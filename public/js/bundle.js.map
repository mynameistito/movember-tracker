{
  "version": 3,
  "sources": ["constants.js", "formatting.js", "logger.js", "parsing.js", "regex-patterns.js", "scraper/html-parsing.js", "scraper/network.js", "cache.js", "scraper/subdomain.js", "scraper/orchestrator.js"],
  "sourcesContent": ["// Mapping of member IDs to their subdomains (manual overrides)\n// Format: \"memberId\": \"subdomain\"\n// Example: \"15023456\": \"fr\" means member 15023456 uses fr.movember.com\n// Note: Subdomains are now auto-detected from redirects, but you can override here if needed\nexport const MEMBER_SUBDOMAIN_MAP = {\n\t// Add manual overrides here if needed\n\t// Example: \"15023456\": \"fr\",\n\t// Example: \"14810348\": \"au\",\n};\n\nexport const DEFAULT_SUBDOMAIN = \"au\"; // Default subdomain to try first\nexport const MOVEMBER_BASE_URL_TEMPLATE =\n\t\"https://{subdomain}.movember.com/donate/details\";\nexport const DEFAULT_MEMBER_ID = \"14810348\"; // Default member ID if none provided\nexport const CACHE_TTL = 300000; // 5 minutes in milliseconds\nexport const SUBDOMAIN_CACHE_TTL = 86400000; // 24 hours in milliseconds (subdomain mappings don't change often)\nexport const MAX_RETRIES = 3;\nexport const RETRY_DELAYS = [1000, 2000, 4000]; // Exponential backoff in milliseconds\n\n// Mapping of subdomain codes to currency codes\n// Format: \"subdomain\": \"CURRENCY_CODE\"\nexport const SUBDOMAIN_CURRENCY_MAP = {\n\tuk: \"GBP\", // United Kingdom - British Pound\n\tau: \"AUD\", // Australia - Australian Dollar\n\tus: \"USD\", // United States - US Dollar\n\tca: \"CAD\", // Canada - Canadian Dollar\n\tnz: \"NZD\", // New Zealand - New Zealand Dollar\n\tie: \"EUR\", // Ireland - Euro\n\tza: \"ZAR\", // South Africa - South African Rand\n\tnl: \"EUR\", // Netherlands - Euro\n\tde: \"EUR\", // Germany - Euro\n\tfr: \"EUR\", // France - Euro\n\tes: \"EUR\", // Spain - Euro\n\tit: \"EUR\", // Italy - Euro\n\tex: \"EUR\", // Unknown/Experimental - Euro (default)\n\tcz: \"CZK\", // Czech Republic - Czech Koruna\n\tdk: \"DKK\", // Denmark - Danish Krone\n\tse: \"SEK\", // Sweden - Swedish Krona\n};\n\n/**\n * Get currency code from subdomain\n * @param {string} subdomain - The subdomain code (e.g., \"uk\", \"au\", \"us\")\n * @returns {string} The currency code (e.g., \"GBP\", \"AUD\", \"USD\"), defaults to \"AUD\" if not found\n * @example\n * getCurrencyFromSubdomain(\"uk\") // \"GBP\"\n * getCurrencyFromSubdomain(\"au\") // \"AUD\"\n * getCurrencyFromSubdomain(\"us\") // \"USD\"\n */\nexport function getCurrencyFromSubdomain(subdomain) {\n\tif (!subdomain) {\n\t\treturn \"AUD\"; // Default currency\n\t}\n\treturn SUBDOMAIN_CURRENCY_MAP[subdomain.toLowerCase()] || \"AUD\";\n}\n\n// Mapping of currency codes to currency symbols\nconst CURRENCY_SYMBOL_MAP = {\n\tUSD: \"$\", // US Dollar\n\tAUD: \"$\", // Australian Dollar\n\tCAD: \"$\", // Canadian Dollar\n\tNZD: \"$\", // New Zealand Dollar\n\tGBP: \"\u00A3\", // British Pound\n\tEUR: \"\u20AC\", // Euro\n\tJPY: \"\u00A5\", // Japanese Yen\n\tZAR: \"R\", // South African Rand\n\tCZK: \"K\u010D\", // Czech Koruna\n\tDKK: \"kr\", // Danish Krone\n\tSEK: \"kr\", // Swedish Krona\n};\n\n/**\n * Get currency symbol from currency code\n * @param {string} currencyCode - The currency code (e.g., \"USD\", \"GBP\", \"EUR\")\n * @returns {string} The currency symbol (e.g., \"$\", \"\u00A3\", \"\u20AC\"), defaults to \"$\" if not found\n * @example\n * getCurrencySymbol(\"USD\") // \"$\"\n * getCurrencySymbol(\"GBP\") // \"\u00A3\"\n * getCurrencySymbol(\"EUR\") // \"\u20AC\"\n */\nexport function getCurrencySymbol(currencyCode) {\n\tif (!currencyCode) {\n\t\treturn \"$\"; // Default symbol\n\t}\n\treturn CURRENCY_SYMBOL_MAP[currencyCode.toUpperCase()] || \"$\";\n}\n\n/**\n * Get the Worker's proxy URL\n * Uses the current origin (the Worker's domain) for the proxy endpoint\n * @returns {string} The proxy URL (e.g., \"https://example.com/proxy\")\n * @example\n * getProxyUrl() // \"https://movember-tracker.example.com/proxy\"\n */\nexport function getProxyUrl() {\n\t// Use the current origin (the Worker's domain) for the proxy\n\treturn `${window.location.origin}/proxy`;\n}\n", "/**\n * Format duration in human-readable format\n * @param {number} ms - Duration in milliseconds\n * @returns {string} Formatted duration string (e.g., \"2m 30s (150000ms)\" or \"45s (45000ms)\")\n * @example\n * formatDuration(150000) // \"2m 30s (150000ms)\"\n * formatDuration(45000) // \"45s (45000ms)\"\n */\nexport const formatDuration = (ms) => {\n\tconst seconds = Math.round(ms / 1000);\n\tconst minutes = Math.floor(seconds / 60);\n\tconst remainingSeconds = seconds % 60;\n\n\tif (minutes > 0) {\n\t\treturn `${minutes}m ${remainingSeconds}s (${ms}ms)`;\n\t}\n\treturn `${seconds}s (${ms}ms)`;\n};\n\n/**\n * Sleep for a specified duration (useful for delays/retries)\n * @param {number} ms - Duration to sleep in milliseconds\n * @returns {Promise<void>} Promise that resolves after the specified duration\n * @example\n * await sleep(1000); // Sleep for 1 second\n */\nexport const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n", "/**\n * Structured logger for client-side code\n * Supports log levels: DEBUG, INFO, WARN, ERROR\n * Can be disabled in production by setting LOG_LEVEL to 'NONE'\n */\n\n// Log levels (higher number = more important)\nconst LOG_LEVELS = {\n\tDEBUG: 0,\n\tINFO: 1,\n\tWARN: 2,\n\tERROR: 3,\n\tNONE: 4,\n};\n\n// Default log level (can be overridden via localStorage or environment)\nlet currentLogLevel = LOG_LEVELS.INFO;\n\n// Initialize log level from localStorage or default\nfunction initializeLogLevel() {\n\ttry {\n\t\tconst stored = localStorage.getItem(\"LOG_LEVEL\");\n\t\tif (stored) {\n\t\t\tconst level = stored.toUpperCase();\n\t\t\tif (level in LOG_LEVELS) {\n\t\t\t\tcurrentLogLevel = LOG_LEVELS[level];\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t// localStorage unavailable (e.g., in private browsing mode)\n\t\t// Log to console as fallback since logger isn't initialized yet\n\t\tif (typeof console !== \"undefined\" && console.warn) {\n\t\t\tconsole.warn(\n\t\t\t\t\"[LOGGER] localStorage unavailable, using default log level:\",\n\t\t\t\terror instanceof Error ? error.message : String(error),\n\t\t\t);\n\t\t}\n\t}\n\n\t// Default to INFO in production, DEBUG in development\n\t// You can detect development mode via URL or other means\n\tconst isDevelopment =\n\t\twindow.location.hostname === \"localhost\" ||\n\t\twindow.location.hostname === \"127.0.0.1\" ||\n\t\twindow.location.search.includes(\"debug=true\");\n\n\tcurrentLogLevel = isDevelopment ? LOG_LEVELS.DEBUG : LOG_LEVELS.INFO;\n}\n\n// Initialize on load\ninitializeLogLevel();\n\n/**\n * Format log message with prefix\n */\nfunction formatMessage(level, prefix, ...args) {\n\tconst timestamp = new Date().toISOString();\n\treturn [`[${timestamp}] [${level}] ${prefix}`, ...args];\n}\n\n/**\n * Check if log level should be output\n */\nfunction shouldLog(level) {\n\treturn LOG_LEVELS[level] >= currentLogLevel;\n}\n\n/**\n * Logger object with methods for each log level\n */\nexport const logger = {\n\t/**\n\t * Set the log level\n\t * @param {string} level - One of: 'DEBUG', 'INFO', 'WARN', 'ERROR', 'NONE'\n\t */\n\tsetLevel(level) {\n\t\tconst upperLevel = level.toUpperCase();\n\t\tif (upperLevel in LOG_LEVELS) {\n\t\t\tcurrentLogLevel = LOG_LEVELS[upperLevel];\n\t\t\ttry {\n\t\t\t\tlocalStorage.setItem(\"LOG_LEVEL\", upperLevel);\n\t\t\t} catch (error) {\n\t\t\t\t// localStorage unavailable - log using logger itself\n\t\t\t\t// Use console as fallback if logger fails\n\t\t\t\ttry {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\"[LOGGER]\",\n\t\t\t\t\t\t\"Failed to persist log level to localStorage:\",\n\t\t\t\t\t\terror instanceof Error ? error.message : String(error),\n\t\t\t\t\t);\n\t\t\t\t} catch {\n\t\t\t\t\t// If logger also fails, use console directly\n\t\t\t\t\tif (typeof console !== \"undefined\" && console.warn) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t\"[LOGGER] Failed to persist log level:\",\n\t\t\t\t\t\t\terror instanceof Error ? error.message : String(error),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Get the current log level\n\t * @returns {string} Current log level name\n\t */\n\tgetLevel() {\n\t\tfor (const [name, value] of Object.entries(LOG_LEVELS)) {\n\t\t\tif (value === currentLogLevel) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\t\treturn \"INFO\";\n\t},\n\n\t/**\n\t * Debug level logging (most verbose)\n\t */\n\tdebug(prefix, ...args) {\n\t\tif (shouldLog(\"DEBUG\")) {\n\t\t\tconsole.debug(...formatMessage(\"DEBUG\", prefix, ...args));\n\t\t}\n\t},\n\n\t/**\n\t * Info level logging (default)\n\t */\n\tinfo(prefix, ...args) {\n\t\tif (shouldLog(\"INFO\")) {\n\t\t\tconsole.log(...formatMessage(\"INFO\", prefix, ...args));\n\t\t}\n\t},\n\n\t/**\n\t * Warning level logging\n\t */\n\twarn(prefix, ...args) {\n\t\tif (shouldLog(\"WARN\")) {\n\t\t\tconsole.warn(...formatMessage(\"WARN\", prefix, ...args));\n\t\t}\n\t},\n\n\t/**\n\t * Error level logging\n\t */\n\terror(prefix, ...args) {\n\t\tif (shouldLog(\"ERROR\")) {\n\t\t\tconsole.error(...formatMessage(\"ERROR\", prefix, ...args));\n\t\t}\n\t},\n};\n\n// Export default logger\nexport default logger;\n", "import { getCurrencyFromSubdomain } from \"./constants.js\";\n\n/**\n * Extract amount from text and determine currency from subdomain\n * Currency is ALWAYS determined from subdomain, never from HTML/text parsing\n * @param {string} text - The text containing the amount (may include currency symbols)\n * @param {string} subdomain - Required subdomain (e.g., \"uk\", \"au\", \"us\") to determine currency\n * @returns {{value: string, currency: string}} Object containing the extracted amount value and currency code\n * @example\n * parseAmount(\"$1,234.56\", \"us\") // { value: \"1,234.56\", currency: \"USD\" }\n * parseAmount(\"\u00A3500\", \"uk\") // { value: \"500\", currency: \"GBP\" }\n */\nexport const parseAmount = (text, subdomain) => {\n\t// Remove whitespace and extract amount\n\tconst cleaned = text.trim();\n\n\t// Always use subdomain to determine currency - this is the source of truth\n\t// If subdomain is not provided, default to AUD\n\tconst currency = subdomain ? getCurrencyFromSubdomain(subdomain) : \"AUD\";\n\n\t// Extract amount (supports numbers with commas and optional decimals)\n\t// Remove currency symbols and codes before extracting number\n\tconst cleanedForAmount = cleaned\n\t\t.replace(/[$\u20AC\u00A3\u00A5]|\\b(USD|EUR|GBP|AUD|JPY|CAD|NZD|ZAR)\\b/gi, \"\")\n\t\t.trim();\n\tconst amountMatch = cleanedForAmount.match(/[\\d,]+\\.?\\d*/);\n\tconst amount = amountMatch ? amountMatch[0] : \"0\";\n\n\treturn { value: amount, currency };\n};\n\n/**\n * Validate that a captured value is a valid number\n * Checks for digits, removes currency symbols, and ensures the value is not just symbols\n * @param {string} value - The value to validate\n * @returns {boolean} True if the value is a valid number, false otherwise\n * @example\n * isValidNumber(\"1,234.56\") // true\n * isValidNumber(\"$500\") // true\n * isValidNumber(\"abc\") // false\n * isValidNumber(\"$\") // false\n */\nexport const isValidNumber = (value) => {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn false;\n\t}\n\t// Remove commas, spaces, and currency symbols, then check if we have at least one digit\n\tconst cleaned = value.replace(/[,.\\s$\u20AC\u00A3\u00A5]/g, \"\");\n\t// Must have at least one digit and be a valid number\n\tif (!cleaned || cleaned.length === 0 || !/^\\d+$/.test(cleaned)) {\n\t\treturn false;\n\t}\n\t// Additional check: the original value should contain at least one digit\n\tif (!/\\d/.test(value)) {\n\t\treturn false;\n\t}\n\t// Reject if value is just commas, spaces, or currency symbols\n\tif (/^[,.\\s$\u20AC\u00A3\u00A5]+$/.test(value)) {\n\t\treturn false;\n\t}\n\treturn true;\n};\n\n/**\n * Calculate percentage of raised amount relative to target\n * @param {string} raised - The raised amount (may include commas)\n * @param {string} target - The target amount (may include commas)\n * @returns {number} The percentage (0-100), or 0 if target is 0\n * @example\n * calculatePercentage(\"2,500\", \"10,000\") // 25\n * calculatePercentage(\"500\", \"1,000\") // 50\n */\nexport const calculatePercentage = (raised, target) => {\n\tconst raisedNum = parseFloat(raised.replace(/,/g, \"\"));\n\tconst targetNum = parseFloat(target.replace(/,/g, \"\"));\n\tif (targetNum === 0) return 0;\n\treturn Math.round((raisedNum / targetNum) * 100);\n};\n", "/**\n * Centralized regex patterns for Movember page scraping\n * All patterns are pre-compiled for better performance\n */\n\n// URL extraction patterns\nexport const URL_PATTERNS = {\n\t/**\n\t * Extract subdomain from Movember URL\n\t * Matches: https://uk.movember.com -> \"uk\"\n\t */\n\tSUBDOMAIN: /https?:\\/\\/([^.]+)\\.movember\\.com/,\n};\n\n// Currency code patterns for subdomain detection\nexport const CURRENCY_CODE_PATTERNS = [\n\t/\\bGBP\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bGBP\\b|British\\s+Pound/i,\n\t/\\bEUR\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bEUR\\b|Euro[\\s:]*[\\d,]+/i,\n\t/\\bUSD\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bUSD\\b|US\\s+Dollar/i,\n\t/\\bAUD\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bAUD\\b|Australian\\s+Dollar/i,\n\t/\\bCAD\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bCAD\\b|Canadian\\s+Dollar/i,\n\t/\\bNZD\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bNZD\\b|New\\s+Zealand\\s+Dollar/i,\n\t/\\bZAR\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bZAR\\b|South\\s+African\\s+Rand/i,\n\t/\\bCZK\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bCZK\\b|Czech\\s+Koruna|K\u010D[\\d,]+/i,\n\t/\\bSEK\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bSEK\\b|Swedish\\s+Krona/i,\n\t/\\bDKK\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bDKK\\b|Danish\\s+Krone/i,\n];\n\n// Country detection patterns\nexport const COUNTRY_DETECTION_PATTERNS = {\n\tIRELAND: /Ireland|Irish/i,\n\tNETHERLANDS: /Netherlands|Dutch/i,\n\tGERMANY: /Germany|German/i,\n\tFRANCE: /France|French/i,\n\tSPAIN: /Spain|Spanish/i,\n\tITALY: /Italy|Italian/i,\n\tUNITED_STATES: /United\\s+States|US\\s+Dollar/i,\n\tCANADA: /Canada|Canadian/i,\n\tNEW_ZEALAND: /New\\s+Zealand/i,\n\tAUSTRALIA: /Australia|Australian/i,\n};\n\n// Dollar amount pattern (ambiguous, used as fallback)\nexport const DOLLAR_AMOUNT_PATTERN = /\\$[\\d,]+/;\n\n// Raised amount extraction patterns (optimized with combined patterns)\n// Patterns are grouped by similarity and combined using alternation for better performance\nexport const RAISED_PATTERNS = [\n\t// Group 1: AmountRaised object patterns (most reliable) - combined\n\t/\"AmountRaised\"[^}]*\"(?:convertedAmount|originalAmount)\"[\"\\s:]*[\"']([\\d,]+(?:\\.\\d+)?)/i,\n\t// Group 2: CSS class patterns with dollar sign - combined\n\t/donationProgress--amount__raised[^>]*>([^<]*\\$([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\n\t// Group 3: CSS class with class attribute - separate (different structure)\n\t/class=\"[^\"]*donationProgress--amount__raised[^\"]*\"[^>]*>[\\s\\S]*?\\$([\\d,]+(?:\\.\\d+)?)/i,\n\t// Group 4: JSON property patterns - combined\n\t/\"(?:raised|raisedAmount|currentAmount)\"[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Group 5: Data attribute patterns - combined\n\t/data-(?:raised|amount)=[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Group 6: CSS class with currency symbols - separate (different capture groups)\n\t/donationProgress--amount__raised[^>]*>([^<]*[\u20AC\u00A3$]([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\n\t// Group 7: CSS class with currency codes - separate (different capture groups)\n\t/donationProgress--amount__raised[^>]*>([^<]*(?:USD|EUR|GBP|AUD)\\s*([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\n];\n\n// Target amount extraction patterns (optimized with combined patterns)\n// Patterns are grouped by similarity and combined using alternation for better performance\nexport const TARGET_PATTERNS = [\n\t// Group 1: target.fundraising.value (most reliable) - separate (most specific)\n\t/\"target\"[^}]*\"fundraising\"[^}]*\"value\"[\"\\s:]*[\"']([\\d,]+(?:\\.\\d+)?)/i,\n\t// Group 2: CSS class patterns with dollar sign - combined\n\t/donationProgress--amount__target[^>]*>([^<]*\\$([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\n\t// Group 3: CSS class with class attribute - separate (different structure)\n\t/class=\"[^\"]*donationProgress--amount__target[^\"]*\"[^>]*>[\\s\\S]*?\\$([\\d,]+(?:\\.\\d+)?)/i,\n\t// Group 4: JSON property patterns - combined\n\t/\"(?:target|targetAmount|goal)\"[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Group 5: Data attribute patterns - combined\n\t/data-(?:target|goal)=[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Group 6: CSS class with currency symbols - separate (different capture groups)\n\t/donationProgress--amount__target[^>]*>([^<]*[\u20AC\u00A3$]([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\n\t// Group 7: CSS class with currency codes - separate (different capture groups)\n\t/donationProgress--amount__target[^>]*>([^<]*(?:USD|EUR|GBP|AUD)\\s*([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\n];\n\n// JSON script tag patterns for raised amounts (optimized with combined patterns)\nexport const RAISED_JSON_PATTERNS = [\n\t// Combined JSON property patterns\n\t/\"(?:raised|raisedAmount|currentAmount|donationAmount|amount)\"[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Unquoted property pattern (separate due to different structure)\n\t/raised[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n];\n\n// JSON script tag patterns for target amounts (optimized with combined patterns)\nexport const TARGET_JSON_PATTERNS = [\n\t// Combined JSON property patterns\n\t/\"(?:target|targetAmount|goal)\"[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Unquoted property patterns - combined\n\t/(?:target|goal)[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n];\n\n// Generic fallback patterns for raised amounts\nexport const GENERIC_RAISED_PATTERNS = [\n\t// Look for $X,XXX pattern in common HTML structures\n\t/\\$([\\d,]+(?:\\.\\d+)?)\\s*(?:raised|donated|collected)/i,\n\t/(?:raised|donated|collected)[:\\s]*\\$([\\d,]+(?:\\.\\d+)?)/i,\n\t// Look for amounts in div/span elements\n\t/<[^>]+class=\"[^\"]*(?:amount|raised|donation|progress)[^\"]*\"[^>]*>\\s*\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Look for amounts in data attributes\n\t/data-[^=]*amount[^=]*=[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Look for amounts near \"of\" or \"out of\" (progress indicators)\n\t/\\$([\\d,]+(?:\\.\\d+)?)\\s*(?:of|out of)/i,\n\t// Look for amounts in JSON-like structures without quotes\n\t/raised[:\\s=]+[$]?([\\d,]+(?:\\.\\d+)?)/i,\n\t/amount[:\\s=]+[$]?([\\d,]+(?:\\.\\d+)?)/i,\n];\n\n// Generic fallback patterns for target amounts\nexport const GENERIC_TARGET_PATTERNS = [\n\t// Look for $X,XXX pattern with target/goal keywords\n\t/\\$([\\d,]+(?:\\.\\d+)?)\\s*(?:target|goal)/i,\n\t/(?:target|goal)[:\\s]*\\$([\\d,]+(?:\\.\\d+)?)/i,\n\t// Look for amounts in div/span elements with target/goal classes\n\t/<[^>]+class=\"[^\"]*(?:target|goal)[^\"]*\"[^>]*>\\s*\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Look for amounts in data attributes\n\t/data-[^=]*(?:target|goal)[^=]*=[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Look for amounts near \"of\" or \"out of\" with target/goal context\n\t/\\$([\\d,]+(?:\\.\\d+)?)\\s*(?:of|out of)\\s*\\$([\\d,]+(?:\\.\\d+)?)/i,\n\t// Look for amounts in JSON-like structures without quotes\n\t/target[:\\s=]+[$]?([\\d,]+(?:\\.\\d+)?)/i,\n\t/goal[:\\s=]+[$]?([\\d,]+(?:\\.\\d+)?)/i,\n];\n", "/**\n * HTML parsing logic for extracting donation amounts from Movember pages\n * @module scraper/html-parsing\n */\n\nimport { formatDuration } from \"../formatting.js\";\nimport logger from \"../logger.js\";\nimport { isValidNumber } from \"../parsing.js\";\nimport {\n\tGENERIC_RAISED_PATTERNS,\n\tGENERIC_TARGET_PATTERNS,\n\tRAISED_JSON_PATTERNS,\n\tRAISED_PATTERNS,\n\tTARGET_JSON_PATTERNS,\n\tTARGET_PATTERNS,\n} from \"../regex-patterns.js\";\n\n/**\n * Extract raised amount from HTML using multiple pattern strategies\n * @param {string} html - The HTML content to parse\n * @returns {string} The extracted raised amount or empty string if not found\n */\nexport function extractRaisedAmount(html) {\n\tlet raised = \"\";\n\n\t// Look for the raised amount in the HTML\n\t// Try multiple patterns to find the data\n\tfor (let i = 0; i < RAISED_PATTERNS.length; i++) {\n\t\tconst pattern = RAISED_PATTERNS[i];\n\t\tconst match = html.match(pattern);\n\t\tif (match) {\n\t\t\t// Get the last capture group (the amount), but also check all groups\n\t\t\tlet captured = match[match.length - 1];\n\n\t\t\t// If the last group is empty or invalid, try the second-to-last\n\t\t\tif (!captured || !isValidNumber(captured)) {\n\t\t\t\tif (match.length > 2) {\n\t\t\t\t\tcaptured = match[match.length - 2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogger.debug(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`Pattern ${i + 1} matched, all groups:`,\n\t\t\t\tmatch.slice(1),\n\t\t\t\t`using: \"${captured}\"`,\n\t\t\t);\n\n\t\t\t// Validate that we captured a valid number\n\t\t\tif (isValidNumber(captured)) {\n\t\t\t\traised = captured;\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t`Found valid raised amount using pattern ${i + 1}: ${raised}`,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t`Pattern ${i + 1} matched but invalid number: \"${captured}\", trying next pattern...`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback: Look for JSON data in script tags\n\tif (!raised) {\n\t\tlogger.info(\"[SCRAPE]\", \"Checking for JSON data in script tags...\");\n\t\tconst scriptTagMatches = html.match(/<script[^>]*>([\\s\\S]*?)<\\/script>/gi);\n\t\tif (scriptTagMatches) {\n\t\t\tfor (const scriptTag of scriptTagMatches) {\n\t\t\t\t// Look for JSON data containing donation amounts with improved patterns\n\t\t\t\t// Try to find raised amount in JSON\n\t\t\t\tfor (let i = 0; i < RAISED_JSON_PATTERNS.length; i++) {\n\t\t\t\t\tconst pattern = RAISED_JSON_PATTERNS[i];\n\t\t\t\t\tconst match = scriptTag.match(pattern);\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tconst captured = match[1];\n\t\t\t\t\t\tif (isValidNumber(captured)) {\n\t\t\t\t\t\t\traised = captured;\n\t\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t\t\t\t`Found valid raised amount in JSON using pattern ${i + 1}: ${raised}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t\t\t\t`JSON raised pattern ${i + 1} matched but invalid number: \"${captured}\"`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (raised) break;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Last resort: Look for any dollar amounts in the HTML (more generic patterns)\n\tif (!raised) {\n\t\tlogger.info(\n\t\t\t\"[SCRAPE]\",\n\t\t\t\"Trying generic dollar amount patterns as last resort...\",\n\t\t);\n\t\tfor (let i = 0; i < GENERIC_RAISED_PATTERNS.length; i++) {\n\t\t\tconst pattern = GENERIC_RAISED_PATTERNS[i];\n\t\t\tconst match = html.match(pattern);\n\t\t\tif (match) {\n\t\t\t\tconst captured = match[1];\n\t\t\t\tif (isValidNumber(captured)) {\n\t\t\t\t\traised = captured;\n\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t\t`Found valid raised amount using generic pattern ${i + 1}: ${raised}`,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t\t`Generic pattern ${i + 1} matched but invalid number: \"${captured}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Final aggressive search: Find all dollar amounts and check their context\n\tif (!raised) {\n\t\tlogger.info(\"[SCRAPE]\", \"Performing aggressive context-based search...\");\n\t\tconst allDollarMatches = [...html.matchAll(/\\$([\\d,]+(?:\\.\\d+)?)/g)];\n\t\tlogger.debug(\n\t\t\t\"[SCRAPE]\",\n\t\t\t`Found ${allDollarMatches.length} dollar amounts in HTML`,\n\t\t);\n\n\t\tif (allDollarMatches.length > 0) {\n\t\t\t// Score each dollar amount based on context\n\t\t\tconst scoredAmounts = [];\n\n\t\t\tfor (const match of allDollarMatches) {\n\t\t\t\tconst amount = match[1];\n\t\t\t\tif (!isValidNumber(amount)) continue;\n\n\t\t\t\tconst matchIndex = match.index;\n\t\t\t\tconst contextStart = Math.max(0, matchIndex - 300);\n\t\t\t\tconst contextEnd = Math.min(\n\t\t\t\t\thtml.length,\n\t\t\t\t\tmatchIndex + match[0].length + 300,\n\t\t\t\t);\n\t\t\t\tconst context = html.substring(contextStart, contextEnd).toLowerCase();\n\n\t\t\t\tlet raisedScore = 0;\n\n\t\t\t\t// Score for raised amounts\n\t\t\t\tif (\n\t\t\t\t\t/(?:raised|donated|collected|current|funds?|progress|amount\\s*(?:raised|donated))/i.test(\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\traisedScore += 10;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t/(?:has\\s+raised|has\\s+donated|has\\s+collected|currently\\s+raised)/i.test(\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\traisedScore += 5;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t/\\$[\\d,]+(?:\\.\\d+)?\\s*(?:raised|donated|collected)/i.test(context)\n\t\t\t\t) {\n\t\t\t\t\traisedScore += 8;\n\t\t\t\t}\n\n\t\t\t\t// Store with score\n\t\t\t\tif (raisedScore > 0) {\n\t\t\t\t\tscoredAmounts.push({\n\t\t\t\t\t\tamount,\n\t\t\t\t\t\tscore: raisedScore,\n\t\t\t\t\t\traisedScore,\n\t\t\t\t\t\tcontext: context.substring(0, 200),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Sort by score and pick the best candidate\n\t\t\tscoredAmounts.sort((a, b) => b.raisedScore - a.raisedScore);\n\n\t\t\t// Try to find raised amount\n\t\t\tif (scoredAmounts.length > 0) {\n\t\t\t\t// Look for amounts with raised-related context, sorted by raisedScore\n\t\t\t\tconst raisedCandidates = scoredAmounts\n\t\t\t\t\t.filter((a) => a.raisedScore > 0)\n\t\t\t\t\t.sort((a, b) => b.raisedScore - a.raisedScore);\n\t\t\t\tif (raisedCandidates.length > 0) {\n\t\t\t\t\traised = raisedCandidates[0].amount;\n\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t\t`Found raised amount via context search: ${raised} (raisedScore: ${raisedCandidates[0].raisedScore})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn raised;\n}\n\n/**\n * Extract target amount from HTML using multiple pattern strategies\n * @param {string} html - The HTML content to parse\n * @returns {string} The extracted target amount or empty string if not found\n */\nexport function extractTargetAmount(html) {\n\tlet target = \"\";\n\n\t// Look for the target amount in the HTML\n\tfor (let i = 0; i < TARGET_PATTERNS.length; i++) {\n\t\tconst pattern = TARGET_PATTERNS[i];\n\t\tconst match = html.match(pattern);\n\t\tif (match) {\n\t\t\t// Get the last capture group (the amount), but also check all groups\n\t\t\tlet captured = match[match.length - 1];\n\n\t\t\t// If the last group is empty or invalid, try the second-to-last\n\t\t\tif (!captured || !isValidNumber(captured)) {\n\t\t\t\tif (match.length > 2) {\n\t\t\t\t\tcaptured = match[match.length - 2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogger.debug(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`Target pattern ${i + 1} matched, all groups:`,\n\t\t\t\tmatch.slice(1),\n\t\t\t\t`using: \"${captured}\"`,\n\t\t\t);\n\n\t\t\t// Validate that we captured a valid number\n\t\t\tif (isValidNumber(captured)) {\n\t\t\t\ttarget = captured;\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t`Found valid target amount using pattern ${i + 1}: ${target}`,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t`Target pattern ${i + 1} matched but invalid number: \"${captured}\", trying next pattern...`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback: Look for JSON data in script tags\n\tif (!target) {\n\t\tconst scriptTagMatches = html.match(/<script[^>]*>([\\s\\S]*?)<\\/script>/gi);\n\t\tif (scriptTagMatches) {\n\t\t\tfor (const scriptTag of scriptTagMatches) {\n\t\t\t\t// Try to find target amount in JSON\n\t\t\t\tfor (let i = 0; i < TARGET_JSON_PATTERNS.length; i++) {\n\t\t\t\t\tconst pattern = TARGET_JSON_PATTERNS[i];\n\t\t\t\t\tconst match = scriptTag.match(pattern);\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tconst captured = match[1];\n\t\t\t\t\t\tif (isValidNumber(captured)) {\n\t\t\t\t\t\t\ttarget = captured;\n\t\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t\t\t\t`Found valid target amount in JSON using pattern ${i + 1}: ${target}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t\t\t\t`JSON target pattern ${i + 1} matched but invalid number: \"${captured}\"`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (target) break;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Last resort: Look for any dollar amounts in the HTML (more generic patterns)\n\tif (!target) {\n\t\tlogger.info(\n\t\t\t\"[SCRAPE]\",\n\t\t\t\"Trying generic target amount patterns as last resort...\",\n\t\t);\n\t\tfor (let i = 0; i < GENERIC_TARGET_PATTERNS.length; i++) {\n\t\t\tconst pattern = GENERIC_TARGET_PATTERNS[i];\n\t\t\tconst match = html.match(pattern);\n\t\t\tif (match) {\n\t\t\t\tconst captured = match[1];\n\t\t\t\tif (isValidNumber(captured)) {\n\t\t\t\t\ttarget = captured;\n\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t\t`Found valid target amount using generic pattern ${i + 1}: ${target}`,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t\t`Generic target pattern ${i + 1} matched but invalid number: \"${captured}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Final aggressive search: Find all dollar amounts and check their context\n\tif (!target) {\n\t\tconst allDollarMatches = [...html.matchAll(/\\$([\\d,]+(?:\\.\\d+)?)/g)];\n\n\t\tif (allDollarMatches.length > 0) {\n\t\t\t// Score each dollar amount based on context\n\t\t\tconst scoredAmounts = [];\n\n\t\t\tfor (const match of allDollarMatches) {\n\t\t\t\tconst amount = match[1];\n\t\t\t\tif (!isValidNumber(amount)) continue;\n\n\t\t\t\tconst matchIndex = match.index;\n\t\t\t\tconst contextStart = Math.max(0, matchIndex - 300);\n\t\t\t\tconst contextEnd = Math.min(\n\t\t\t\t\thtml.length,\n\t\t\t\t\tmatchIndex + match[0].length + 300,\n\t\t\t\t);\n\t\t\t\tconst context = html.substring(contextStart, contextEnd).toLowerCase();\n\n\t\t\t\tlet targetScore = 0;\n\n\t\t\t\t// Score for target amounts\n\t\t\t\tif (/(?:target|goal|aim|objective|of\\s+\\$)/i.test(context)) {\n\t\t\t\t\ttargetScore += 10;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t/(?:target\\s+(?:of|is)|goal\\s+(?:of|is)|aim\\s+(?:of|is))/i.test(\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\ttargetScore += 5;\n\t\t\t\t}\n\t\t\t\tif (/\\$[\\d,]+(?:\\.\\d+)?\\s*(?:target|goal)/i.test(context)) {\n\t\t\t\t\ttargetScore += 8;\n\t\t\t\t}\n\n\t\t\t\t// Store with score\n\t\t\t\tif (targetScore > 0) {\n\t\t\t\t\tscoredAmounts.push({\n\t\t\t\t\t\tamount,\n\t\t\t\t\t\tscore: targetScore,\n\t\t\t\t\t\ttargetScore,\n\t\t\t\t\t\tcontext: context.substring(0, 200),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Sort by score and pick the best candidate\n\t\t\tscoredAmounts.sort((a, b) => b.targetScore - a.targetScore);\n\n\t\t\t// Try to find target amount\n\t\t\tif (scoredAmounts.length > 0) {\n\t\t\t\t// Look for amounts with target-related context, sorted by targetScore\n\t\t\t\tconst targetCandidates = scoredAmounts\n\t\t\t\t\t.filter((a) => a.targetScore > 0)\n\t\t\t\t\t.sort((a, b) => b.targetScore - a.targetScore);\n\t\t\t\tif (targetCandidates.length > 0) {\n\t\t\t\t\ttarget = targetCandidates[0].amount;\n\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t\t`Found target amount via context search: ${target} (targetScore: ${targetCandidates[0].targetScore})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn target;\n}\n\n/**\n * Extract both raised and target amounts from HTML\n * @param {string} html - The HTML content to parse\n * @param {string} memberId - The member ID (for logging)\n * @param {string} subdomain - The subdomain (for logging)\n * @returns {{raised: string, target: string}} Object containing extracted amounts\n */\nexport function extractAmounts(html, memberId, subdomain) {\n\tconst extractStart = Date.now();\n\tlogger.info(\"[SCRAPE]\", \"Extracting data from HTML...\");\n\n\tconst raised = extractRaisedAmount(html);\n\tconst target = extractTargetAmount(html);\n\n\tconst extractDuration = Date.now() - extractStart;\n\tlogger.info(\n\t\t\"[SCRAPE]\",\n\t\t`Data extraction completed in ${formatDuration(extractDuration)}`,\n\t);\n\tlogger.debug(\n\t\t\"[SCRAPE]\",\n\t\t`Raw extracted data for memberId ${memberId} (subdomain: ${subdomain}):`,\n\t\t{\n\t\t\traised: raised || \"NOT FOUND\",\n\t\t\ttarget: target || \"NOT FOUND\",\n\t\t},\n\t);\n\n\treturn { raised, target };\n}\n", "/**\n * Network utilities for fetching Movember pages via proxy\n * @module scraper/network\n */\n\nimport { getProxyUrl, MOVEMBER_BASE_URL_TEMPLATE } from \"../constants.js\";\nimport logger from \"../logger.js\";\nimport { URL_PATTERNS } from \"../regex-patterns.js\";\n\n/**\n * Extract subdomain from a Movember URL\n * @param {string} url - The Movember URL\n * @returns {string|null} The subdomain (e.g., \"uk\", \"au\", \"us\") or null if not found\n */\nexport function extractSubdomainFromUrl(url) {\n\tconst match = url.match(URL_PATTERNS.SUBDOMAIN);\n\treturn match ? match[1] : null;\n}\n\n/**\n * Fetch HTML using Worker's CORS proxy\n * Returns both HTML and the final URL after redirects\n * @param {string} url - The URL to fetch\n * @returns {Promise<{html: string, finalUrl: string}>} The HTML content and final URL\n * @throws {Error} If the proxy request fails\n */\nexport async function fetchViaProxy(url) {\n\tconst proxyUrl = `${getProxyUrl()}?url=${encodeURIComponent(url)}`;\n\tconst response = await fetch(proxyUrl);\n\n\tif (!response.ok) {\n\t\t// Try to get error message from response\n\t\tlet errorMessage = `Proxy error! status: ${response.status}`;\n\t\ttry {\n\t\t\tconst contentType = response.headers.get(\"content-type\");\n\t\t\tif (contentType?.includes(\"application/json\")) {\n\t\t\t\tconst errorData = await response.json();\n\t\t\t\tif (errorData.message) {\n\t\t\t\t\terrorMessage = errorData.message;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst errorText = await response.text();\n\t\t\t\tif (errorText) {\n\t\t\t\t\terrorMessage = errorText.substring(0, 200); // Limit error message length\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// Ignore parse errors, use default error message\n\t\t\tlogger.warn(\"[PROXY]\", \"Could not parse error response:\", e);\n\t\t}\n\t\tthrow new Error(errorMessage);\n\t}\n\n\t// Worker proxy returns HTML directly\n\tconst html = await response.text();\n\t// Get final URL after redirects from response header\n\tconst finalUrl = response.headers.get(\"X-Final-URL\") || url;\n\n\treturn { html, finalUrl };\n}\n\n/**\n * Build Movember URL with correct subdomain for a member\n * @param {string} memberId - The member ID\n * @param {string} subdomain - The subdomain to use\n * @returns {string} The complete Movember URL\n */\nexport function buildMovemberUrl(memberId, subdomain) {\n\tconst baseUrl = MOVEMBER_BASE_URL_TEMPLATE.replace(\"{subdomain}\", subdomain);\n\treturn `${baseUrl}?memberId=${memberId}`;\n}\n", "// localStorage cache manager with TTL support\n// Consolidated cache: all data (including subdomain) stored in single key per member\nimport { SUBDOMAIN_CACHE_TTL } from \"./constants.js\";\nimport logger from \"./logger.js\";\n\n/**\n * Get cached donation data for a member (includes subdomain)\n * @param {string} memberId - Member ID\n * @returns {Object|null} Cached data or null if expired/not found\n * Data structure: { amount, currency, target, percentage, timestamp, subdomain }\n */\nexport function getCachedData(memberId) {\n\ttry {\n\t\tconst cacheKey = `movember:data:${memberId}`;\n\t\tconst cached = localStorage.getItem(cacheKey);\n\t\tif (!cached) return null;\n\n\t\tconst { data, cachedAt, ttl } = JSON.parse(cached);\n\t\tconst now = Date.now();\n\n\t\t// Check if cache is expired\n\t\tif (now - cachedAt > ttl) {\n\t\t\tlocalStorage.removeItem(cacheKey);\n\t\t\treturn null;\n\t\t}\n\n\t\treturn data;\n\t} catch (error) {\n\t\tlogger.warn(\"[CACHE]\", \"Error reading cached data:\", error);\n\t\treturn null;\n\t}\n}\n\n/**\n * Set cached donation data for a member (includes subdomain)\n * @param {string} memberId - Member ID\n * @param {Object} data - Data to cache (must include subdomain)\n * @param {number} ttl - Time to live in milliseconds\n */\nexport function setCachedData(memberId, data, ttl) {\n\ttry {\n\t\tconst cacheKey = `movember:data:${memberId}`;\n\t\tconst cacheValue = {\n\t\t\tdata,\n\t\t\tcachedAt: Date.now(),\n\t\t\tttl,\n\t\t};\n\t\tlocalStorage.setItem(cacheKey, JSON.stringify(cacheValue));\n\t} catch (error) {\n\t\tlogger.warn(\"[CACHE]\", \"Error setting cached data:\", error);\n\t}\n}\n\n/**\n * Get cached subdomain for a member (from consolidated cache)\n * Uses subdomain TTL (24h) not data TTL (5min) - subdomain persists longer\n * @param {string} memberId - Member ID\n * @returns {string|null} Cached subdomain or null if expired/not found\n */\nexport function getCachedSubdomain(memberId) {\n\ttry {\n\t\tconst cacheKey = `movember:data:${memberId}`;\n\t\tconst cached = localStorage.getItem(cacheKey);\n\t\tif (!cached) return null;\n\n\t\tconst { data, cachedAt } = JSON.parse(cached);\n\t\tconst now = Date.now();\n\n\t\t// For subdomain, use SUBDOMAIN_CACHE_TTL (24h) instead of data TTL (5min)\n\t\t// Check if subdomain exists in data\n\t\tif (data?.subdomain) {\n\t\t\t// Use longer TTL for subdomain (24 hours)\n\t\t\tif (now - cachedAt > SUBDOMAIN_CACHE_TTL) {\n\t\t\t\t// Subdomain expired, but don't remove cache yet (data might still be valid)\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn data.subdomain;\n\t\t}\n\t\treturn null;\n\t} catch (error) {\n\t\tlogger.warn(\"[CACHE]\", \"Error reading cached subdomain:\", error);\n\t\treturn null;\n\t}\n}\n\n/**\n * Set cached subdomain for a member (updates consolidated cache)\n * @param {string} memberId - Member ID\n * @param {string} subdomain - Subdomain to cache\n * @param {number} ttl - Time to live in milliseconds\n */\nexport function setCachedSubdomain(memberId, subdomain, ttl) {\n\ttry {\n\t\t// Get existing data or create new\n\t\tlet data = getCachedData(memberId);\n\t\tif (!data) {\n\t\t\tdata = {};\n\t\t}\n\n\t\t// Update subdomain in data\n\t\tdata.subdomain = subdomain;\n\n\t\t// Save with the provided TTL\n\t\tsetCachedData(memberId, data, ttl);\n\t} catch (error) {\n\t\tlogger.warn(\"[CACHE]\", \"Error setting cached subdomain:\", error);\n\t}\n}\n\n/**\n * Clear cached data for a member (clears both data and subdomain)\n * @param {string} memberId - Member ID\n */\nexport function clearSubdomainCache(memberId) {\n\ttry {\n\t\tconst cacheKey = `movember:data:${memberId}`;\n\t\tlocalStorage.removeItem(cacheKey);\n\n\t\t// Also clear old separate subdomain cache if it exists (migration cleanup)\n\t\tconst oldSubdomainKey = `movember:subdomain:${memberId}`;\n\t\tlocalStorage.removeItem(oldSubdomainKey);\n\n\t\t// Also clear old amount cache if it exists (migration cleanup)\n\t\tconst oldAmountKey = `movember:amount:${memberId}`;\n\t\tlocalStorage.removeItem(oldAmountKey);\n\t} catch (error) {\n\t\tlogger.warn(\"[CACHE]\", \"Error clearing cached data:\", error);\n\t}\n}\n", "/**\n * Subdomain detection logic for Movember pages\n * @module scraper/subdomain\n */\n\nimport { getCachedSubdomain, setCachedSubdomain } from \"../cache.js\";\nimport {\n\tDEFAULT_SUBDOMAIN,\n\tMEMBER_SUBDOMAIN_MAP,\n\tSUBDOMAIN_CACHE_TTL,\n} from \"../constants.js\";\nimport logger from \"../logger.js\";\nimport {\n\tCOUNTRY_DETECTION_PATTERNS,\n\tCURRENCY_CODE_PATTERNS,\n\tDOLLAR_AMOUNT_PATTERN,\n} from \"../regex-patterns.js\";\nimport {\n\tbuildMovemberUrl,\n\textractSubdomainFromUrl,\n\tfetchViaProxy,\n} from \"./network.js\";\n\n/**\n * Detect subdomain from HTML content by checking currency symbols\n * This is used for verification - if currency doesn't match URL subdomain, we skip it\n * Made more aggressive: checks for currency symbols anywhere, not just near amounts\n * @param {string} html - The HTML content to analyze\n * @returns {string|null} The detected subdomain or null if not found\n */\nexport function detectSubdomainFromHtml(html) {\n\tif (!html) return null;\n\n\t// First, check for unambiguous currency symbols anywhere in HTML (most reliable)\n\t// \u00A3 symbol anywhere indicates UK (GBP)\n\tif (\n\t\thtml.includes(\"\u00A3\") ||\n\t\thtml.includes(\"&pound;\") ||\n\t\thtml.includes(\"&#163;\")\n\t) {\n\t\treturn \"uk\";\n\t}\n\n\t// \u20AC symbol anywhere indicates EU\n\tif (\n\t\thtml.includes(\"\u20AC\") ||\n\t\thtml.includes(\"&euro;\") ||\n\t\thtml.includes(\"&#8364;\")\n\t) {\n\t\t// Try to determine which EU country by checking for country-specific text\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.IRELAND)) return \"ie\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.NETHERLANDS)) return \"nl\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.GERMANY)) return \"de\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.FRANCE)) return \"fr\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.SPAIN)) return \"es\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.ITALY)) return \"it\";\n\t\t// Default to first EU country if we can't determine\n\t\treturn \"ie\";\n\t}\n\n\t// Look for currency codes near amounts (secondary check)\n\t// Pattern: currency code followed by amount, or amount followed by currency code\n\n\t// Check for GBP code near amounts (UK) - secondary check after symbol check\n\tif (CURRENCY_CODE_PATTERNS[0].test(html)) {\n\t\treturn \"uk\";\n\t}\n\n\t// Check for EUR/\u20AC near amounts (EU countries)\n\tif (CURRENCY_CODE_PATTERNS[1].test(html)) {\n\t\t// Try to determine which EU country by checking for country-specific text\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.IRELAND)) return \"ie\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.NETHERLANDS)) return \"nl\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.GERMANY)) return \"de\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.FRANCE)) return \"fr\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.SPAIN)) return \"es\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.ITALY)) return \"it\";\n\t\t// Default to first EU country if we can't determine\n\t\treturn \"ie\";\n\t}\n\n\t// Check for USD near amounts (US)\n\tif (CURRENCY_CODE_PATTERNS[2].test(html)) {\n\t\treturn \"us\";\n\t}\n\n\t// Check for AUD near amounts (Australia) - check before generic $\n\tif (CURRENCY_CODE_PATTERNS[3].test(html)) {\n\t\treturn \"au\";\n\t}\n\n\t// Check for CAD near amounts (Canada)\n\tif (CURRENCY_CODE_PATTERNS[4].test(html)) {\n\t\treturn \"ca\";\n\t}\n\n\t// Check for NZD near amounts (New Zealand)\n\tif (CURRENCY_CODE_PATTERNS[5].test(html)) {\n\t\treturn \"nz\";\n\t}\n\n\t// Check for ZAR near amounts (South Africa)\n\tif (CURRENCY_CODE_PATTERNS[6].test(html)) {\n\t\treturn \"za\";\n\t}\n\n\t// Check for CZK/K\u010D near amounts (Czech Republic)\n\tif (CURRENCY_CODE_PATTERNS[7].test(html)) {\n\t\treturn \"cz\";\n\t}\n\n\t// Check for SEK near amounts (Sweden)\n\tif (CURRENCY_CODE_PATTERNS[8].test(html)) {\n\t\treturn \"se\";\n\t}\n\n\t// Check for DKK near amounts (Denmark)\n\tif (CURRENCY_CODE_PATTERNS[9].test(html)) {\n\t\treturn \"dk\";\n\t}\n\n\t// Fallback: Check for $ near amounts (but this is ambiguous)\n\t// Only use if we see $ followed by digits, and prefer AUD as default\n\tif (DOLLAR_AMOUNT_PATTERN.test(html)) {\n\t\t// Try to find country indicators\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.UNITED_STATES)) return \"us\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.CANADA)) return \"ca\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.NEW_ZEALAND)) return \"nz\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.AUSTRALIA)) return \"au\";\n\t\t// Default to AUD if we can't determine (since au is default subdomain)\n\t\treturn \"au\";\n\t}\n\n\treturn null;\n}\n\n/**\n * Detect subdomain by following redirects and checking HTML content\n * @param {string} memberId - The member ID\n * @param {boolean} forceRefresh - Whether to force refresh (skip cache)\n * @returns {Promise<string>} The detected subdomain\n */\nexport async function detectSubdomainForMember(memberId, forceRefresh = false) {\n\t// Check cache first (unless forcing refresh)\n\tif (!forceRefresh) {\n\t\tconst cached = getCachedSubdomain(memberId);\n\t\tif (cached) {\n\t\t\tlogger.info(\n\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t`Found cached subdomain for memberId ${memberId}: ${cached}`,\n\t\t\t);\n\t\t\treturn cached;\n\t\t}\n\t} else {\n\t\tlogger.info(\n\t\t\t\"[SUBDOMAIN]\",\n\t\t\t`Force refresh requested, skipping cache for memberId ${memberId}`,\n\t\t);\n\t}\n\n\t// Check manual override\n\tif (MEMBER_SUBDOMAIN_MAP[memberId]) {\n\t\tconst subdomain = MEMBER_SUBDOMAIN_MAP[memberId];\n\t\tlogger.info(\n\t\t\t\"[SUBDOMAIN]\",\n\t\t\t`Using manual override for memberId ${memberId}: ${subdomain}`,\n\t\t);\n\t\t// Cache the manual override\n\t\tsetCachedSubdomain(memberId, subdomain, SUBDOMAIN_CACHE_TTL);\n\t\treturn subdomain;\n\t}\n\n\t// Try to detect by checking common subdomains and their HTML content\n\tlogger.info(\"[SUBDOMAIN]\", `Detecting subdomain for memberId ${memberId}...`);\n\t// Reorder to try 'au' first since it's the default, then other common ones\n\tconst commonSubdomains = [\n\t\t\"au\",\n\t\t\"uk\",\n\t\t\"us\",\n\t\t\"ca\",\n\t\t\"nz\",\n\t\t\"ie\",\n\t\t\"za\",\n\t\t\"nl\",\n\t\t\"de\",\n\t\t\"fr\",\n\t\t\"es\",\n\t\t\"it\",\n\t\t\"ex\",\n\t\t\"cz\",\n\t\t\"dk\",\n\t\t\"se\",\n\t];\n\n\ttry {\n\t\t// Try common subdomains and check for currency indicators\n\t\t// Primary method: Verify with HTML currency check (most reliable)\n\t\t// Secondary method: Use URL subdomain as fallback if currency check is inconclusive\n\t\tlet fallbackSubdomain = null;\n\n\t\tfor (const subdomain of commonSubdomains) {\n\t\t\tconst testSubdomainUrl = buildMovemberUrl(memberId, subdomain);\n\t\t\ttry {\n\t\t\t\tconst { html: testHtml, finalUrl } =\n\t\t\t\t\tawait fetchViaProxy(testSubdomainUrl);\n\n\t\t\t\t// Extract actual subdomain from final URL (after redirects)\n\t\t\t\tconst actualSubdomain = extractSubdomainFromUrl(finalUrl);\n\n\t\t\t\tif (testHtml && testHtml.length > 1000) {\n\t\t\t\t\t// Check HTML for currency indicators\n\t\t\t\t\tconst detectedSubdomain = detectSubdomainFromHtml(testHtml);\n\n\t\t\t\t\t// Priority 1: Use actual subdomain from final URL (after redirects) - most reliable\n\t\t\t\t\tif (actualSubdomain && actualSubdomain !== subdomain) {\n\t\t\t\t\t\t// URL redirected to a different subdomain - use the actual one\n\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t\t\t\t`URL redirected from ${subdomain} to ${actualSubdomain} for memberId ${memberId}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tsetCachedSubdomain(memberId, actualSubdomain, SUBDOMAIN_CACHE_TTL);\n\t\t\t\t\t\treturn actualSubdomain;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Priority 2: If HTML currency check confirms the subdomain, use it\n\t\t\t\t\tif (\n\t\t\t\t\t\tdetectedSubdomain === subdomain ||\n\t\t\t\t\t\tdetectedSubdomain === actualSubdomain\n\t\t\t\t\t) {\n\t\t\t\t\t\t// HTML matches this subdomain's currency - this is correct\n\t\t\t\t\t\tconst confirmedSubdomain = actualSubdomain || subdomain;\n\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t\t\t\t`Found matching subdomain for memberId ${memberId}: ${confirmedSubdomain} (verified by currency)`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tsetCachedSubdomain(\n\t\t\t\t\t\t\tmemberId,\n\t\t\t\t\t\t\tconfirmedSubdomain,\n\t\t\t\t\t\t\tSUBDOMAIN_CACHE_TTL,\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn confirmedSubdomain;\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tdetectedSubdomain &&\n\t\t\t\t\t\tdetectedSubdomain !== subdomain &&\n\t\t\t\t\t\tdetectedSubdomain !== actualSubdomain\n\t\t\t\t\t) {\n\t\t\t\t\t\t// HTML indicates a different subdomain - use the detected one (currency is reliable)\n\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t\t\t\t`HTML currency indicates ${detectedSubdomain} (tested ${subdomain}, final URL: ${actualSubdomain || subdomain}), using detected subdomain`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tsetCachedSubdomain(\n\t\t\t\t\t\t\tmemberId,\n\t\t\t\t\t\t\tdetectedSubdomain,\n\t\t\t\t\t\t\tSUBDOMAIN_CACHE_TTL,\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn detectedSubdomain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Can't determine from currency, but HTML is valid\n\t\t\t\t\t\t// Use actual subdomain from final URL, or tested subdomain as fallback\n\t\t\t\t\t\tconst fallbackSubdomainToUse = actualSubdomain || subdomain;\n\t\t\t\t\t\tif (!fallbackSubdomain) {\n\t\t\t\t\t\t\tfallbackSubdomain = fallbackSubdomainToUse;\n\t\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t\t\t\t\t`Found valid HTML for subdomain ${fallbackSubdomainToUse} (currency check inconclusive, storing as fallback)`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Continue to next subdomain\n\t\t\t\tlogger.warn(\"[SUBDOMAIN]\", \"Error trying subdomain:\", e);\n\t\t\t}\n\t\t}\n\n\t\t// If we found a fallback subdomain (valid HTML but inconclusive currency), use it\n\t\tif (fallbackSubdomain) {\n\t\t\tlogger.info(\n\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t`Using fallback subdomain for memberId ${memberId}: ${fallbackSubdomain} (no currency match found)`,\n\t\t\t);\n\t\t\tsetCachedSubdomain(memberId, fallbackSubdomain, SUBDOMAIN_CACHE_TTL);\n\t\t\treturn fallbackSubdomain;\n\t\t}\n\n\t\t// If we couldn't determine by currency, try default subdomain\n\t\tconst testUrl = buildMovemberUrl(memberId, DEFAULT_SUBDOMAIN);\n\t\ttry {\n\t\t\tconst { html, finalUrl } = await fetchViaProxy(testUrl);\n\t\t\tif (html && html.length > 1000) {\n\t\t\t\t// Extract actual subdomain from final URL (after redirects)\n\t\t\t\tconst actualSubdomain =\n\t\t\t\t\textractSubdomainFromUrl(finalUrl) || DEFAULT_SUBDOMAIN;\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t\t`Using default subdomain for memberId ${memberId}: ${actualSubdomain}`,\n\t\t\t\t);\n\t\t\t\tsetCachedSubdomain(memberId, actualSubdomain, SUBDOMAIN_CACHE_TTL);\n\t\t\t\treturn actualSubdomain;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// Continue to fallback\n\t\t\tlogger.warn(\"[SUBDOMAIN]\", \"Error trying default subdomain:\", e);\n\t\t}\n\n\t\t// Fallback to default\n\t\tlogger.warn(\n\t\t\t\"[SUBDOMAIN]\",\n\t\t\t`Could not find working subdomain for memberId ${memberId}, using default: ${DEFAULT_SUBDOMAIN}`,\n\t\t);\n\t\tsetCachedSubdomain(memberId, DEFAULT_SUBDOMAIN, SUBDOMAIN_CACHE_TTL);\n\t\treturn DEFAULT_SUBDOMAIN;\n\t} catch (error) {\n\t\tlogger.warn(\n\t\t\t\"[SUBDOMAIN]\",\n\t\t\t`Failed to detect subdomain for memberId ${memberId}, using default:`,\n\t\t\terror,\n\t\t);\n\t\tsetCachedSubdomain(memberId, DEFAULT_SUBDOMAIN, SUBDOMAIN_CACHE_TTL);\n\t\treturn DEFAULT_SUBDOMAIN;\n\t}\n}\n\n/**\n * Get subdomain for a member ID (with auto-detection)\n * @param {string} memberId - The member ID\n * @returns {Promise<string>} The subdomain for the member\n */\nexport async function getSubdomainForMember(memberId) {\n\t// Check manual override first\n\tif (MEMBER_SUBDOMAIN_MAP[memberId]) {\n\t\treturn MEMBER_SUBDOMAIN_MAP[memberId];\n\t}\n\n\t// Auto-detect (will check cache internally)\n\treturn await detectSubdomainForMember(memberId);\n}\n", "/**\n * Main orchestration logic for scraping Movember pages\n * @module scraper/orchestrator\n */\n\nimport {\n\tclearSubdomainCache,\n\tgetCachedData,\n\tsetCachedData,\n\tsetCachedSubdomain,\n} from \"../cache.js\";\nimport {\n\tCACHE_TTL,\n\tgetCurrencySymbol,\n\tMAX_RETRIES,\n\tRETRY_DELAYS,\n\tSUBDOMAIN_CACHE_TTL,\n} from \"../constants.js\";\nimport { formatDuration, sleep } from \"../formatting.js\";\nimport logger from \"../logger.js\";\nimport { calculatePercentage, isValidNumber, parseAmount } from \"../parsing.js\";\nimport { extractAmounts } from \"./html-parsing.js\";\nimport {\n\tbuildMovemberUrl,\n\textractSubdomainFromUrl,\n\tfetchViaProxy,\n} from \"./network.js\";\nimport {\n\tdetectSubdomainForMember,\n\tdetectSubdomainFromHtml,\n\tgetSubdomainForMember,\n} from \"./subdomain.js\";\n\n/**\n * Scrape the Movember page using Worker's CORS proxy and HTML parsing\n * @param {string} memberId - The member ID to scrape\n * @param {boolean} clearSubdomainOn404 - Whether to clear subdomain cache on 404 errors\n * @returns {Promise<{amount: string, currency: string, subdomain: string, timestamp: number, target?: string, percentage?: number}>} The scraped data\n * @throws {Error} If scraping fails\n */\nexport async function scrapeMovemberPage(\n\tmemberId,\n\tclearSubdomainOn404 = false,\n) {\n\tlet subdomain = await getSubdomainForMember(memberId);\n\tconst movemberUrl = buildMovemberUrl(memberId, subdomain);\n\tconst startTime = Date.now();\n\tlogger.info(\n\t\t\"[SCRAPE]\",\n\t\t`Starting scrape of Movember page: ${movemberUrl} (subdomain: ${subdomain})`,\n\t);\n\n\ttry {\n\t\t// Fetch the HTML via Worker's CORS proxy\n\t\tlogger.info(\"[SCRAPE]\", `Fetching HTML from ${movemberUrl} via proxy...`);\n\t\tconst fetchStart = Date.now();\n\t\tlet html;\n\t\tlet finalUrl;\n\n\t\ttry {\n\t\t\tconst result = await fetchViaProxy(movemberUrl);\n\t\t\thtml = result.html;\n\t\t\tfinalUrl = result.finalUrl;\n\t\t} catch (error) {\n\t\t\t// If we get an error, try clearing subdomain cache and re-detecting\n\t\t\tif (clearSubdomainOn404 && error.message.includes(\"404\")) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t`Got 404 for ${movemberUrl}, clearing cached subdomain and re-detecting...`,\n\t\t\t\t);\n\t\t\t\tclearSubdomainCache(memberId);\n\t\t\t\t// Re-detect subdomain with force refresh\n\t\t\t\tconst newSubdomain = await detectSubdomainForMember(memberId, true);\n\t\t\t\tif (newSubdomain !== subdomain) {\n\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t\t`Re-detected subdomain: ${newSubdomain} (was ${subdomain}), retrying with new subdomain...`,\n\t\t\t\t\t);\n\t\t\t\t\t// Retry with new subdomain\n\t\t\t\t\tconst newUrl = buildMovemberUrl(memberId, newSubdomain);\n\t\t\t\t\tconst retryResult = await fetchViaProxy(newUrl);\n\t\t\t\t\thtml = retryResult.html;\n\t\t\t\t\tfinalUrl = retryResult.finalUrl;\n\t\t\t\t\tsubdomain = newSubdomain;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`HTTP error! status: 404 (page not found - member may not exist)`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\tconst fetchDuration = Date.now() - fetchStart;\n\t\tlogger.info(\n\t\t\t\"[SCRAPE]\",\n\t\t\t`HTML fetched successfully in ${formatDuration(fetchDuration)} (${html.length} characters)`,\n\t\t);\n\n\t\t// Check if URL redirected to a different subdomain\n\t\tconst actualSubdomain = extractSubdomainFromUrl(finalUrl);\n\t\tif (actualSubdomain && actualSubdomain !== subdomain) {\n\t\t\tlogger.info(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`URL redirected from ${subdomain} to ${actualSubdomain}, updating subdomain...`,\n\t\t\t);\n\t\t\tsubdomain = actualSubdomain;\n\t\t\t// Update cache with correct subdomain\n\t\t\tsetCachedSubdomain(memberId, subdomain, SUBDOMAIN_CACHE_TTL);\n\t\t}\n\n\t\t// Verify subdomain by checking HTML content for currency indicators (optional verification only)\n\t\tconst htmlDetectedSubdomain = detectSubdomainFromHtml(html);\n\t\tif (htmlDetectedSubdomain && htmlDetectedSubdomain !== subdomain) {\n\t\t\tlogger.warn(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`HTML currency indicates subdomain ${htmlDetectedSubdomain} but URL subdomain is ${subdomain}. Trusting URL subdomain (primary source).`,\n\t\t\t);\n\t\t\t// Don't override - trust the URL subdomain we're using\n\t\t} else if (htmlDetectedSubdomain === subdomain) {\n\t\t\tlogger.info(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`HTML currency verification confirms subdomain ${subdomain}`,\n\t\t\t);\n\t\t}\n\n\t\t// Extract data from HTML\n\t\tconst { raised, target } = extractAmounts(html, memberId, subdomain);\n\n\t\t// Final validation check - ensure raised is actually valid before using\n\t\tif (!raised || !isValidNumber(raised)) {\n\t\t\t// Debug: Try to find any dollar amounts in the HTML to help diagnose\n\t\t\tconst allDollarAmounts = html.match(/\\$[\\d,]+(?:\\.\\d+)?/g);\n\t\t\tlogger.warn(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`Found ${allDollarAmounts ? allDollarAmounts.length : 0} dollar amounts in HTML:`,\n\t\t\t\tallDollarAmounts ? allDollarAmounts.slice(0, 10) : [],\n\t\t\t); // Show first 10\n\n\t\t\t// Try to find any numbers that might be amounts\n\t\t\tconst potentialAmounts = html.match(/[\\d,]{3,}(?:\\.\\d+)?/g);\n\t\t\tlogger.warn(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`Found ${potentialAmounts ? potentialAmounts.length : 0} potential amount numbers in HTML (showing first 20):`,\n\t\t\t\tpotentialAmounts ? potentialAmounts.slice(0, 20) : [],\n\t\t\t);\n\n\t\t\tconst errorDetails = {\n\t\t\t\tmemberId,\n\t\t\t\tsubdomain,\n\t\t\t\turl: movemberUrl,\n\t\t\t\tmessage:\n\t\t\t\t\t\"Could not find raised amount in HTML. The page may require JavaScript execution or the HTML structure may have changed.\",\n\t\t\t\thtmlLength: html.length,\n\t\t\t\tdollarAmountsFound: allDollarAmounts ? allDollarAmounts.length : 0,\n\t\t\t\traisedValue: raised || \"empty\",\n\t\t\t};\n\t\t\tlogger.error(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\"Failed to extract raised amount:\",\n\t\t\t\terrorDetails,\n\t\t\t);\n\t\t\tthrow new Error(\n\t\t\t\t`Could not find raised amount in HTML for memberId ${memberId} (subdomain: ${subdomain}). The page may require JavaScript execution or the HTML structure may have changed. Found ${allDollarAmounts ? allDollarAmounts.length : 0} dollar amounts in HTML.`,\n\t\t\t);\n\t\t}\n\n\t\t// Double-check that raised is valid before parsing\n\t\tif (!isValidNumber(raised)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Invalid raised value captured: \"${raised}\" for memberId ${memberId}`,\n\t\t\t);\n\t\t}\n\n\t\t// Parse amount with subdomain to determine correct currency\n\t\tconst { value: raisedValue, currency } = parseAmount(\n\t\t\t`$${raised}`,\n\t\t\tsubdomain,\n\t\t);\n\n\t\t// Validate the parsed value is not empty or zero (unless it's actually zero)\n\t\tif (!raisedValue || raisedValue === \"0\" || raisedValue === \"\") {\n\t\t\tlogger.warn(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`Parsed raised value is invalid: \"${raisedValue}\" from input: \"${raised}\"`,\n\t\t\t);\n\t\t}\n\n\t\t// Format amount with appropriate currency symbol\n\t\tconst currencySymbol = getCurrencySymbol(currency);\n\t\tconst raisedFormatted = `${currencySymbol}${raisedValue}`;\n\n\t\tconst result = {\n\t\t\tamount: raisedFormatted,\n\t\t\tcurrency,\n\t\t\tsubdomain, // Include subdomain in result for consolidated cache\n\t\t\ttimestamp: Date.now(),\n\t\t};\n\n\t\tif (target && isValidNumber(target)) {\n\t\t\tconst { value: targetValue } = parseAmount(`$${target}`, subdomain);\n\t\t\t// Use the same currency symbol for consistency\n\t\t\tconst targetFormatted = `${currencySymbol}${targetValue}`;\n\t\t\tresult.target = targetFormatted;\n\t\t\tresult.percentage = calculatePercentage(raisedValue, targetValue);\n\t\t} else if (target) {\n\t\t\tlogger.warn(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`Target value \"${target}\" failed validation, skipping target`,\n\t\t\t);\n\t\t}\n\n\t\tconst totalDuration = Date.now() - startTime;\n\t\tlogger.info(\n\t\t\t\"[SCRAPE]\",\n\t\t\t`Scraping completed successfully in ${formatDuration(totalDuration)}:`,\n\t\t\t{\n\t\t\t\tamount: result.amount,\n\t\t\t\ttarget: result.target,\n\t\t\t\tpercentage: result.percentage,\n\t\t\t\tcurrency: result.currency,\n\t\t\t\tsubdomain: result.subdomain,\n\t\t\t},\n\t\t);\n\n\t\treturn result;\n\t} catch (error) {\n\t\tconst totalDuration = Date.now() - startTime;\n\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\tlogger.error(\n\t\t\t\"[SCRAPE]\",\n\t\t\t`Scraping failed after ${formatDuration(totalDuration)}:`,\n\t\t\terrorMessage,\n\t\t\terror,\n\t\t);\n\t\tthrow error;\n\t}\n}\n\n/**\n * Retry wrapper with exponential backoff\n * @param {string} memberId - The member ID to scrape\n * @returns {Promise<{amount: string, currency: string, subdomain: string, timestamp: number, target?: string, percentage?: number}>} The scraped data\n * @throws {Error} If all retries fail\n */\nexport async function scrapeWithRetry(memberId) {\n\tlet lastError = null;\n\tconst retryStartTime = Date.now();\n\n\tlogger.info(\n\t\t\"[RETRY]\",\n\t\t`Starting retry logic (max ${MAX_RETRIES} attempts) for memberId: ${memberId}`,\n\t);\n\n\tfor (let attempt = 0; attempt < MAX_RETRIES; attempt++) {\n\t\ttry {\n\t\t\tlogger.info(\"[RETRY]\", `Attempt ${attempt + 1}/${MAX_RETRIES}`);\n\t\t\t// Enable subdomain clearing on 404 for retries (especially on first attempt)\n\t\t\tconst clearSubdomainOn404 =\n\t\t\t\tattempt === 0 || lastError?.message.includes(\"404\");\n\t\t\tconst result = await scrapeMovemberPage(memberId, clearSubdomainOn404);\n\t\t\tconst totalDuration = Date.now() - retryStartTime;\n\t\t\tlogger.info(\n\t\t\t\t\"[RETRY]\",\n\t\t\t\t`Success on attempt ${attempt + 1} after ${totalDuration}ms`,\n\t\t\t);\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tlastError = error instanceof Error ? error : new Error(String(error));\n\t\t\tconst errorMessage = lastError.message;\n\t\t\tlogger.error(\"[RETRY]\", `Attempt ${attempt + 1} failed:`, errorMessage);\n\n\t\t\t// If we got a 404, clear the subdomain cache before retrying\n\t\t\tif (errorMessage.includes(\"404\")) {\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"[RETRY]\",\n\t\t\t\t\t`404 detected, clearing subdomain cache for memberId: ${memberId}`,\n\t\t\t\t);\n\t\t\t\tclearSubdomainCache(memberId);\n\t\t\t}\n\n\t\t\tif (attempt < MAX_RETRIES - 1) {\n\t\t\t\tconst delay =\n\t\t\t\t\tRETRY_DELAYS[attempt] || RETRY_DELAYS[RETRY_DELAYS.length - 1];\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"[RETRY]\",\n\t\t\t\t\t`Waiting ${delay}ms before retry ${attempt + 2}...`,\n\t\t\t\t);\n\t\t\t\tawait sleep(delay);\n\t\t\t} else {\n\t\t\t\tconst totalDuration = Date.now() - retryStartTime;\n\t\t\t\tlogger.error(\n\t\t\t\t\t\"[RETRY]\",\n\t\t\t\t\t`All ${MAX_RETRIES} attempts failed after ${totalDuration}ms`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow lastError || new Error(\"Failed to scrape after all retries\");\n}\n\n/**\n * Main function to get data (with caching)\n * @param {string} memberId - The member ID to get data for\n * @param {boolean} grabLive - Whether to force a fresh scrape (bypass cache)\n * @returns {Promise<{data: {amount: string, currency: string, subdomain: string, timestamp: number, target?: string, percentage?: number}, cacheStatus: string}>} The data and cache status\n */\nexport async function getData(memberId, grabLive = false) {\n\tlet data = null;\n\tlet cacheStatus = \"HIT\";\n\n\tif (grabLive) {\n\t\t// Force fresh scrape, bypass cache\n\t\tlogger.info(\n\t\t\t\"[LIVE]\",\n\t\t\t`grab-live parameter detected - forcing fresh scrape for memberId: ${memberId}`,\n\t\t);\n\t\tdata = await scrapeWithRetry(memberId);\n\t\tcacheStatus = \"LIVE\";\n\n\t\t// Store in cache with 5-minute TTL\n\t\tlogger.info(\n\t\t\t\"[CACHE]\",\n\t\t\t`Storing live data in cache with TTL: ${CACHE_TTL}ms for memberId: ${memberId}`,\n\t\t);\n\t\tsetCachedData(memberId, data, CACHE_TTL);\n\t\tlogger.info(\"[CACHE]\", \"Live data stored successfully\");\n\t} else {\n\t\t// Check cache first\n\t\tlogger.info(\"[CACHE]\", `Checking cache for memberId: ${memberId}`);\n\t\tdata = getCachedData(memberId);\n\n\t\tif (data) {\n\t\t\tconst cacheAge = Date.now() - data.timestamp;\n\t\t\tlogger.info(\n\t\t\t\t\"[CACHE]\",\n\t\t\t\t`Cache HIT - data age: ${Math.round(cacheAge / 1000)}s for memberId: ${memberId}`,\n\t\t\t\t{\n\t\t\t\t\tamount: data.amount,\n\t\t\t\t\ttarget: data.target,\n\t\t\t\t\ttimestamp: new Date(data.timestamp).toISOString(),\n\t\t\t\t},\n\t\t\t);\n\t\t} else {\n\t\t\tlogger.info(\n\t\t\t\t\"[CACHE]\",\n\t\t\t\t`Cache MISS - need to scrape for memberId: ${memberId}`,\n\t\t\t);\n\t\t}\n\n\t\t// If cache miss, scrape the page\n\t\tif (!data) {\n\t\t\tdata = await scrapeWithRetry(memberId);\n\t\t\tcacheStatus = \"MISS\";\n\n\t\t\t// Store in cache with 5-minute TTL\n\t\t\tlogger.info(\n\t\t\t\t\"[CACHE]\",\n\t\t\t\t`Storing data in cache with TTL: ${CACHE_TTL}ms for memberId: ${memberId}`,\n\t\t\t);\n\t\t\tsetCachedData(memberId, data, CACHE_TTL);\n\t\t\tlogger.info(\"[CACHE]\", \"Data stored successfully\");\n\t\t}\n\t}\n\n\treturn { data, cacheStatus };\n}\n"],
  "mappings": "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",
  "names": ["MEMBER_SUBDOMAIN_MAP", "MOVEMBER_BASE_URL_TEMPLATE", "DEFAULT_MEMBER_ID", "RETRY_DELAYS", "SUBDOMAIN_CURRENCY_MAP", "getCurrencyFromSubdomain", "subdomain", "CURRENCY_SYMBOL_MAP", "getCurrencySymbol", "currencyCode", "getProxyUrl", "formatDuration", "ms", "seconds", "minutes", "remainingSeconds", "sleep", "resolve", "LOG_LEVELS", "currentLogLevel", "initializeLogLevel", "stored", "level", "error", "formatMessage", "prefix", "args", "shouldLog", "logger", "upperLevel", "name", "value", "logger_default", "parseAmount", "text", "subdomain", "cleaned", "currency", "getCurrencyFromSubdomain", "amountMatch", "isValidNumber", "value", "calculatePercentage", "raised", "target", "raisedNum", "targetNum", "URL_PATTERNS", "CURRENCY_CODE_PATTERNS", "COUNTRY_DETECTION_PATTERNS", "DOLLAR_AMOUNT_PATTERN", "RAISED_PATTERNS", "TARGET_PATTERNS", "RAISED_JSON_PATTERNS", "TARGET_JSON_PATTERNS", "GENERIC_RAISED_PATTERNS", "GENERIC_TARGET_PATTERNS", "extractRaisedAmount", "html", "raised", "i", "RAISED_PATTERNS", "pattern", "match", "captured", "isValidNumber", "logger_default", "scriptTagMatches", "scriptTag", "RAISED_JSON_PATTERNS", "GENERIC_RAISED_PATTERNS", "allDollarMatches", "scoredAmounts", "amount", "matchIndex", "contextStart", "contextEnd", "context", "raisedScore", "a", "b", "raisedCandidates", "extractTargetAmount", "target", "TARGET_PATTERNS", "TARGET_JSON_PATTERNS", "GENERIC_TARGET_PATTERNS", "targetScore", "targetCandidates", "extractAmounts", "memberId", "subdomain", "extractStart", "extractDuration", "formatDuration", "extractSubdomainFromUrl", "url", "match", "URL_PATTERNS", "fetchViaProxy", "proxyUrl", "getProxyUrl", "response", "errorMessage", "errorData", "errorText", "e", "logger_default", "html", "finalUrl", "buildMovemberUrl", "memberId", "subdomain", "MOVEMBER_BASE_URL_TEMPLATE", "getCachedData", "memberId", "cacheKey", "cached", "data", "cachedAt", "ttl", "error", "logger_default", "setCachedData", "cacheValue", "getCachedSubdomain", "now", "setCachedSubdomain", "subdomain", "clearSubdomainCache", "oldSubdomainKey", "oldAmountKey", "detectSubdomainFromHtml", "html", "COUNTRY_DETECTION_PATTERNS", "CURRENCY_CODE_PATTERNS", "DOLLAR_AMOUNT_PATTERN", "detectSubdomainForMember", "memberId", "forceRefresh", "logger_default", "cached", "getCachedSubdomain", "MEMBER_SUBDOMAIN_MAP", "subdomain", "setCachedSubdomain", "commonSubdomains", "fallbackSubdomain", "testSubdomainUrl", "buildMovemberUrl", "testHtml", "finalUrl", "fetchViaProxy", "actualSubdomain", "extractSubdomainFromUrl", "detectedSubdomain", "confirmedSubdomain", "fallbackSubdomainToUse", "e", "testUrl", "error", "getSubdomainForMember", "scrapeMovemberPage", "memberId", "clearSubdomainOn404", "subdomain", "getSubdomainForMember", "movemberUrl", "buildMovemberUrl", "startTime", "logger_default", "fetchStart", "html", "finalUrl", "result", "fetchViaProxy", "error", "clearSubdomainCache", "newSubdomain", "detectSubdomainForMember", "newUrl", "retryResult", "fetchDuration", "formatDuration", "actualSubdomain", "extractSubdomainFromUrl", "setCachedSubdomain", "htmlDetectedSubdomain", "detectSubdomainFromHtml", "raised", "target", "extractAmounts", "isValidNumber", "allDollarAmounts", "potentialAmounts", "errorDetails", "raisedValue", "currency", "parseAmount", "currencySymbol", "getCurrencySymbol", "targetValue", "targetFormatted", "calculatePercentage", "totalDuration", "errorMessage", "scrapeWithRetry", "lastError", "retryStartTime", "attempt", "delay", "RETRY_DELAYS", "sleep", "getData", "grabLive", "data", "cacheStatus", "setCachedData", "getCachedData", "cacheAge"]
}
