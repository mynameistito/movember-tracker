{
  "version": 3,
  "sources": ["../../src/client/constants.ts", "../../src/client/formatting.ts", "../../src/client/logger.ts", "../../src/client/parsing.ts", "../../src/client/regex-patterns.ts", "../../src/client/scraper/html-parsing.ts", "../../src/client/error-tracking.ts", "../../src/client/scraper/network.ts", "../../src/client/cache.ts", "../../src/client/scraper/subdomain.ts", "../../src/client/scraper/orchestrator.ts"],
  "sourcesContent": ["// Mapping of member IDs to their subdomains (manual overrides)\r\n// Format: \"memberId\": \"subdomain\"\r\n// Example: \"15023456\": \"fr\" means member 15023456 uses fr.movember.com\r\n// Note: Subdomains are now auto-detected from redirects, but you can override here if needed\r\nexport const MEMBER_SUBDOMAIN_MAP: Record<string, string> = {\r\n\t// Add manual overrides here if needed\r\n\t// Example: \"15023456\": \"fr\",\r\n\t// Example: \"14810348\": \"au\",\r\n};\r\n\r\nexport const DEFAULT_SUBDOMAIN = \"au\"; // Default subdomain to try first\r\nexport const MOVEMBER_BASE_URL_TEMPLATE =\r\n\t\"https://{subdomain}.movember.com/donate/details\";\r\nexport const DEFAULT_MEMBER_ID = \"14810348\"; // Default member ID if none provided\r\nexport const CACHE_TTL = 300000; // 5 minutes in milliseconds\r\nexport const SUBDOMAIN_CACHE_TTL = 86400000; // 24 hours in milliseconds (subdomain mappings don't change often)\r\nexport const MAX_RETRIES = 3;\r\nexport const RETRY_DELAYS = [1000, 2000, 4000]; // Exponential backoff in milliseconds\r\n\r\n// Mapping of subdomain codes to currency codes\r\n// Format: \"subdomain\": \"CURRENCY_CODE\"\r\nexport const SUBDOMAIN_CURRENCY_MAP: Record<string, string> = {\r\n\tuk: \"GBP\", // United Kingdom - British Pound\r\n\tau: \"AUD\", // Australia - Australian Dollar\r\n\tus: \"USD\", // United States - US Dollar\r\n\tca: \"CAD\", // Canada - Canadian Dollar\r\n\tnz: \"NZD\", // New Zealand - New Zealand Dollar\r\n\tie: \"EUR\", // Ireland - Euro\r\n\tza: \"ZAR\", // South Africa - South African Rand\r\n\tnl: \"EUR\", // Netherlands - Euro\r\n\tde: \"EUR\", // Germany - Euro\r\n\tfr: \"EUR\", // France - Euro\r\n\tes: \"EUR\", // Spain - Euro\r\n\tit: \"EUR\", // Italy - Euro\r\n\tex: \"EUR\", // Unknown/Experimental - Euro (default)\r\n\tcz: \"CZK\", // Czech Republic - Czech Koruna\r\n\tdk: \"DKK\", // Denmark - Danish Krone\r\n\tse: \"SEK\", // Sweden - Swedish Krona\r\n};\r\n\r\n/**\r\n * Get currency code from subdomain\r\n * @param subdomain - The subdomain code (e.g., \"uk\", \"au\", \"us\")\r\n * @returns The currency code (e.g., \"GBP\", \"AUD\", \"USD\"), defaults to \"AUD\" if not found\r\n * @example\r\n * getCurrencyFromSubdomain(\"uk\") // \"GBP\"\r\n * getCurrencyFromSubdomain(\"au\") // \"AUD\"\r\n * getCurrencyFromSubdomain(\"us\") // \"USD\"\r\n */\r\nexport function getCurrencyFromSubdomain(subdomain: string | null | undefined): string {\r\n\tif (!subdomain) {\r\n\t\treturn \"AUD\"; // Default currency\r\n\t}\r\n\treturn SUBDOMAIN_CURRENCY_MAP[subdomain.toLowerCase()] || \"AUD\";\r\n}\r\n\r\n// Mapping of currency codes to currency symbols\r\nconst CURRENCY_SYMBOL_MAP: Record<string, string> = {\r\n\tUSD: \"$\", // US Dollar\r\n\tAUD: \"$\", // Australian Dollar\r\n\tCAD: \"$\", // Canadian Dollar\r\n\tNZD: \"$\", // New Zealand Dollar\r\n\tGBP: \"\u00A3\", // British Pound\r\n\tEUR: \"\u20AC\", // Euro\r\n\tJPY: \"\u00A5\", // Japanese Yen\r\n\tZAR: \"R\", // South African Rand\r\n\tCZK: \"K\u010D\", // Czech Koruna\r\n\tDKK: \"kr\", // Danish Krone\r\n\tSEK: \"kr\", // Swedish Krona\r\n};\r\n\r\n/**\r\n * Get currency symbol from currency code\r\n * @param currencyCode - The currency code (e.g., \"USD\", \"GBP\", \"EUR\")\r\n * @returns The currency symbol (e.g., \"$\", \"\u00A3\", \"\u20AC\"), defaults to \"$\" if not found\r\n * @example\r\n * getCurrencySymbol(\"USD\") // \"$\"\r\n * getCurrencySymbol(\"GBP\") // \"\u00A3\"\r\n * getCurrencySymbol(\"EUR\") // \"\u20AC\"\r\n */\r\nexport function getCurrencySymbol(currencyCode: string | null | undefined): string {\r\n\tif (!currencyCode) {\r\n\t\treturn \"$\"; // Default symbol\r\n\t}\r\n\treturn CURRENCY_SYMBOL_MAP[currencyCode.toUpperCase()] || \"$\";\r\n}\r\n\r\n/**\r\n * Get the Worker's proxy URL\r\n * Uses the current origin (the Worker's domain) for the proxy endpoint\r\n * @returns The proxy URL (e.g., \"https://example.com/proxy\")\r\n * @example\r\n * getProxyUrl() // \"https://movember-tracker.example.com/proxy\"\r\n */\r\nexport function getProxyUrl(): string {\r\n\t// Use the current origin (the Worker's domain) for the proxy\r\n\treturn `${window.location.origin}/proxy`;\r\n}\r\n\r\n", "/**\r\n * Format duration in human-readable format\r\n * @param ms - Duration in milliseconds\r\n * @returns Formatted duration string (e.g., \"2m 30s (150000ms)\" or \"45s (45000ms)\")\r\n * @example\r\n * formatDuration(150000) // \"2m 30s (150000ms)\"\r\n * formatDuration(45000) // \"45s (45000ms)\"\r\n */\r\nexport const formatDuration = (ms: number): string => {\r\n\tconst seconds = Math.round(ms / 1000);\r\n\tconst minutes = Math.floor(seconds / 60);\r\n\tconst remainingSeconds = seconds % 60;\r\n\r\n\tif (minutes > 0) {\r\n\t\treturn `${minutes}m ${remainingSeconds}s (${ms}ms)`;\r\n\t}\r\n\treturn `${seconds}s (${ms}ms)`;\r\n};\r\n\r\n/**\r\n * Sleep for a specified duration (useful for delays/retries)\r\n * @param ms - Duration to sleep in milliseconds\r\n * @returns Promise that resolves after the specified duration\r\n * @example\r\n * await sleep(1000); // Sleep for 1 second\r\n */\r\nexport const sleep = (ms: number): Promise<void> =>\r\n\tnew Promise((resolve) => setTimeout(resolve, ms));\r\n\r\n", "/**\r\n * Structured logger for client-side code\r\n * Supports log levels: DEBUG, INFO, WARN, ERROR\r\n * Can be disabled in production by setting LOG_LEVEL to 'NONE'\r\n */\r\n\r\n// Log levels (higher number = more important)\r\nconst LOG_LEVELS = {\r\n\tDEBUG: 0,\r\n\tINFO: 1,\r\n\tWARN: 2,\r\n\tERROR: 3,\r\n\tNONE: 4,\r\n} as const;\r\n\r\ntype LogLevel = keyof typeof LOG_LEVELS;\r\n\r\n// Default log level (can be overridden via localStorage or environment)\r\nlet currentLogLevel: number = LOG_LEVELS.INFO;\r\n\r\n// Initialize log level from localStorage or default\r\nfunction initializeLogLevel(): void {\r\n\ttry {\r\n\t\tconst stored = localStorage.getItem(\"LOG_LEVEL\");\r\n\t\tif (stored) {\r\n\t\t\tconst level = stored.toUpperCase() as LogLevel;\r\n\t\t\tif (level in LOG_LEVELS) {\r\n\t\t\t\tcurrentLogLevel = LOG_LEVELS[level];\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t} catch (error) {\r\n\t\t// localStorage unavailable (e.g., in private browsing mode)\r\n\t\t// Log to console as fallback since logger isn't initialized yet\r\n\t\tif (typeof console !== \"undefined\" && console.warn) {\r\n\t\t\tconsole.warn(\r\n\t\t\t\t\"[LOGGER] localStorage unavailable, using default log level:\",\r\n\t\t\t\terror instanceof Error ? error.message : String(error),\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t// Default to INFO in production, DEBUG in development\r\n\t// You can detect development mode via URL or other means\r\n\tconst isDevelopment =\r\n\t\twindow.location.hostname === \"localhost\" ||\r\n\t\twindow.location.hostname === \"127.0.0.1\" ||\r\n\t\twindow.location.search.includes(\"debug=true\");\r\n\r\n\tcurrentLogLevel = isDevelopment ? LOG_LEVELS.DEBUG : LOG_LEVELS.INFO;\r\n}\r\n\r\n// Initialize on load\r\ninitializeLogLevel();\r\n\r\n/**\r\n * Format log message with prefix\r\n */\r\nfunction formatMessage(level: string, prefix: string, ...args: unknown[]): unknown[] {\r\n\tconst timestamp = new Date().toISOString();\r\n\treturn [`[${timestamp}] [${level}] ${prefix}`, ...args];\r\n}\r\n\r\n/**\r\n * Check if log level should be output\r\n */\r\nfunction shouldLog(level: LogLevel): boolean {\r\n\treturn LOG_LEVELS[level] >= currentLogLevel;\r\n}\r\n\r\n/**\r\n * Logger object with methods for each log level\r\n */\r\nexport const logger = {\r\n\t/**\r\n\t * Set the log level\r\n\t * @param level - One of: 'DEBUG', 'INFO', 'WARN', 'ERROR', 'NONE'\r\n\t */\r\n\tsetLevel(level: string): void {\r\n\t\tconst upperLevel = level.toUpperCase() as LogLevel;\r\n\t\tif (upperLevel in LOG_LEVELS) {\r\n\t\t\tcurrentLogLevel = LOG_LEVELS[upperLevel];\r\n\t\t\ttry {\r\n\t\t\t\tlocalStorage.setItem(\"LOG_LEVEL\", upperLevel);\r\n\t\t\t} catch (error) {\r\n\t\t\t\t// localStorage unavailable - log using logger itself\r\n\t\t\t\t// Use console as fallback if logger fails\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\t\"[LOGGER]\",\r\n\t\t\t\t\t\t\"Failed to persist log level to localStorage:\",\r\n\t\t\t\t\t\terror instanceof Error ? error.message : String(error),\r\n\t\t\t\t\t);\r\n\t\t\t\t} catch {\r\n\t\t\t\t\t// If logger also fails, use console directly\r\n\t\t\t\t\tif (typeof console !== \"undefined\" && console.warn) {\r\n\t\t\t\t\t\tconsole.warn(\r\n\t\t\t\t\t\t\t\"[LOGGER] Failed to persist log level:\",\r\n\t\t\t\t\t\t\terror instanceof Error ? error.message : String(error),\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Get the current log level\r\n\t * @returns Current log level name\r\n\t */\r\n\tgetLevel(): string {\r\n\t\tfor (const [name, value] of Object.entries(LOG_LEVELS)) {\r\n\t\t\tif (value === currentLogLevel) {\r\n\t\t\t\treturn name;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn \"INFO\";\r\n\t},\r\n\r\n\t/**\r\n\t * Debug level logging (most verbose)\r\n\t */\r\n\tdebug(prefix: string, ...args: unknown[]): void {\r\n\t\tif (shouldLog(\"DEBUG\")) {\r\n\t\t\tconsole.debug(...formatMessage(\"DEBUG\", prefix, ...args));\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Info level logging (default)\r\n\t */\r\n\tinfo(prefix: string, ...args: unknown[]): void {\r\n\t\tif (shouldLog(\"INFO\")) {\r\n\t\t\tconsole.log(...formatMessage(\"INFO\", prefix, ...args));\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Warning level logging\r\n\t */\r\n\twarn(prefix: string, ...args: unknown[]): void {\r\n\t\tif (shouldLog(\"WARN\")) {\r\n\t\t\tconsole.warn(...formatMessage(\"WARN\", prefix, ...args));\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Error level logging\r\n\t */\r\n\terror(prefix: string, ...args: unknown[]): void {\r\n\t\tif (shouldLog(\"ERROR\")) {\r\n\t\t\tconsole.error(...formatMessage(\"ERROR\", prefix, ...args));\r\n\t\t}\r\n\t},\r\n};\r\n\r\n// Export default logger\r\nexport default logger;\r\n\r\n", "import { getCurrencyFromSubdomain } from \"./constants.js\";\r\n\r\nexport interface ParsedAmount {\r\n\tvalue: string;\r\n\tcurrency: string;\r\n}\r\n\r\n/**\r\n * Extract amount from text and determine currency from subdomain\r\n * Currency is ALWAYS determined from subdomain, never from HTML/text parsing\r\n * @param text - The text containing the amount (may include currency symbols)\r\n * @param subdomain - Required subdomain (e.g., \"uk\", \"au\", \"us\") to determine currency\r\n * @returns Object containing the extracted amount value and currency code\r\n * @example\r\n * parseAmount(\"$1,234.56\", \"us\") // { value: \"1,234.56\", currency: \"USD\" }\r\n * parseAmount(\"\u00A3500\", \"uk\") // { value: \"500\", currency: \"GBP\" }\r\n */\r\nexport const parseAmount = (text: string, subdomain: string | null | undefined): ParsedAmount => {\r\n\t// Remove whitespace and extract amount\r\n\tconst cleaned = text.trim();\r\n\r\n\t// Always use subdomain to determine currency - this is the source of truth\r\n\t// If subdomain is not provided, default to AUD\r\n\tconst currency = subdomain ? getCurrencyFromSubdomain(subdomain) : \"AUD\";\r\n\r\n\t// Extract amount (supports numbers with commas and optional decimals)\r\n\t// Remove currency symbols and codes before extracting number\r\n\tconst cleanedForAmount = cleaned\r\n\t\t.replace(/[$\u20AC\u00A3\u00A5]|\\b(USD|EUR|GBP|AUD|JPY|CAD|NZD|ZAR)\\b/gi, \"\")\r\n\t\t.trim();\r\n\tconst amountMatch = cleanedForAmount.match(/[\\d,]+\\.?\\d*/);\r\n\tconst amount = amountMatch ? amountMatch[0] : \"0\";\r\n\r\n\treturn { value: amount, currency };\r\n};\r\n\r\n/**\r\n * Validate that a captured value is a valid number\r\n * Checks for digits, removes currency symbols, and ensures the value is not just symbols\r\n * @param value - The value to validate\r\n * @returns True if the value is a valid number, false otherwise\r\n * @example\r\n * isValidNumber(\"1,234.56\") // true\r\n * isValidNumber(\"$500\") // true\r\n * isValidNumber(\"abc\") // false\r\n * isValidNumber(\"$\") // false\r\n */\r\nexport const isValidNumber = (value: string | null | undefined): boolean => {\r\n\tif (!value || typeof value !== \"string\") {\r\n\t\treturn false;\r\n\t}\r\n\t// Remove commas, spaces, and currency symbols, then check if we have at least one digit\r\n\tconst cleaned = value.replace(/[,.\\s$\u20AC\u00A3\u00A5]/g, \"\");\r\n\t// Must have at least one digit and be a valid number\r\n\tif (!cleaned || cleaned.length === 0 || !/^\\d+$/.test(cleaned)) {\r\n\t\treturn false;\r\n\t}\r\n\t// Additional check: the original value should contain at least one digit\r\n\tif (!/\\d/.test(value)) {\r\n\t\treturn false;\r\n\t}\r\n\t// Reject if value is just commas, spaces, or currency symbols\r\n\tif (/^[,.\\s$\u20AC\u00A3\u00A5]+$/.test(value)) {\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n};\r\n\r\n/**\r\n * Calculate percentage of raised amount relative to target\r\n * @param raised - The raised amount (may include commas)\r\n * @param target - The target amount (may include commas)\r\n * @returns The percentage (0-100), or 0 if target is 0\r\n * @example\r\n * calculatePercentage(\"2,500\", \"10,000\") // 25\r\n * calculatePercentage(\"500\", \"1,000\") // 50\r\n */\r\nexport const calculatePercentage = (raised: string, target: string): number => {\r\n\tconst raisedNum = parseFloat(raised.replace(/,/g, \"\"));\r\n\tconst targetNum = parseFloat(target.replace(/,/g, \"\"));\r\n\tif (targetNum === 0) return 0;\r\n\treturn Math.round((raisedNum / targetNum) * 100);\r\n};\r\n\r\n", "/**\r\n * Centralized regex patterns for Movember page scraping\r\n * All patterns are pre-compiled for better performance\r\n */\r\n\r\n// URL extraction patterns\r\nexport const URL_PATTERNS = {\r\n\t/**\r\n\t * Extract subdomain from Movember URL\r\n\t * Matches: https://uk.movember.com -> \"uk\"\r\n\t */\r\n\tSUBDOMAIN: /https?:\\/\\/([^.]+)\\.movember\\.com/,\r\n};\r\n\r\n// Currency code patterns for subdomain detection\r\nexport const CURRENCY_CODE_PATTERNS: RegExp[] = [\r\n\t/\\bGBP\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bGBP\\b|British\\s+Pound/i,\r\n\t/\\bEUR\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bEUR\\b|Euro[\\s:]*[\\d,]+/i,\r\n\t/\\bUSD\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bUSD\\b|US\\s+Dollar/i,\r\n\t/\\bAUD\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bAUD\\b|Australian\\s+Dollar/i,\r\n\t/\\bCAD\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bCAD\\b|Canadian\\s+Dollar/i,\r\n\t/\\bNZD\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bNZD\\b|New\\s+Zealand\\s+Dollar/i,\r\n\t/\\bZAR\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bZAR\\b|South\\s+African\\s+Rand/i,\r\n\t/\\bCZK\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bCZK\\b|Czech\\s+Koruna|K\u010D[\\d,]+/i,\r\n\t/\\bSEK\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bSEK\\b|Swedish\\s+Krona/i,\r\n\t/\\bDKK\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bDKK\\b|Danish\\s+Krone/i,\r\n];\r\n\r\n// Country detection patterns\r\nexport const COUNTRY_DETECTION_PATTERNS: Record<string, RegExp> = {\r\n\tIRELAND: /Ireland|Irish/i,\r\n\tNETHERLANDS: /Netherlands|Dutch/i,\r\n\tGERMANY: /Germany|German/i,\r\n\tFRANCE: /France|French/i,\r\n\tSPAIN: /Spain|Spanish/i,\r\n\tITALY: /Italy|Italian/i,\r\n\tUNITED_STATES: /United\\s+States|US\\s+Dollar/i,\r\n\tCANADA: /Canada|Canadian/i,\r\n\tNEW_ZEALAND: /New\\s+Zealand/i,\r\n\tAUSTRALIA: /Australia|Australian/i,\r\n};\r\n\r\n// Dollar amount pattern (ambiguous, used as fallback)\r\nexport const DOLLAR_AMOUNT_PATTERN = /\\$[\\d,]+/;\r\n\r\n// Raised amount extraction patterns (optimized with combined patterns)\r\n// Patterns are grouped by similarity and combined using alternation for better performance\r\nexport const RAISED_PATTERNS: RegExp[] = [\r\n\t// Group 1: AmountRaised object patterns (most reliable) - combined\r\n\t/\"AmountRaised\"[^}]*\"(?:convertedAmount|originalAmount)\"[\"\\s:]*[\"']([\\d,]+(?:\\.\\d+)?)/i,\r\n\t// Group 2: CSS class patterns with dollar sign - combined\r\n\t/donationProgress--amount__raised[^>]*>([^<]*\\$([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\r\n\t// Group 3: CSS class with class attribute - separate (different structure)\r\n\t/class=\"[^\"]*donationProgress--amount__raised[^\"]*\"[^>]*>[\\s\\S]*?\\$([\\d,]+(?:\\.\\d+)?)/i,\r\n\t// Group 4: JSON property patterns - combined\r\n\t/\"(?:raised|raisedAmount|currentAmount)\"[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\r\n\t// Group 5: Data attribute patterns - combined\r\n\t/data-(?:raised|amount)=[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\r\n\t// Group 6: CSS class with currency symbols - separate (different capture groups)\r\n\t/donationProgress--amount__raised[^>]*>([^<]*[\u20AC\u00A3$]([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\r\n\t// Group 7: CSS class with currency codes - separate (different capture groups)\r\n\t/donationProgress--amount__raised[^>]*>([^<]*(?:USD|EUR|GBP|AUD)\\s*([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\r\n];\r\n\r\n// Target amount extraction patterns (optimized with combined patterns)\r\n// Patterns are grouped by similarity and combined using alternation for better performance\r\nexport const TARGET_PATTERNS: RegExp[] = [\r\n\t// Group 1: target.fundraising.value (most reliable) - separate (most specific)\r\n\t/\"target\"[^}]*\"fundraising\"[^}]*\"value\"[\"\\s:]*[\"']([\\d,]+(?:\\.\\d+)?)/i,\r\n\t// Group 2: CSS class patterns with dollar sign - combined\r\n\t/donationProgress--amount__target[^>]*>([^<]*\\$([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\r\n\t// Group 3: CSS class with class attribute - separate (different structure)\r\n\t/class=\"[^\"]*donationProgress--amount__target[^\"]*\"[^>]*>[\\s\\S]*?\\$([\\d,]+(?:\\.\\d+)?)/i,\r\n\t// Group 4: JSON property patterns - combined\r\n\t/\"(?:target|targetAmount|goal)\"[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\r\n\t// Group 5: Data attribute patterns - combined\r\n\t/data-(?:target|goal)=[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\r\n\t// Group 6: CSS class with currency symbols - separate (different capture groups)\r\n\t/donationProgress--amount__target[^>]*>([^<]*[\u20AC\u00A3$]([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\r\n\t// Group 7: CSS class with currency codes - separate (different capture groups)\r\n\t/donationProgress--amount__target[^>]*>([^<]*(?:USD|EUR|GBP|AUD)\\s*([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\r\n];\r\n\r\n// JSON script tag patterns for raised amounts (optimized with combined patterns)\r\nexport const RAISED_JSON_PATTERNS: RegExp[] = [\r\n\t// Combined JSON property patterns\r\n\t/\"(?:raised|raisedAmount|currentAmount|donationAmount|amount)\"[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\r\n\t// Unquoted property pattern (separate due to different structure)\r\n\t/raised[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\r\n];\r\n\r\n// JSON script tag patterns for target amounts (optimized with combined patterns)\r\nexport const TARGET_JSON_PATTERNS: RegExp[] = [\r\n\t// Combined JSON property patterns\r\n\t/\"(?:target|targetAmount|goal)\"[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\r\n\t// Unquoted property patterns - combined\r\n\t/(?:target|goal)[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\r\n];\r\n\r\n// Generic fallback patterns for raised amounts\r\nexport const GENERIC_RAISED_PATTERNS: RegExp[] = [\r\n\t// Look for $X,XXX pattern in common HTML structures\r\n\t/\\$([\\d,]+(?:\\.\\d+)?)\\s*(?:raised|donated|collected)/i,\r\n\t/(?:raised|donated|collected)[:\\s]*\\$([\\d,]+(?:\\.\\d+)?)/i,\r\n\t// Look for amounts in div/span elements\r\n\t/<[^>]+class=\"[^\"]*(?:amount|raised|donation|progress)[^\"]*\"[^>]*>\\s*\\$?([\\d,]+(?:\\.\\d+)?)/i,\r\n\t// Look for amounts in data attributes\r\n\t/data-[^=]*amount[^=]*=[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\r\n\t// Look for amounts near \"of\" or \"out of\" (progress indicators)\r\n\t/\\$([\\d,]+(?:\\.\\d+)?)\\s*(?:of|out of)/i,\r\n\t// Look for amounts in JSON-like structures without quotes\r\n\t/raised[:\\s=]+[$]?([\\d,]+(?:\\.\\d+)?)/i,\r\n\t/amount[:\\s=]+[$]?([\\d,]+(?:\\.\\d+)?)/i,\r\n];\r\n\r\n// Generic fallback patterns for target amounts\r\nexport const GENERIC_TARGET_PATTERNS: RegExp[] = [\r\n\t// Look for $X,XXX pattern with target/goal keywords\r\n\t/\\$([\\d,]+(?:\\.\\d+)?)\\s*(?:target|goal)/i,\r\n\t/(?:target|goal)[:\\s]*\\$([\\d,]+(?:\\.\\d+)?)/i,\r\n\t// Look for amounts in div/span elements with target/goal classes\r\n\t/<[^>]+class=\"[^\"]*(?:target|goal)[^\"]*\"[^>]*>\\s*\\$?([\\d,]+(?:\\.\\d+)?)/i,\r\n\t// Look for amounts in data attributes\r\n\t/data-[^=]*(?:target|goal)[^=]*=[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\r\n\t// Look for amounts near \"of\" or \"out of\" with target/goal context\r\n\t/\\$([\\d,]+(?:\\.\\d+)?)\\s*(?:of|out of)\\s*\\$([\\d,]+(?:\\.\\d+)?)/i,\r\n\t// Look for amounts in JSON-like structures without quotes\r\n\t/target[:\\s=]+[$]?([\\d,]+(?:\\.\\d+)?)/i,\r\n\t/goal[:\\s=]+[$]?([\\d,]+(?:\\.\\d+)?)/i,\r\n];\r\n\r\n", "/**\r\n * HTML parsing logic for extracting donation amounts from Movember pages\r\n * @module scraper/html-parsing\r\n */\r\n\r\nimport { formatDuration } from \"../formatting.js\";\r\nimport logger from \"../logger.js\";\r\nimport { isValidNumber } from \"../parsing.js\";\r\nimport {\r\n\tGENERIC_RAISED_PATTERNS,\r\n\tGENERIC_TARGET_PATTERNS,\r\n\tRAISED_JSON_PATTERNS,\r\n\tRAISED_PATTERNS,\r\n\tTARGET_JSON_PATTERNS,\r\n\tTARGET_PATTERNS,\r\n} from \"../regex-patterns.js\";\r\n\r\nexport interface ExtractedAmounts {\r\n\traised: string;\r\n\ttarget: string;\r\n}\r\n\r\n/**\r\n * Extract raised amount from HTML using DOMParser (primary method)\r\n * Falls back to regex if DOMParser fails or doesn't find results\r\n * @param html - The HTML content to parse\r\n * @returns The extracted raised amount or empty string if not found\r\n */\r\nfunction extractRaisedAmountWithDOMParser(html: string): string {\r\n\ttry {\r\n\t\tconst parser = new DOMParser();\r\n\t\tconst doc = parser.parseFromString(html, \"text/html\");\r\n\r\n\t\t// Try to find elements with donation-related classes\r\n\t\tconst selectors = [\r\n\t\t\t\".donationProgress--amount__raised\",\r\n\t\t\t'[class*=\"donationProgress--amount__raised\"]',\r\n\t\t\t'[class*=\"raised\"]',\r\n\t\t\t\"[data-raised]\",\r\n\t\t\t\"[data-amount]\",\r\n\t\t\t\"[data-raised-amount]\",\r\n\t\t];\r\n\r\n\t\tfor (const selector of selectors) {\r\n\t\t\tconst elements = doc.querySelectorAll(selector);\r\n\t\t\tfor (const element of Array.from(elements)) {\r\n\t\t\t\tconst text = element.textContent || (element as HTMLElement).innerText || \"\";\r\n\t\t\t\t// Try to extract amount from text\r\n\t\t\t\tconst amountMatch = text.match(/[\\d,]+(?:\\.\\d+)?/);\r\n\t\t\t\tif (amountMatch && isValidNumber(amountMatch[0])) {\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Found raised amount using DOMParser with selector \"${selector}\": ${amountMatch[0]}`,\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn amountMatch[0];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Try data attributes\r\n\t\t\t\tconst dataRaised =\r\n\t\t\t\t\telement.getAttribute(\"data-raised\") ||\r\n\t\t\t\t\telement.getAttribute(\"data-amount\") ||\r\n\t\t\t\t\telement.getAttribute(\"data-raised-amount\");\r\n\t\t\t\tif (dataRaised && isValidNumber(dataRaised)) {\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Found raised amount using DOMParser data attribute: ${dataRaised}`,\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn dataRaised;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Try to find JSON data in script tags using DOMParser\r\n\t\tconst scriptTags = doc.querySelectorAll(\"script\");\r\n\t\tfor (const script of Array.from(scriptTags)) {\r\n\t\t\tconst scriptContent = script.textContent || script.innerHTML || \"\";\r\n\t\t\tfor (let i = 0; i < RAISED_JSON_PATTERNS.length; i++) {\r\n\t\t\t\tconst pattern = RAISED_JSON_PATTERNS[i];\r\n\t\t\t\tconst match = scriptContent.match(pattern);\r\n\t\t\t\tif (match) {\r\n\t\t\t\t\tconst captured = match[1];\r\n\t\t\t\t\tif (isValidNumber(captured)) {\r\n\t\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t\t`Found raised amount in JSON using DOMParser: ${captured}`,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\treturn captured;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} catch (error) {\r\n\t\tlogger.warn(\r\n\t\t\t\"[SCRAPE]\",\r\n\t\t\t\"DOMParser extraction failed, falling back to regex:\",\r\n\t\t\terror,\r\n\t\t);\r\n\t}\r\n\r\n\treturn \"\";\r\n}\r\n\r\n/**\r\n * Extract raised amount from HTML using multiple pattern strategies\r\n * Tries DOMParser first, then falls back to regex patterns\r\n * @param html - The HTML content to parse\r\n * @returns The extracted raised amount or empty string if not found\r\n */\r\nexport function extractRaisedAmount(html: string): string {\r\n\t// Try DOMParser first (more reliable for structured HTML)\r\n\tlet raised = extractRaisedAmountWithDOMParser(html);\r\n\tif (raised) {\r\n\t\treturn raised;\r\n\t}\r\n\r\n\tlogger.info(\r\n\t\t\"[SCRAPE]\",\r\n\t\t\"DOMParser didn't find raised amount, trying regex patterns...\",\r\n\t);\r\n\traised = \"\";\r\n\r\n\t// Look for the raised amount in the HTML\r\n\t// Try multiple patterns to find the data\r\n\tfor (let i = 0; i < RAISED_PATTERNS.length; i++) {\r\n\t\tconst pattern = RAISED_PATTERNS[i];\r\n\t\tconst match = html.match(pattern);\r\n\t\tif (match) {\r\n\t\t\t// Get the last capture group (the amount), but also check all groups\r\n\t\t\tlet captured = match[match.length - 1];\r\n\r\n\t\t\t// If the last group is empty or invalid, try the second-to-last\r\n\t\t\tif (!captured || !isValidNumber(captured)) {\r\n\t\t\t\tif (match.length > 2) {\r\n\t\t\t\t\tcaptured = match[match.length - 2];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlogger.debug(\r\n\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t`Pattern ${i + 1} matched, all groups:`,\r\n\t\t\t\tmatch.slice(1),\r\n\t\t\t\t`using: \"${captured}\"`,\r\n\t\t\t);\r\n\r\n\t\t\t// Validate that we captured a valid number\r\n\t\t\tif (isValidNumber(captured)) {\r\n\t\t\t\traised = captured;\r\n\t\t\t\tlogger.info(\r\n\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t`Found valid raised amount using pattern ${i + 1}: ${raised}`,\r\n\t\t\t\t);\r\n\t\t\t\tbreak;\r\n\t\t\t} else {\r\n\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t`Pattern ${i + 1} matched but invalid number: \"${captured}\", trying next pattern...`,\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Fallback: Look for JSON data in script tags\r\n\tif (!raised) {\r\n\t\tlogger.info(\"[SCRAPE]\", \"Checking for JSON data in script tags...\");\r\n\t\tconst scriptTagMatches = html.match(/<script[^>]*>([\\s\\S]*?)<\\/script>/gi);\r\n\t\tif (scriptTagMatches) {\r\n\t\t\tfor (const scriptTag of scriptTagMatches) {\r\n\t\t\t\t// Look for JSON data containing donation amounts with improved patterns\r\n\t\t\t\t// Try to find raised amount in JSON\r\n\t\t\t\tfor (let i = 0; i < RAISED_JSON_PATTERNS.length; i++) {\r\n\t\t\t\t\tconst pattern = RAISED_JSON_PATTERNS[i];\r\n\t\t\t\t\tconst match = scriptTag.match(pattern);\r\n\t\t\t\t\tif (match) {\r\n\t\t\t\t\t\tconst captured = match[1];\r\n\t\t\t\t\t\tif (isValidNumber(captured)) {\r\n\t\t\t\t\t\t\traised = captured;\r\n\t\t\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t\t\t`Found valid raised amount in JSON using pattern ${i + 1}: ${raised}`,\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t\t\t`JSON raised pattern ${i + 1} matched but invalid number: \"${captured}\"`,\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (raised) break;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Last resort: Look for any dollar amounts in the HTML (more generic patterns)\r\n\tif (!raised) {\r\n\t\tlogger.info(\r\n\t\t\t\"[SCRAPE]\",\r\n\t\t\t\"Trying generic dollar amount patterns as last resort...\",\r\n\t\t);\r\n\t\tfor (let i = 0; i < GENERIC_RAISED_PATTERNS.length; i++) {\r\n\t\t\tconst pattern = GENERIC_RAISED_PATTERNS[i];\r\n\t\t\tconst match = html.match(pattern);\r\n\t\t\tif (match) {\r\n\t\t\t\tconst captured = match[1];\r\n\t\t\t\tif (isValidNumber(captured)) {\r\n\t\t\t\t\traised = captured;\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Found valid raised amount using generic pattern ${i + 1}: ${raised}`,\r\n\t\t\t\t\t);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Generic pattern ${i + 1} matched but invalid number: \"${captured}\"`,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Final aggressive search: Find all dollar amounts and check their context\r\n\tif (!raised) {\r\n\t\tlogger.info(\"[SCRAPE]\", \"Performing aggressive context-based search...\");\r\n\t\tconst allDollarMatches = [...html.matchAll(/\\$([\\d,]+(?:\\.\\d+)?)/g)];\r\n\t\tlogger.debug(\r\n\t\t\t\"[SCRAPE]\",\r\n\t\t\t`Found ${allDollarMatches.length} dollar amounts in HTML`,\r\n\t\t);\r\n\r\n\t\tif (allDollarMatches.length > 0) {\r\n\t\t\t// Score each dollar amount based on context\r\n\t\t\tconst scoredAmounts: Array<{\r\n\t\t\t\tamount: string;\r\n\t\t\t\tscore: number;\r\n\t\t\t\traisedScore: number;\r\n\t\t\t\tcontext: string;\r\n\t\t\t}> = [];\r\n\r\n\t\t\tfor (const match of allDollarMatches) {\r\n\t\t\t\tconst amount = match[1];\r\n\t\t\t\tif (!isValidNumber(amount)) continue;\r\n\r\n\t\t\t\tconst matchIndex = match.index ?? 0;\r\n\t\t\t\tconst contextStart = Math.max(0, matchIndex - 300);\r\n\t\t\t\tconst contextEnd = Math.min(\r\n\t\t\t\t\thtml.length,\r\n\t\t\t\t\tmatchIndex + match[0].length + 300,\r\n\t\t\t\t);\r\n\t\t\t\tconst context = html.substring(contextStart, contextEnd).toLowerCase();\r\n\r\n\t\t\t\tlet raisedScore = 0;\r\n\r\n\t\t\t\t// Score for raised amounts\r\n\t\t\t\tif (\r\n\t\t\t\t\t/(?:raised|donated|collected|current|funds?|progress|amount\\s*(?:raised|donated))/i.test(\r\n\t\t\t\t\t\tcontext,\r\n\t\t\t\t\t)\r\n\t\t\t\t) {\r\n\t\t\t\t\traisedScore += 10;\r\n\t\t\t\t}\r\n\t\t\t\tif (\r\n\t\t\t\t\t/(?:has\\s+raised|has\\s+donated|has\\s+collected|currently\\s+raised)/i.test(\r\n\t\t\t\t\t\tcontext,\r\n\t\t\t\t\t)\r\n\t\t\t\t) {\r\n\t\t\t\t\traisedScore += 5;\r\n\t\t\t\t}\r\n\t\t\t\tif (\r\n\t\t\t\t\t/\\$[\\d,]+(?:\\.\\d+)?\\s*(?:raised|donated|collected)/i.test(context)\r\n\t\t\t\t) {\r\n\t\t\t\t\traisedScore += 8;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Store with score\r\n\t\t\t\tif (raisedScore > 0) {\r\n\t\t\t\t\tscoredAmounts.push({\r\n\t\t\t\t\t\tamount,\r\n\t\t\t\t\t\tscore: raisedScore,\r\n\t\t\t\t\t\traisedScore,\r\n\t\t\t\t\t\tcontext: context.substring(0, 200),\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Sort by score and pick the best candidate\r\n\t\t\tscoredAmounts.sort((a, b) => b.raisedScore - a.raisedScore);\r\n\r\n\t\t\t// Try to find raised amount\r\n\t\t\tif (scoredAmounts.length > 0) {\r\n\t\t\t\t// Look for amounts with raised-related context, sorted by raisedScore\r\n\t\t\t\tconst raisedCandidates = scoredAmounts\r\n\t\t\t\t\t.filter((a) => a.raisedScore > 0)\r\n\t\t\t\t\t.sort((a, b) => b.raisedScore - a.raisedScore);\r\n\t\t\t\tif (raisedCandidates.length > 0) {\r\n\t\t\t\t\traised = raisedCandidates[0].amount;\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Found raised amount via context search: ${raised} (raisedScore: ${raisedCandidates[0].raisedScore})`,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn raised;\r\n}\r\n\r\n/**\r\n * Extract target amount from HTML using DOMParser (primary method)\r\n * Falls back to regex if DOMParser fails or doesn't find results\r\n * @param html - The HTML content to parse\r\n * @returns The extracted target amount or empty string if not found\r\n */\r\nfunction extractTargetAmountWithDOMParser(html: string): string {\r\n\ttry {\r\n\t\tconst parser = new DOMParser();\r\n\t\tconst doc = parser.parseFromString(html, \"text/html\");\r\n\r\n\t\t// Try to find elements with target-related classes\r\n\t\tconst selectors = [\r\n\t\t\t\".donationProgress--amount__target\",\r\n\t\t\t'[class*=\"donationProgress--amount__target\"]',\r\n\t\t\t'[class*=\"target\"]',\r\n\t\t\t'[class*=\"goal\"]',\r\n\t\t\t\"[data-target]\",\r\n\t\t\t\"[data-goal]\",\r\n\t\t\t\"[data-target-amount]\",\r\n\t\t];\r\n\r\n\t\tfor (const selector of selectors) {\r\n\t\t\tconst elements = doc.querySelectorAll(selector);\r\n\t\t\tfor (const element of Array.from(elements)) {\r\n\t\t\t\tconst text = element.textContent || (element as HTMLElement).innerText || \"\";\r\n\t\t\t\t// Try to extract amount from text\r\n\t\t\t\tconst amountMatch = text.match(/[\\d,]+(?:\\.\\d+)?/);\r\n\t\t\t\tif (amountMatch && isValidNumber(amountMatch[0])) {\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Found target amount using DOMParser with selector \"${selector}\": ${amountMatch[0]}`,\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn amountMatch[0];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Try data attributes\r\n\t\t\t\tconst dataTarget =\r\n\t\t\t\t\telement.getAttribute(\"data-target\") ||\r\n\t\t\t\t\telement.getAttribute(\"data-goal\") ||\r\n\t\t\t\t\telement.getAttribute(\"data-target-amount\");\r\n\t\t\t\tif (dataTarget && isValidNumber(dataTarget)) {\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Found target amount using DOMParser data attribute: ${dataTarget}`,\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn dataTarget;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Try to find JSON data in script tags using DOMParser\r\n\t\tconst scriptTags = doc.querySelectorAll(\"script\");\r\n\t\tfor (const script of Array.from(scriptTags)) {\r\n\t\t\tconst scriptContent = script.textContent || script.innerHTML || \"\";\r\n\t\t\tfor (let i = 0; i < TARGET_JSON_PATTERNS.length; i++) {\r\n\t\t\t\tconst pattern = TARGET_JSON_PATTERNS[i];\r\n\t\t\t\tconst match = scriptContent.match(pattern);\r\n\t\t\t\tif (match) {\r\n\t\t\t\t\tconst captured = match[1];\r\n\t\t\t\t\tif (isValidNumber(captured)) {\r\n\t\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t\t`Found target amount in JSON using DOMParser: ${captured}`,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\treturn captured;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} catch (error) {\r\n\t\tlogger.warn(\r\n\t\t\t\"[SCRAPE]\",\r\n\t\t\t\"DOMParser extraction failed, falling back to regex:\",\r\n\t\t\terror,\r\n\t\t);\r\n\t}\r\n\r\n\treturn \"\";\r\n}\r\n\r\n/**\r\n * Extract target amount from HTML using multiple pattern strategies\r\n * Tries DOMParser first, then falls back to regex patterns\r\n * @param html - The HTML content to parse\r\n * @returns The extracted target amount or empty string if not found\r\n */\r\nexport function extractTargetAmount(html: string): string {\r\n\t// Try DOMParser first (more reliable for structured HTML)\r\n\tlet target = extractTargetAmountWithDOMParser(html);\r\n\tif (target) {\r\n\t\treturn target;\r\n\t}\r\n\r\n\tlogger.info(\r\n\t\t\"[SCRAPE]\",\r\n\t\t\"DOMParser didn't find target amount, trying regex patterns...\",\r\n\t);\r\n\ttarget = \"\";\r\n\r\n\t// Look for the target amount in the HTML\r\n\tfor (let i = 0; i < TARGET_PATTERNS.length; i++) {\r\n\t\tconst pattern = TARGET_PATTERNS[i];\r\n\t\tconst match = html.match(pattern);\r\n\t\tif (match) {\r\n\t\t\t// Get the last capture group (the amount), but also check all groups\r\n\t\t\tlet captured = match[match.length - 1];\r\n\r\n\t\t\t// If the last group is empty or invalid, try the second-to-last\r\n\t\t\tif (!captured || !isValidNumber(captured)) {\r\n\t\t\t\tif (match.length > 2) {\r\n\t\t\t\t\tcaptured = match[match.length - 2];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlogger.debug(\r\n\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t`Target pattern ${i + 1} matched, all groups:`,\r\n\t\t\t\tmatch.slice(1),\r\n\t\t\t\t`using: \"${captured}\"`,\r\n\t\t\t);\r\n\r\n\t\t\t// Validate that we captured a valid number\r\n\t\t\tif (isValidNumber(captured)) {\r\n\t\t\t\ttarget = captured;\r\n\t\t\t\tlogger.info(\r\n\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t`Found valid target amount using pattern ${i + 1}: ${target}`,\r\n\t\t\t\t);\r\n\t\t\t\tbreak;\r\n\t\t\t} else {\r\n\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t`Target pattern ${i + 1} matched but invalid number: \"${captured}\", trying next pattern...`,\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Fallback: Look for JSON data in script tags\r\n\tif (!target) {\r\n\t\tconst scriptTagMatches = html.match(/<script[^>]*>([\\s\\S]*?)<\\/script>/gi);\r\n\t\tif (scriptTagMatches) {\r\n\t\t\tfor (const scriptTag of scriptTagMatches) {\r\n\t\t\t\t// Try to find target amount in JSON\r\n\t\t\t\tfor (let i = 0; i < TARGET_JSON_PATTERNS.length; i++) {\r\n\t\t\t\t\tconst pattern = TARGET_JSON_PATTERNS[i];\r\n\t\t\t\t\tconst match = scriptTag.match(pattern);\r\n\t\t\t\t\tif (match) {\r\n\t\t\t\t\t\tconst captured = match[1];\r\n\t\t\t\t\t\tif (isValidNumber(captured)) {\r\n\t\t\t\t\t\t\ttarget = captured;\r\n\t\t\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t\t\t`Found valid target amount in JSON using pattern ${i + 1}: ${target}`,\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t\t\t`JSON target pattern ${i + 1} matched but invalid number: \"${captured}\"`,\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (target) break;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Last resort: Look for any dollar amounts in the HTML (more generic patterns)\r\n\tif (!target) {\r\n\t\tlogger.info(\r\n\t\t\t\"[SCRAPE]\",\r\n\t\t\t\"Trying generic target amount patterns as last resort...\",\r\n\t\t);\r\n\t\tfor (let i = 0; i < GENERIC_TARGET_PATTERNS.length; i++) {\r\n\t\t\tconst pattern = GENERIC_TARGET_PATTERNS[i];\r\n\t\t\tconst match = html.match(pattern);\r\n\t\t\tif (match) {\r\n\t\t\t\t// Iterate backward from the last capture group to index 1\r\n\t\t\t\t// Pick the first non-empty capture that passes isValidNumber\r\n\t\t\t\tlet captured: string | null = null;\r\n\t\t\t\tfor (let j = match.length - 1; j >= 1; j--) {\r\n\t\t\t\t\tif (match[j] && isValidNumber(match[j])) {\r\n\t\t\t\t\t\tcaptured = match[j];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (captured) {\r\n\t\t\t\t\ttarget = captured;\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Found valid target amount using generic pattern ${i + 1}: ${target}`,\r\n\t\t\t\t\t);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Generic target pattern ${i + 1} matched but no valid number found in capture groups`,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Final aggressive search: Find all dollar amounts and check their context\r\n\tif (!target) {\r\n\t\tconst allDollarMatches = [...html.matchAll(/\\$([\\d,]+(?:\\.\\d+)?)/g)];\r\n\r\n\t\tif (allDollarMatches.length > 0) {\r\n\t\t\t// Score each dollar amount based on context\r\n\t\t\tconst scoredAmounts: Array<{\r\n\t\t\t\tamount: string;\r\n\t\t\t\tscore: number;\r\n\t\t\t\ttargetScore: number;\r\n\t\t\t\tcontext: string;\r\n\t\t\t}> = [];\r\n\r\n\t\t\tfor (const match of allDollarMatches) {\r\n\t\t\t\tconst amount = match[1];\r\n\t\t\t\tif (!isValidNumber(amount)) continue;\r\n\r\n\t\t\t\tconst matchIndex = match.index ?? 0;\r\n\t\t\t\tconst contextStart = Math.max(0, matchIndex - 300);\r\n\t\t\t\tconst contextEnd = Math.min(\r\n\t\t\t\t\thtml.length,\r\n\t\t\t\t\tmatchIndex + match[0].length + 300,\r\n\t\t\t\t);\r\n\t\t\t\tconst context = html.substring(contextStart, contextEnd).toLowerCase();\r\n\r\n\t\t\t\tlet targetScore = 0;\r\n\r\n\t\t\t\t// Score for target amounts\r\n\t\t\t\tif (/(?:target|goal|aim|objective|of\\s+\\$)/i.test(context)) {\r\n\t\t\t\t\ttargetScore += 10;\r\n\t\t\t\t}\r\n\t\t\t\tif (\r\n\t\t\t\t\t/(?:target\\s+(?:of|is)|goal\\s+(?:of|is)|aim\\s+(?:of|is))/i.test(\r\n\t\t\t\t\t\tcontext,\r\n\t\t\t\t\t)\r\n\t\t\t\t) {\r\n\t\t\t\t\ttargetScore += 5;\r\n\t\t\t\t}\r\n\t\t\t\tif (/\\$[\\d,]+(?:\\.\\d+)?\\s*(?:target|goal)/i.test(context)) {\r\n\t\t\t\t\ttargetScore += 8;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Store with score\r\n\t\t\t\tif (targetScore > 0) {\r\n\t\t\t\t\tscoredAmounts.push({\r\n\t\t\t\t\t\tamount,\r\n\t\t\t\t\t\tscore: targetScore,\r\n\t\t\t\t\t\ttargetScore,\r\n\t\t\t\t\t\tcontext: context.substring(0, 200),\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Sort by score and pick the best candidate\r\n\t\t\tscoredAmounts.sort((a, b) => b.targetScore - a.targetScore);\r\n\r\n\t\t\t// Try to find target amount\r\n\t\t\tif (scoredAmounts.length > 0) {\r\n\t\t\t\t// Look for amounts with target-related context, sorted by targetScore\r\n\t\t\t\tconst targetCandidates = scoredAmounts\r\n\t\t\t\t\t.filter((a) => a.targetScore > 0)\r\n\t\t\t\t\t.sort((a, b) => b.targetScore - a.targetScore);\r\n\t\t\t\tif (targetCandidates.length > 0) {\r\n\t\t\t\t\ttarget = targetCandidates[0].amount;\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Found target amount via context search: ${target} (targetScore: ${targetCandidates[0].targetScore})`,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn target;\r\n}\r\n\r\n/**\r\n * Extract both raised and target amounts from HTML\r\n * @param html - The HTML content to parse\r\n * @param memberId - The member ID (for logging)\r\n * @param subdomain - The subdomain (for logging)\r\n * @returns Object containing extracted amounts\r\n */\r\nexport function extractAmounts(\r\n\thtml: string,\r\n\tmemberId: string,\r\n\tsubdomain: string,\r\n): ExtractedAmounts {\r\n\tconst extractStart = Date.now();\r\n\tlogger.info(\"[SCRAPE]\", \"Extracting data from HTML...\");\r\n\r\n\tconst raised = extractRaisedAmount(html);\r\n\tconst target = extractTargetAmount(html);\r\n\r\n\tconst extractDuration = Date.now() - extractStart;\r\n\tlogger.info(\r\n\t\t\"[SCRAPE]\",\r\n\t\t`Data extraction completed in ${formatDuration(extractDuration)}`,\r\n\t);\r\n\tlogger.debug(\r\n\t\t\"[SCRAPE]\",\r\n\t\t`Raw extracted data for memberId ${memberId} (subdomain: ${subdomain}):`,\r\n\t\t{\r\n\t\t\traised: raised || \"NOT FOUND\",\r\n\t\t\ttarget: target || \"NOT FOUND\",\r\n\t\t},\r\n\t);\r\n\r\n\treturn { raised, target };\r\n}\r\n\r\n", "/**\r\n * Structured error tracking module\r\n * Can be extended to integrate with Sentry or other error tracking services\r\n * @module error-tracking\r\n */\r\n\r\nimport logger from \"./logger.js\";\r\n\r\n/**\r\n * Error severity levels\r\n */\r\nexport const ERROR_SEVERITY = {\r\n\tLOW: \"low\",\r\n\tMEDIUM: \"medium\",\r\n\tHIGH: \"high\",\r\n\tCRITICAL: \"critical\",\r\n} as const;\r\n\r\n/**\r\n * Error categories\r\n */\r\nexport const ERROR_CATEGORY = {\r\n\tSCRAPING: \"scraping\",\r\n\tSUBDOMAIN: \"subdomain\",\r\n\tCACHE: \"cache\",\r\n\tNETWORK: \"network\",\r\n\tPARSING: \"parsing\",\r\n\tVALIDATION: \"validation\",\r\n\tUNKNOWN: \"unknown\",\r\n} as const;\r\n\r\nexport type ErrorSeverity = (typeof ERROR_SEVERITY)[keyof typeof ERROR_SEVERITY];\r\nexport type ErrorCategory = (typeof ERROR_CATEGORY)[keyof typeof ERROR_CATEGORY];\r\n\r\nexport interface ErrorContext {\r\n\tcategory?: ErrorCategory;\r\n\tseverity?: ErrorSeverity;\r\n\tmemberId?: string;\r\n\tsubdomain?: string;\r\n\turl?: string;\r\n\tmetadata?: Record<string, unknown>;\r\n}\r\n\r\nexport interface ErrorInfo {\r\n\ttimestamp: string;\r\n\tmessage: string;\r\n\tstack?: string;\r\n\tcategory: ErrorCategory;\r\n\tseverity: ErrorSeverity;\r\n\tcontext: {\r\n\t\tmemberId?: string;\r\n\t\tsubdomain?: string;\r\n\t\turl?: string;\r\n\t\t[key: string]: unknown;\r\n\t};\r\n}\r\n\r\n/**\r\n * Track an error with structured context\r\n * @param error - The error object or error message\r\n * @param context - Additional context about the error\r\n * @returns The tracked error information\r\n */\r\nexport function trackError(error: Error | string, context: ErrorContext = {}): ErrorInfo {\r\n\tconst errorInfo: ErrorInfo = {\r\n\t\ttimestamp: new Date().toISOString(),\r\n\t\tmessage: error instanceof Error ? error.message : String(error),\r\n\t\tstack: error instanceof Error ? error.stack : undefined,\r\n\t\tcategory: context.category || ERROR_CATEGORY.UNKNOWN,\r\n\t\tseverity: context.severity || ERROR_SEVERITY.MEDIUM,\r\n\t\tcontext: {\r\n\t\t\tmemberId: context.memberId,\r\n\t\t\tsubdomain: context.subdomain,\r\n\t\t\turl: context.url,\r\n\t\t\t...(context.metadata || {}),\r\n\t\t},\r\n\t};\r\n\r\n\t// Log the error with structured information\r\n\tlogger.error(\r\n\t\t\"[ERROR_TRACKING]\",\r\n\t\t`[${errorInfo.category}] [${errorInfo.severity}] ${errorInfo.message}`,\r\n\t\terrorInfo,\r\n\t);\r\n\r\n\t// In the future, this can be extended to send to Sentry:\r\n\t// if (window.Sentry) {\r\n\t//   window.Sentry.captureException(error, {\r\n\t//     tags: {\r\n\t//       category: errorInfo.category,\r\n\t//       severity: errorInfo.severity,\r\n\t//     },\r\n\t//     extra: errorInfo.context,\r\n\t//   });\r\n\t// }\r\n\r\n\t// Store errors in localStorage for debugging (limit to last 50 errors)\r\n\ttry {\r\n\t\tconst storedErrors = JSON.parse(\r\n\t\t\tlocalStorage.getItem(\"error_tracking_log\") || \"[]\",\r\n\t\t) as ErrorInfo[];\r\n\t\tstoredErrors.push(errorInfo);\r\n\t\t// Keep only last 50 errors\r\n\t\tif (storedErrors.length > 50) {\r\n\t\t\tstoredErrors.shift();\r\n\t\t}\r\n\t\tlocalStorage.setItem(\"error_tracking_log\", JSON.stringify(storedErrors));\r\n\t} catch (e) {\r\n\t\t// Ignore localStorage errors\r\n\t\tlogger.warn(\r\n\t\t\t\"[ERROR_TRACKING]\",\r\n\t\t\t\"Failed to store error in localStorage:\",\r\n\t\t\te,\r\n\t\t);\r\n\t}\r\n\r\n\treturn errorInfo;\r\n}\r\n\r\n/**\r\n * Track a scraping error\r\n * @param error - The error object\r\n * @param context - Additional context\r\n */\r\nexport function trackScrapingError(error: Error, context: Omit<ErrorContext, \"category\" | \"severity\"> = {}): ErrorInfo {\r\n\treturn trackError(error, {\r\n\t\tcategory: ERROR_CATEGORY.SCRAPING,\r\n\t\tseverity: ERROR_SEVERITY.HIGH,\r\n\t\t...context,\r\n\t});\r\n}\r\n\r\n/**\r\n * Track a subdomain detection error\r\n * @param error - The error object\r\n * @param context - Additional context\r\n */\r\nexport function trackSubdomainError(error: Error, context: Omit<ErrorContext, \"category\" | \"severity\"> = {}): ErrorInfo {\r\n\treturn trackError(error, {\r\n\t\tcategory: ERROR_CATEGORY.SUBDOMAIN,\r\n\t\tseverity: ERROR_SEVERITY.MEDIUM,\r\n\t\t...context,\r\n\t});\r\n}\r\n\r\n/**\r\n * Track a network error\r\n * @param error - The error object\r\n * @param context - Additional context\r\n */\r\nexport function trackNetworkError(error: Error, context: Omit<ErrorContext, \"category\" | \"severity\"> = {}): ErrorInfo {\r\n\treturn trackError(error, {\r\n\t\tcategory: ERROR_CATEGORY.NETWORK,\r\n\t\tseverity: ERROR_SEVERITY.HIGH,\r\n\t\t...context,\r\n\t});\r\n}\r\n\r\n/**\r\n * Track a parsing error\r\n * @param error - The error object\r\n * @param context - Additional context\r\n */\r\nexport function trackParsingError(error: Error, context: Omit<ErrorContext, \"category\" | \"severity\"> = {}): ErrorInfo {\r\n\treturn trackError(error, {\r\n\t\tcategory: ERROR_CATEGORY.PARSING,\r\n\t\tseverity: ERROR_SEVERITY.MEDIUM,\r\n\t\t...context,\r\n\t});\r\n}\r\n\r\n/**\r\n * Get recent errors from localStorage\r\n * @param limit - Maximum number of errors to return\r\n * @returns Array of recent errors\r\n */\r\nexport function getRecentErrors(limit = 10): ErrorInfo[] {\r\n\ttry {\r\n\t\tconst storedErrors = JSON.parse(\r\n\t\t\tlocalStorage.getItem(\"error_tracking_log\") || \"[]\",\r\n\t\t) as ErrorInfo[];\r\n\t\treturn storedErrors.slice(-limit);\r\n\t} catch (e) {\r\n\t\tlogger.warn(\"[ERROR_TRACKING]\", \"Failed to get recent errors:\", e);\r\n\t\treturn [];\r\n\t}\r\n}\r\n\r\n/**\r\n * Clear error tracking log\r\n */\r\nexport function clearErrorLog(): void {\r\n\ttry {\r\n\t\tlocalStorage.removeItem(\"error_tracking_log\");\r\n\t\tlogger.info(\"[ERROR_TRACKING]\", \"Error log cleared\");\r\n\t} catch (e) {\r\n\t\tlogger.warn(\"[ERROR_TRACKING]\", \"Failed to clear error log:\", e);\r\n\t}\r\n}\r\n\r\n", "/**\r\n * Network utilities for fetching Movember pages via proxy\r\n * @module scraper/network\r\n */\r\n\r\nimport { getProxyUrl, MOVEMBER_BASE_URL_TEMPLATE } from \"../constants.js\";\r\nimport { trackNetworkError } from \"../error-tracking.js\";\r\nimport logger from \"../logger.js\";\r\nimport { URL_PATTERNS } from \"../regex-patterns.js\";\r\n\r\nexport interface FetchResult {\r\n\thtml: string;\r\n\tfinalUrl: string;\r\n}\r\n\r\n/**\r\n * Extract subdomain from a Movember URL\r\n * @param url - The Movember URL\r\n * @returns The subdomain (e.g., \"uk\", \"au\", \"us\") or null if not found\r\n */\r\nexport function extractSubdomainFromUrl(url: string): string | null {\r\n\tconst match = url.match(URL_PATTERNS.SUBDOMAIN);\r\n\treturn match ? match[1] : null;\r\n}\r\n\r\n/**\r\n * Fetch HTML using Worker's CORS proxy\r\n * Returns both HTML and the final URL after redirects\r\n * @param url - The URL to fetch\r\n * @returns The HTML content and final URL\r\n * @throws If the proxy request fails\r\n */\r\nexport async function fetchViaProxy(url: string): Promise<FetchResult> {\r\n\tconst proxyUrl = `${getProxyUrl()}?url=${encodeURIComponent(url)}`;\r\n\tconst response = await fetch(proxyUrl);\r\n\r\n\tif (!response.ok) {\r\n\t\t// Try to get error message from response\r\n\t\tlet errorMessage = `Proxy error! status: ${response.status}`;\r\n\t\ttry {\r\n\t\t\tconst contentType = response.headers.get(\"content-type\");\r\n\t\t\tif (contentType?.includes(\"application/json\")) {\r\n\t\t\t\tconst errorData = (await response.json()) as { message?: string };\r\n\t\t\t\tif (errorData.message) {\r\n\t\t\t\t\terrorMessage = errorData.message;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconst errorText = await response.text();\r\n\t\t\t\tif (errorText) {\r\n\t\t\t\t\terrorMessage = errorText.substring(0, 200); // Limit error message length\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\t// Ignore parse errors, use default error message\r\n\t\t\tlogger.warn(\"[PROXY]\", \"Could not parse error response:\", e);\r\n\t\t}\r\n\r\n\t\tconst error = new Error(errorMessage);\r\n\t\t// Track network error with structured context\r\n\t\ttrackNetworkError(error, {\r\n\t\t\turl,\r\n\t\t\tmetadata: {\r\n\t\t\t\tstatus: response.status,\r\n\t\t\t\tstatusText: response.statusText,\r\n\t\t\t},\r\n\t\t});\r\n\r\n\t\tthrow error;\r\n\t}\r\n\r\n\t// Worker proxy returns HTML directly\r\n\tconst html = await response.text();\r\n\t// Get final URL after redirects from response header\r\n\tconst finalUrl = response.headers.get(\"X-Final-URL\") || url;\r\n\r\n\treturn { html, finalUrl };\r\n}\r\n\r\n/**\r\n * Build Movember URL with correct subdomain for a member\r\n * @param memberId - The member ID\r\n * @param subdomain - The subdomain to use\r\n * @returns The complete Movember URL\r\n */\r\nexport function buildMovemberUrl(memberId: string, subdomain: string): string {\r\n\tconst baseUrl = MOVEMBER_BASE_URL_TEMPLATE.replace(\"{subdomain}\", subdomain);\r\n\treturn `${baseUrl}?memberId=${memberId}`;\r\n}\r\n\r\n", "// localStorage cache manager with TTL support\r\n// Subdomain stored in separate cache key (movember:subdomain:${memberId}) with 24h TTL\r\n// Data stored in separate cache key (movember:data:${memberId}) with 5min TTL\r\nimport { SUBDOMAIN_CACHE_TTL } from \"./constants.js\";\r\nimport logger from \"./logger.js\";\r\n\r\nexport interface CachedData {\r\n\tamount: string;\r\n\tcurrency: string;\r\n\tsubdomain: string;\r\n\ttimestamp: number;\r\n\ttarget?: string;\r\n\tpercentage?: number;\r\n}\r\n\r\ninterface CacheEntry<T> {\r\n\tdata: T;\r\n\tcachedAt: number;\r\n\tttl: number;\r\n}\r\n\r\ninterface SubdomainCacheEntry {\r\n\tsubdomain: string;\r\n\tcachedAt: number;\r\n\tttl: number;\r\n}\r\n\r\n/**\r\n * Get cached donation data for a member (includes subdomain)\r\n * @param memberId - Member ID\r\n * @returns Cached data or null if expired/not found\r\n * Data structure: { amount, currency, target, percentage, timestamp, subdomain }\r\n */\r\nexport function getCachedData(memberId: string): CachedData | null {\r\n\ttry {\r\n\t\tconst cacheKey = `movember:data:${memberId}`;\r\n\t\tconst cached = localStorage.getItem(cacheKey);\r\n\t\tif (!cached) return null;\r\n\r\n\t\tconst entry = JSON.parse(cached) as CacheEntry<CachedData>;\r\n\t\tconst now = Date.now();\r\n\r\n\t\t// Check if cache is expired\r\n\t\tif (now - entry.cachedAt > entry.ttl) {\r\n\t\t\tlocalStorage.removeItem(cacheKey);\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn entry.data;\r\n\t} catch (error) {\r\n\t\tlogger.warn(\"[CACHE]\", \"Error reading cached data:\", error);\r\n\t\treturn null;\r\n\t}\r\n}\r\n\r\n/**\r\n * Get stale cached data for a member (even if expired)\r\n * Used for stale-while-revalidate pattern\r\n * @param memberId - Member ID\r\n * @returns Stale cached data or null if not found\r\n * Data structure: { amount, currency, target, percentage, timestamp, subdomain }\r\n */\r\nexport function getStaleCachedData(memberId: string): CachedData | null {\r\n\ttry {\r\n\t\tconst cacheKey = `movember:data:${memberId}`;\r\n\t\tconst cached = localStorage.getItem(cacheKey);\r\n\t\tif (!cached) return null;\r\n\r\n\t\tconst entry = JSON.parse(cached) as CacheEntry<CachedData>;\r\n\r\n\t\t// Return data even if expired (for stale-while-revalidate)\r\n\t\t// Only return null if cache doesn't exist\r\n\t\treturn entry.data;\r\n\t} catch (error) {\r\n\t\tlogger.warn(\"[CACHE]\", \"Error reading stale cached data:\", error);\r\n\t\treturn null;\r\n\t}\r\n}\r\n\r\n/**\r\n * Check if cached data is stale (expired but still available)\r\n * @param memberId - Member ID\r\n * @returns True if data exists but is expired, false otherwise\r\n */\r\nexport function isCachedDataStale(memberId: string): boolean {\r\n\ttry {\r\n\t\tconst cacheKey = `movember:data:${memberId}`;\r\n\t\tconst cached = localStorage.getItem(cacheKey);\r\n\t\tif (!cached) return false;\r\n\r\n\t\tconst entry = JSON.parse(cached) as CacheEntry<CachedData>;\r\n\t\tconst now = Date.now();\r\n\r\n\t\t// Check if cache is expired\r\n\t\treturn now - entry.cachedAt > entry.ttl;\r\n\t} catch (error) {\r\n\t\tlogger.warn(\"[CACHE]\", \"Error checking if cached data is stale:\", error);\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n/**\r\n * Set cached donation data for a member (includes subdomain)\r\n * @param memberId - Member ID\r\n * @param data - Data to cache (must include subdomain)\r\n * @param ttl - Time to live in milliseconds\r\n */\r\nexport function setCachedData(memberId: string, data: CachedData, ttl: number): void {\r\n\ttry {\r\n\t\tconst cacheKey = `movember:data:${memberId}`;\r\n\t\tconst cacheValue: CacheEntry<CachedData> = {\r\n\t\t\tdata,\r\n\t\t\tcachedAt: Date.now(),\r\n\t\t\tttl,\r\n\t\t};\r\n\t\tlocalStorage.setItem(cacheKey, JSON.stringify(cacheValue));\r\n\t} catch (error) {\r\n\t\tlogger.warn(\"[CACHE]\", \"Error setting cached data:\", error);\r\n\t}\r\n}\r\n\r\n/**\r\n * Get cached subdomain for a member (from separate cache key)\r\n * Uses subdomain TTL (24h) independent of data TTL (5min) - subdomain persists longer\r\n * @param memberId - Member ID\r\n * @returns Cached subdomain or null if expired/not found\r\n */\r\nexport function getCachedSubdomain(memberId: string): string | null {\r\n\ttry {\r\n\t\tconst cacheKey = `movember:subdomain:${memberId}`;\r\n\t\tconst cached = localStorage.getItem(cacheKey);\r\n\t\tif (!cached) return null;\r\n\r\n\t\tconst entry = JSON.parse(cached) as SubdomainCacheEntry;\r\n\t\tconst now = Date.now();\r\n\r\n\t\t// Check if cache is expired using the stored TTL\r\n\t\tif (now - entry.cachedAt > entry.ttl) {\r\n\t\t\tlocalStorage.removeItem(cacheKey);\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn entry.subdomain;\r\n\t} catch (error) {\r\n\t\tlogger.warn(\"[CACHE]\", \"Error reading cached subdomain:\", error);\r\n\t\treturn null;\r\n\t}\r\n}\r\n\r\n/**\r\n * Set cached subdomain for a member (uses separate cache key with independent TTL)\r\n * @param memberId - Member ID\r\n * @param subdomain - Subdomain to cache\r\n * @param ttl - Time to live in milliseconds (typically SUBDOMAIN_CACHE_TTL)\r\n */\r\nexport function setCachedSubdomain(memberId: string, subdomain: string, ttl: number): void {\r\n\ttry {\r\n\t\tconst cacheKey = `movember:subdomain:${memberId}`;\r\n\t\tconst cacheValue: SubdomainCacheEntry = {\r\n\t\t\tsubdomain,\r\n\t\t\tcachedAt: Date.now(),\r\n\t\t\tttl,\r\n\t\t};\r\n\t\tlocalStorage.setItem(cacheKey, JSON.stringify(cacheValue));\r\n\t} catch (error) {\r\n\t\tlogger.warn(\"[CACHE]\", \"Error setting cached subdomain:\", error);\r\n\t}\r\n}\r\n\r\n/**\r\n * Clear cached data for a member (clears both data and subdomain)\r\n * @param memberId - Member ID\r\n */\r\nexport function clearSubdomainCache(memberId: string): void {\r\n\ttry {\r\n\t\tconst cacheKey = `movember:data:${memberId}`;\r\n\t\tlocalStorage.removeItem(cacheKey);\r\n\r\n\t\t// Clear separate subdomain cache\r\n\t\tconst subdomainKey = `movember:subdomain:${memberId}`;\r\n\t\tlocalStorage.removeItem(subdomainKey);\r\n\r\n\t\t// Also clear old amount cache if it exists (migration cleanup)\r\n\t\tconst oldAmountKey = `movember:amount:${memberId}`;\r\n\t\tlocalStorage.removeItem(oldAmountKey);\r\n\t} catch (error) {\r\n\t\tlogger.warn(\"[CACHE]\", \"Error clearing cached data:\", error);\r\n\t}\r\n}\r\n\r\n", "/**\r\n * Subdomain detection logic for Movember pages\r\n * @module scraper/subdomain\r\n */\r\n\r\nimport { getCachedSubdomain, setCachedSubdomain } from \"../cache.js\";\r\nimport {\r\n\tDEFAULT_SUBDOMAIN,\r\n\tMEMBER_SUBDOMAIN_MAP,\r\n\tSUBDOMAIN_CACHE_TTL,\r\n} from \"../constants.js\";\r\nimport { trackSubdomainError } from \"../error-tracking.js\";\r\nimport logger from \"../logger.js\";\r\nimport {\r\n\tCOUNTRY_DETECTION_PATTERNS,\r\n\tCURRENCY_CODE_PATTERNS,\r\n\tDOLLAR_AMOUNT_PATTERN,\r\n} from \"../regex-patterns.js\";\r\nimport {\r\n\tbuildMovemberUrl,\r\n\textractSubdomainFromUrl,\r\n\tfetchViaProxy,\r\n} from \"./network.js\";\r\n\r\n/**\r\n * Detect subdomain from HTML content by checking currency symbols\r\n * This is used for verification - if currency doesn't match URL subdomain, we skip it\r\n * Made more aggressive: checks for currency symbols anywhere, not just near amounts\r\n * @param html - The HTML content to analyze\r\n * @returns The detected subdomain or null if not found\r\n */\r\nexport function detectSubdomainFromHtml(html: string | null | undefined): string | null {\r\n\tif (!html) return null;\r\n\r\n\t// First, check for unambiguous currency symbols anywhere in HTML (most reliable)\r\n\t// \u00A3 symbol anywhere indicates UK (GBP)\r\n\tif (\r\n\t\thtml.includes(\"\u00A3\") ||\r\n\t\thtml.includes(\"&pound;\") ||\r\n\t\thtml.includes(\"&#163;\")\r\n\t) {\r\n\t\treturn \"uk\";\r\n\t}\r\n\r\n\t// \u20AC symbol anywhere indicates EU\r\n\tif (\r\n\t\thtml.includes(\"\u20AC\") ||\r\n\t\thtml.includes(\"&euro;\") ||\r\n\t\thtml.includes(\"&#8364;\")\r\n\t) {\r\n\t\t// Try to determine which EU country by checking for country-specific text\r\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.IRELAND)) return \"ie\";\r\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.NETHERLANDS)) return \"nl\";\r\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.GERMANY)) return \"de\";\r\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.FRANCE)) return \"fr\";\r\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.SPAIN)) return \"es\";\r\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.ITALY)) return \"it\";\r\n\t\t// Default to first EU country if we can't determine\r\n\t\treturn \"ie\";\r\n\t}\r\n\r\n\t// Look for currency codes near amounts (secondary check)\r\n\t// Pattern: currency code followed by amount, or amount followed by currency code\r\n\r\n\t// Check for GBP code near amounts (UK) - secondary check after symbol check\r\n\tif (CURRENCY_CODE_PATTERNS[0].test(html)) {\r\n\t\treturn \"uk\";\r\n\t}\r\n\r\n\t// Check for EUR/\u20AC near amounts (EU countries)\r\n\tif (CURRENCY_CODE_PATTERNS[1].test(html)) {\r\n\t\t// Try to determine which EU country by checking for country-specific text\r\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.IRELAND)) return \"ie\";\r\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.NETHERLANDS)) return \"nl\";\r\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.GERMANY)) return \"de\";\r\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.FRANCE)) return \"fr\";\r\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.SPAIN)) return \"es\";\r\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.ITALY)) return \"it\";\r\n\t\t// Default to first EU country if we can't determine\r\n\t\treturn \"ie\";\r\n\t}\r\n\r\n\t// Check for USD near amounts (US)\r\n\tif (CURRENCY_CODE_PATTERNS[2].test(html)) {\r\n\t\treturn \"us\";\r\n\t}\r\n\r\n\t// Check for AUD near amounts (Australia) - check before generic $\r\n\tif (CURRENCY_CODE_PATTERNS[3].test(html)) {\r\n\t\treturn \"au\";\r\n\t}\r\n\r\n\t// Check for CAD near amounts (Canada)\r\n\tif (CURRENCY_CODE_PATTERNS[4].test(html)) {\r\n\t\treturn \"ca\";\r\n\t}\r\n\r\n\t// Check for NZD near amounts (New Zealand)\r\n\tif (CURRENCY_CODE_PATTERNS[5].test(html)) {\r\n\t\treturn \"nz\";\r\n\t}\r\n\r\n\t// Check for ZAR near amounts (South Africa)\r\n\tif (CURRENCY_CODE_PATTERNS[6].test(html)) {\r\n\t\treturn \"za\";\r\n\t}\r\n\r\n\t// Check for CZK/K\u010D near amounts (Czech Republic)\r\n\tif (CURRENCY_CODE_PATTERNS[7].test(html)) {\r\n\t\treturn \"cz\";\r\n\t}\r\n\r\n\t// Check for SEK near amounts (Sweden)\r\n\tif (CURRENCY_CODE_PATTERNS[8].test(html)) {\r\n\t\treturn \"se\";\r\n\t}\r\n\r\n\t// Check for DKK near amounts (Denmark)\r\n\tif (CURRENCY_CODE_PATTERNS[9].test(html)) {\r\n\t\treturn \"dk\";\r\n\t}\r\n\r\n\t// Fallback: Check for $ near amounts (but this is ambiguous)\r\n\t// Only use if we see $ followed by digits, and prefer AUD as default\r\n\tif (DOLLAR_AMOUNT_PATTERN.test(html)) {\r\n\t\t// Try to find country indicators\r\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.UNITED_STATES)) return \"us\";\r\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.CANADA)) return \"ca\";\r\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.NEW_ZEALAND)) return \"nz\";\r\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.AUSTRALIA)) return \"au\";\r\n\t\t// Default to AUD if we can't determine (since au is default subdomain)\r\n\t\treturn \"au\";\r\n\t}\r\n\r\n\treturn null;\r\n}\r\n\r\n/**\r\n * Detect subdomain by following redirects and checking HTML content\r\n * @param memberId - The member ID\r\n * @param forceRefresh - Whether to force refresh (skip cache)\r\n * @returns The detected subdomain\r\n */\r\nexport async function detectSubdomainForMember(\r\n\tmemberId: string,\r\n\tforceRefresh = false,\r\n): Promise<string> {\r\n\t// Check cache first (unless forcing refresh)\r\n\tif (!forceRefresh) {\r\n\t\tconst cached = getCachedSubdomain(memberId);\r\n\t\tif (cached) {\r\n\t\t\tlogger.info(\r\n\t\t\t\t\"[SUBDOMAIN]\",\r\n\t\t\t\t`Found cached subdomain for memberId ${memberId}: ${cached}`,\r\n\t\t\t);\r\n\t\t\treturn cached;\r\n\t\t}\r\n\t} else {\r\n\t\tlogger.info(\r\n\t\t\t\"[SUBDOMAIN]\",\r\n\t\t\t`Force refresh requested, skipping cache for memberId ${memberId}`,\r\n\t\t);\r\n\t}\r\n\r\n\t// Check manual override\r\n\tif (MEMBER_SUBDOMAIN_MAP[memberId]) {\r\n\t\tconst subdomain = MEMBER_SUBDOMAIN_MAP[memberId];\r\n\t\tlogger.info(\r\n\t\t\t\"[SUBDOMAIN]\",\r\n\t\t\t`Using manual override for memberId ${memberId}: ${subdomain}`,\r\n\t\t);\r\n\t\t// Cache the manual override\r\n\t\tsetCachedSubdomain(memberId, subdomain, SUBDOMAIN_CACHE_TTL);\r\n\t\treturn subdomain;\r\n\t}\r\n\r\n\t// Try to detect by checking common subdomains and their HTML content\r\n\tlogger.info(\"[SUBDOMAIN]\", `Detecting subdomain for memberId ${memberId}...`);\r\n\t// Optimized: Prioritize most common subdomains first (based on usage statistics)\r\n\t// This reduces average detection time by testing high-probability subdomains first\r\n\tconst commonSubdomains = [\r\n\t\t\"au\", // Most common (default)\r\n\t\t\"uk\", // Very common\r\n\t\t\"us\", // Very common\r\n\t\t\"ca\", // Common\r\n\t\t\"nz\", // Common\r\n\t\t\"ie\", // Common (EU)\r\n\t\t\"za\", // Less common\r\n\t\t\"nl\", // Less common (EU)\r\n\t\t\"de\", // Less common (EU)\r\n\t\t\"fr\", // Less common (EU)\r\n\t\t\"es\", // Less common (EU)\r\n\t\t\"it\", // Less common (EU)\r\n\t\t\"cz\", // Rare\r\n\t\t\"dk\", // Rare\r\n\t\t\"se\", // Rare\r\n\t\t\"ex\", // Rare (experimental)\r\n\t];\r\n\r\n\ttry {\r\n\t\t// Try common subdomains and check for currency indicators\r\n\t\t// Primary method: Verify with HTML currency check (most reliable)\r\n\t\t// Secondary method: Use URL subdomain as fallback if currency check is inconclusive\r\n\t\tlet fallbackSubdomain: string | null = null;\r\n\r\n\t\t// Optimized: Test subdomains with early exit when match is found\r\n\t\t// This reduces average detection time significantly\r\n\t\tfor (const subdomain of commonSubdomains) {\r\n\t\t\tconst testSubdomainUrl = buildMovemberUrl(memberId, subdomain);\r\n\t\t\ttry {\r\n\t\t\t\tconst { html: testHtml, finalUrl } =\r\n\t\t\t\t\tawait fetchViaProxy(testSubdomainUrl);\r\n\r\n\t\t\t\t// Extract actual subdomain from final URL (after redirects)\r\n\t\t\t\tconst actualSubdomain = extractSubdomainFromUrl(finalUrl);\r\n\r\n\t\t\t\t// Early exit optimization: If we get a redirect to a valid subdomain, use it immediately\r\n\t\t\t\tif (actualSubdomain && actualSubdomain !== subdomain) {\r\n\t\t\t\t\t// URL redirected to a different subdomain - use the actual one (most reliable)\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SUBDOMAIN]\",\r\n\t\t\t\t\t\t`URL redirected from ${subdomain} to ${actualSubdomain} for memberId ${memberId} (early exit)`,\r\n\t\t\t\t\t);\r\n\t\t\t\t\tsetCachedSubdomain(memberId, actualSubdomain, SUBDOMAIN_CACHE_TTL);\r\n\t\t\t\t\treturn actualSubdomain;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (testHtml && testHtml.length > 1000) {\r\n\t\t\t\t\t// Check HTML for currency indicators\r\n\t\t\t\t\tconst detectedSubdomain = detectSubdomainFromHtml(testHtml);\r\n\r\n\t\t\t\t\t// Priority 1: If HTML currency check confirms the subdomain, use it (early exit)\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tdetectedSubdomain === subdomain ||\r\n\t\t\t\t\t\tdetectedSubdomain === actualSubdomain\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\t// HTML matches this subdomain's currency - this is correct\r\n\t\t\t\t\t\tconst confirmedSubdomain = actualSubdomain || subdomain;\r\n\t\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\t\"[SUBDOMAIN]\",\r\n\t\t\t\t\t\t\t`Found matching subdomain for memberId ${memberId}: ${confirmedSubdomain} (verified by currency, early exit)`,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tsetCachedSubdomain(\r\n\t\t\t\t\t\t\tmemberId,\r\n\t\t\t\t\t\t\tconfirmedSubdomain,\r\n\t\t\t\t\t\t\tSUBDOMAIN_CACHE_TTL,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\treturn confirmedSubdomain;\r\n\t\t\t\t\t} else if (\r\n\t\t\t\t\t\tdetectedSubdomain &&\r\n\t\t\t\t\t\tdetectedSubdomain !== subdomain &&\r\n\t\t\t\t\t\tdetectedSubdomain !== actualSubdomain\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\t// HTML indicates a different subdomain - use the detected one (currency is reliable, early exit)\r\n\t\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\t\"[SUBDOMAIN]\",\r\n\t\t\t\t\t\t\t`HTML currency indicates ${detectedSubdomain} (tested ${subdomain}, final URL: ${actualSubdomain || subdomain}), using detected subdomain (early exit)`,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tsetCachedSubdomain(\r\n\t\t\t\t\t\t\tmemberId,\r\n\t\t\t\t\t\t\tdetectedSubdomain,\r\n\t\t\t\t\t\t\tSUBDOMAIN_CACHE_TTL,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\treturn detectedSubdomain;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Can't determine from currency, but HTML is valid\r\n\t\t\t\t\t\t// Use actual subdomain from final URL, or tested subdomain as fallback\r\n\t\t\t\t\t\tconst fallbackSubdomainToUse = actualSubdomain || subdomain;\r\n\t\t\t\t\t\tif (!fallbackSubdomain) {\r\n\t\t\t\t\t\t\tfallbackSubdomain = fallbackSubdomainToUse;\r\n\t\t\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\t\t\"[SUBDOMAIN]\",\r\n\t\t\t\t\t\t\t\t`Found valid HTML for subdomain ${fallbackSubdomainToUse} (currency check inconclusive, storing as fallback)`,\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// Continue to next subdomain (optimized: don't log every error to reduce noise)\r\n\t\t\t\tconst error = e instanceof Error ? e : new Error(String(e));\r\n\t\t\t\tif (error.message && !error.message.includes(\"404\")) {\r\n\t\t\t\t\tlogger.warn(\"[SUBDOMAIN]\", `Error trying subdomain ${subdomain}:`, e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If we found a fallback subdomain (valid HTML but inconclusive currency), use it\r\n\t\tif (fallbackSubdomain) {\r\n\t\t\tlogger.info(\r\n\t\t\t\t\"[SUBDOMAIN]\",\r\n\t\t\t\t`Using fallback subdomain for memberId ${memberId}: ${fallbackSubdomain} (no currency match found)`,\r\n\t\t\t);\r\n\t\t\tsetCachedSubdomain(memberId, fallbackSubdomain, SUBDOMAIN_CACHE_TTL);\r\n\t\t\treturn fallbackSubdomain;\r\n\t\t}\r\n\r\n\t\t// If we couldn't determine by currency, try default subdomain\r\n\t\tconst testUrl = buildMovemberUrl(memberId, DEFAULT_SUBDOMAIN);\r\n\t\ttry {\r\n\t\t\tconst { html, finalUrl } = await fetchViaProxy(testUrl);\r\n\t\t\tif (html && html.length > 1000) {\r\n\t\t\t\t// Extract actual subdomain from final URL (after redirects)\r\n\t\t\t\tconst actualSubdomain =\r\n\t\t\t\t\textractSubdomainFromUrl(finalUrl) || DEFAULT_SUBDOMAIN;\r\n\t\t\t\tlogger.info(\r\n\t\t\t\t\t\"[SUBDOMAIN]\",\r\n\t\t\t\t\t`Using default subdomain for memberId ${memberId}: ${actualSubdomain}`,\r\n\t\t\t\t);\r\n\t\t\t\tsetCachedSubdomain(memberId, actualSubdomain, SUBDOMAIN_CACHE_TTL);\r\n\t\t\t\treturn actualSubdomain;\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\t// Continue to fallback\r\n\t\t\tlogger.warn(\"[SUBDOMAIN]\", \"Error trying default subdomain:\", e);\r\n\t\t}\r\n\r\n\t\t// Fallback to default\r\n\t\tlogger.warn(\r\n\t\t\t\"[SUBDOMAIN]\",\r\n\t\t\t`Could not find working subdomain for memberId ${memberId}, using default: ${DEFAULT_SUBDOMAIN}`,\r\n\t\t);\r\n\t\tsetCachedSubdomain(memberId, DEFAULT_SUBDOMAIN, SUBDOMAIN_CACHE_TTL);\r\n\t\treturn DEFAULT_SUBDOMAIN;\r\n\t} catch (error) {\r\n\t\t// Track error with structured context\r\n\t\ttrackSubdomainError(\r\n\t\t\terror instanceof Error ? error : new Error(String(error)),\r\n\t\t\t{\r\n\t\t\t\tmemberId,\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\ttimestamp: Date.now(),\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t);\r\n\r\n\t\tlogger.warn(\r\n\t\t\t\"[SUBDOMAIN]\",\r\n\t\t\t`Failed to detect subdomain for memberId ${memberId}, using default:`,\r\n\t\t\terror,\r\n\t\t);\r\n\t\tsetCachedSubdomain(memberId, DEFAULT_SUBDOMAIN, SUBDOMAIN_CACHE_TTL);\r\n\t\treturn DEFAULT_SUBDOMAIN;\r\n\t}\r\n}\r\n\r\n/**\r\n * Get subdomain for a member ID (with auto-detection)\r\n * @param memberId - The member ID\r\n * @returns The subdomain for the member\r\n */\r\nexport async function getSubdomainForMember(memberId: string): Promise<string> {\r\n\t// Check manual override first\r\n\tif (MEMBER_SUBDOMAIN_MAP[memberId]) {\r\n\t\treturn MEMBER_SUBDOMAIN_MAP[memberId];\r\n\t}\r\n\r\n\t// Auto-detect (will check cache internally)\r\n\treturn await detectSubdomainForMember(memberId);\r\n}\r\n\r\n", "/**\r\n * Main orchestration logic for scraping Movember pages\r\n * @module scraper/orchestrator\r\n */\r\n\r\nimport {\r\n\tclearSubdomainCache,\r\n\tgetCachedData,\r\n\tgetStaleCachedData,\r\n\tisCachedDataStale,\r\n\tsetCachedData,\r\n\tsetCachedSubdomain,\r\n\ttype CachedData,\r\n} from \"../cache.js\";\r\nimport {\r\n\tCACHE_TTL,\r\n\tgetCurrencySymbol,\r\n\tMAX_RETRIES,\r\n\tRETRY_DELAYS,\r\n\tSUBDOMAIN_CACHE_TTL,\r\n} from \"../constants.js\";\r\nimport { trackScrapingError } from \"../error-tracking.js\";\r\nimport { formatDuration, sleep } from \"../formatting.js\";\r\nimport logger from \"../logger.js\";\r\nimport { calculatePercentage, isValidNumber, parseAmount } from \"../parsing.js\";\r\nimport { extractAmounts } from \"./html-parsing.js\";\r\nimport {\r\n\tbuildMovemberUrl,\r\n\textractSubdomainFromUrl,\r\n\tfetchViaProxy,\r\n} from \"./network.js\";\r\nimport {\r\n\tdetectSubdomainForMember,\r\n\tdetectSubdomainFromHtml,\r\n\tgetSubdomainForMember,\r\n} from \"./subdomain.js\";\r\n\r\nexport interface ScrapedData extends CachedData {\r\n\tamount: string;\r\n\tcurrency: string;\r\n\tsubdomain: string;\r\n\ttimestamp: number;\r\n\ttarget?: string;\r\n\tpercentage?: number;\r\n}\r\n\r\nexport interface GetDataResult {\r\n\tdata: ScrapedData;\r\n\tcacheStatus: \"HIT\" | \"MISS\" | \"STALE\" | \"LIVE\";\r\n}\r\n\r\n/**\r\n * Scrape the Movember page using Worker's CORS proxy and HTML parsing\r\n * @param memberId - The member ID to scrape\r\n * @param clearSubdomainOn404 - Whether to clear subdomain cache on 404 errors\r\n * @returns The scraped data\r\n * @throws If scraping fails\r\n */\r\nexport async function scrapeMovemberPage(\r\n\tmemberId: string,\r\n\tclearSubdomainOn404 = false,\r\n): Promise<ScrapedData> {\r\n\tlet subdomain = await getSubdomainForMember(memberId);\r\n\tconst movemberUrl = buildMovemberUrl(memberId, subdomain);\r\n\tconst startTime = Date.now();\r\n\tlogger.info(\r\n\t\t\"[SCRAPE]\",\r\n\t\t`Starting scrape of Movember page: ${movemberUrl} (subdomain: ${subdomain})`,\r\n\t);\r\n\r\n\ttry {\r\n\t\t// Fetch the HTML via Worker's CORS proxy\r\n\t\tlogger.info(\"[SCRAPE]\", `Fetching HTML from ${movemberUrl} via proxy...`);\r\n\t\tconst fetchStart = Date.now();\r\n\t\tlet html: string;\r\n\t\tlet finalUrl: string;\r\n\r\n\t\ttry {\r\n\t\t\tconst result = await fetchViaProxy(movemberUrl);\r\n\t\t\thtml = result.html;\r\n\t\t\tfinalUrl = result.finalUrl;\r\n\t\t} catch (error) {\r\n\t\t\t// If we get an error, try clearing subdomain cache and re-detecting\r\n\t\t\tif (\r\n\t\t\t\tclearSubdomainOn404 &&\r\n\t\t\t\terror instanceof Error &&\r\n\t\t\t\terror.message.includes(\"404\")\r\n\t\t\t) {\r\n\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t`Got 404 for ${movemberUrl}, clearing cached subdomain and re-detecting...`,\r\n\t\t\t\t);\r\n\t\t\t\tclearSubdomainCache(memberId);\r\n\t\t\t\t// Re-detect subdomain with force refresh\r\n\t\t\t\tconst newSubdomain = await detectSubdomainForMember(memberId, true);\r\n\t\t\t\tif (newSubdomain !== subdomain) {\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Re-detected subdomain: ${newSubdomain} (was ${subdomain}), retrying with new subdomain...`,\r\n\t\t\t\t\t);\r\n\t\t\t\t\t// Retry with new subdomain\r\n\t\t\t\t\tconst newUrl = buildMovemberUrl(memberId, newSubdomain);\r\n\t\t\t\t\tconst retryResult = await fetchViaProxy(newUrl);\r\n\t\t\t\t\thtml = retryResult.html;\r\n\t\t\t\t\tfinalUrl = retryResult.finalUrl;\r\n\t\t\t\t\tsubdomain = newSubdomain;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t`HTTP error! status: 404 (page not found - member may not exist)`,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow error;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst fetchDuration = Date.now() - fetchStart;\r\n\t\tlogger.info(\r\n\t\t\t\"[SCRAPE]\",\r\n\t\t\t`HTML fetched successfully in ${formatDuration(fetchDuration)} (${html.length} characters)`,\r\n\t\t);\r\n\r\n\t\t// Check if URL redirected to a different subdomain\r\n\t\tconst actualSubdomain = extractSubdomainFromUrl(finalUrl);\r\n\t\tif (actualSubdomain && actualSubdomain !== subdomain) {\r\n\t\t\tlogger.info(\r\n\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t`URL redirected from ${subdomain} to ${actualSubdomain}, updating subdomain...`,\r\n\t\t\t);\r\n\t\t\tsubdomain = actualSubdomain;\r\n\t\t\t// Update cache with correct subdomain\r\n\t\t\tsetCachedSubdomain(memberId, subdomain, SUBDOMAIN_CACHE_TTL);\r\n\t\t}\r\n\r\n\t\t// Verify subdomain by checking HTML content for currency indicators (optional verification only)\r\n\t\tconst htmlDetectedSubdomain = detectSubdomainFromHtml(html);\r\n\t\tif (htmlDetectedSubdomain && htmlDetectedSubdomain !== subdomain) {\r\n\t\t\tlogger.warn(\r\n\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t`HTML currency indicates subdomain ${htmlDetectedSubdomain} but URL subdomain is ${subdomain}. Trusting URL subdomain (primary source).`,\r\n\t\t\t);\r\n\t\t\t// Don't override - trust the URL subdomain we're using\r\n\t\t} else if (htmlDetectedSubdomain === subdomain) {\r\n\t\t\tlogger.info(\r\n\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t`HTML currency verification confirms subdomain ${subdomain}`,\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// Extract data from HTML\r\n\t\tconst { raised, target } = extractAmounts(html, memberId, subdomain);\r\n\r\n\t\t// Final validation check - ensure raised is actually valid before using\r\n\t\tif (!raised || !isValidNumber(raised)) {\r\n\t\t\t// Debug: Try to find any dollar amounts in the HTML to help diagnose\r\n\t\t\tconst allDollarAmounts = html.match(/\\$[\\d,]+(?:\\.\\d+)?/g);\r\n\t\t\tlogger.warn(\r\n\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t`Found ${allDollarAmounts ? allDollarAmounts.length : 0} dollar amounts in HTML:`,\r\n\t\t\t\tallDollarAmounts ? allDollarAmounts.slice(0, 10) : [],\r\n\t\t\t); // Show first 10\r\n\r\n\t\t\t// Try to find any numbers that might be amounts\r\n\t\t\tconst potentialAmounts = html.match(/[\\d,]{3,}(?:\\.\\d+)?/g);\r\n\t\t\tlogger.warn(\r\n\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t`Found ${potentialAmounts ? potentialAmounts.length : 0} potential amount numbers in HTML (showing first 20):`,\r\n\t\t\t\tpotentialAmounts ? potentialAmounts.slice(0, 20) : [],\r\n\t\t\t);\r\n\r\n\t\t\tconst errorDetails = {\r\n\t\t\t\tmemberId,\r\n\t\t\t\tsubdomain,\r\n\t\t\t\turl: movemberUrl,\r\n\t\t\t\tmessage:\r\n\t\t\t\t\t\"Could not find raised amount in HTML. The page may require JavaScript execution or the HTML structure may have changed.\",\r\n\t\t\t\thtmlLength: html.length,\r\n\t\t\t\tdollarAmountsFound: allDollarAmounts ? allDollarAmounts.length : 0,\r\n\t\t\t\traisedValue: raised || \"empty\",\r\n\t\t\t};\r\n\t\t\tlogger.error(\r\n\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\"Failed to extract raised amount:\",\r\n\t\t\t\terrorDetails,\r\n\t\t\t);\r\n\t\t\tthrow new Error(\r\n\t\t\t\t`Could not find raised amount in HTML for memberId ${memberId} (subdomain: ${subdomain}). The page may require JavaScript execution or the HTML structure may have changed. Found ${allDollarAmounts ? allDollarAmounts.length : 0} dollar amounts in HTML.`,\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// Double-check that raised is valid before parsing\r\n\t\tif (!isValidNumber(raised)) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t`Invalid raised value captured: \"${raised}\" for memberId ${memberId}`,\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// Parse amount with subdomain to determine correct currency\r\n\t\tconst { value: raisedValue, currency } = parseAmount(`$${raised}`, subdomain);\r\n\r\n\t\t// Validate the parsed value is not empty or zero (unless it's actually zero)\r\n\t\tif (!raisedValue || raisedValue === \"0\" || raisedValue === \"\") {\r\n\t\t\tlogger.warn(\r\n\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t`Parsed raised value is invalid: \"${raisedValue}\" from input: \"${raised}\"`,\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// Format amount with appropriate currency symbol\r\n\t\tconst currencySymbol = getCurrencySymbol(currency);\r\n\t\tconst raisedFormatted = `${currencySymbol}${raisedValue}`;\r\n\r\n\t\tconst result: ScrapedData = {\r\n\t\t\tamount: raisedFormatted,\r\n\t\t\tcurrency,\r\n\t\t\tsubdomain, // Include subdomain in result for consolidated cache\r\n\t\t\ttimestamp: Date.now(),\r\n\t\t};\r\n\r\n\t\tif (target && isValidNumber(target)) {\r\n\t\t\tconst { value: targetValue } = parseAmount(`$${target}`, subdomain);\r\n\t\t\t// Use the same currency symbol for consistency\r\n\t\t\tconst targetFormatted = `${currencySymbol}${targetValue}`;\r\n\t\t\tresult.target = targetFormatted;\r\n\t\t\tresult.percentage = calculatePercentage(raisedValue, targetValue);\r\n\t\t} else if (target) {\r\n\t\t\tlogger.warn(\r\n\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t`Target value \"${target}\" failed validation, skipping target`,\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tconst totalDuration = Date.now() - startTime;\r\n\t\tlogger.info(\r\n\t\t\t\"[SCRAPE]\",\r\n\t\t\t`Scraping completed successfully in ${formatDuration(totalDuration)}:`,\r\n\t\t\t{\r\n\t\t\t\tamount: result.amount,\r\n\t\t\t\ttarget: result.target,\r\n\t\t\t\tpercentage: result.percentage,\r\n\t\t\t\tcurrency: result.currency,\r\n\t\t\t\tsubdomain: result.subdomain,\r\n\t\t\t},\r\n\t\t);\r\n\r\n\t\treturn result;\r\n\t} catch (error) {\r\n\t\tconst totalDuration = Date.now() - startTime;\r\n\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\r\n\r\n\t\t// Track error with structured context\r\n\t\ttrackScrapingError(error instanceof Error ? error : new Error(errorMessage), {\r\n\t\t\tmemberId,\r\n\t\t\tsubdomain,\r\n\t\t\turl: movemberUrl,\r\n\t\t\tmetadata: {\r\n\t\t\t\tduration: totalDuration,\r\n\t\t\t\ttimestamp: Date.now(),\r\n\t\t\t},\r\n\t\t});\r\n\r\n\t\tlogger.error(\r\n\t\t\t\"[SCRAPE]\",\r\n\t\t\t`Scraping failed after ${formatDuration(totalDuration)}:`,\r\n\t\t\terrorMessage,\r\n\t\t\terror,\r\n\t\t);\r\n\t\tthrow error;\r\n\t}\r\n}\r\n\r\n/**\r\n * Retry wrapper with exponential backoff\r\n * @param memberId - The member ID to scrape\r\n * @returns The scraped data\r\n * @throws If all retries fail\r\n */\r\nexport async function scrapeWithRetry(memberId: string): Promise<ScrapedData> {\r\n\tlet lastError: Error | null = null;\r\n\tconst retryStartTime = Date.now();\r\n\r\n\tlogger.info(\r\n\t\t\"[RETRY]\",\r\n\t\t`Starting retry logic (max ${MAX_RETRIES} attempts) for memberId: ${memberId}`,\r\n\t);\r\n\r\n\tfor (let attempt = 0; attempt < MAX_RETRIES; attempt++) {\r\n\t\ttry {\r\n\t\t\tlogger.info(\"[RETRY]\", `Attempt ${attempt + 1}/${MAX_RETRIES}`);\r\n\t\t\t// Enable subdomain clearing on 404 for retries (especially on first attempt)\r\n\t\t\tconst clearSubdomainOn404 =\r\n\t\t\t\tattempt === 0 || lastError?.message.includes(\"404\");\r\n\t\t\tconst result = await scrapeMovemberPage(memberId, clearSubdomainOn404);\r\n\t\t\tconst totalDuration = Date.now() - retryStartTime;\r\n\t\t\tlogger.info(\r\n\t\t\t\t\"[RETRY]\",\r\n\t\t\t\t`Success on attempt ${attempt + 1} after ${totalDuration}ms`,\r\n\t\t\t);\r\n\t\t\treturn result;\r\n\t\t} catch (error) {\r\n\t\t\tlastError = error instanceof Error ? error : new Error(String(error));\r\n\t\t\tconst errorMessage = lastError.message;\r\n\t\t\tlogger.error(\"[RETRY]\", `Attempt ${attempt + 1} failed:`, errorMessage);\r\n\r\n\t\t\t// If we got a 404, clear the subdomain cache before retrying\r\n\t\t\tif (errorMessage.includes(\"404\")) {\r\n\t\t\t\tlogger.info(\r\n\t\t\t\t\t\"[RETRY]\",\r\n\t\t\t\t\t`404 detected, clearing subdomain cache for memberId: ${memberId}`,\r\n\t\t\t\t);\r\n\t\t\t\tclearSubdomainCache(memberId);\r\n\t\t\t}\r\n\r\n\t\t\tif (attempt < MAX_RETRIES - 1) {\r\n\t\t\t\tconst delay =\r\n\t\t\t\t\tRETRY_DELAYS[attempt] || RETRY_DELAYS[RETRY_DELAYS.length - 1];\r\n\t\t\t\tlogger.info(\r\n\t\t\t\t\t\"[RETRY]\",\r\n\t\t\t\t\t`Waiting ${delay}ms before retry ${attempt + 2}...`,\r\n\t\t\t\t);\r\n\t\t\t\tawait sleep(delay);\r\n\t\t\t} else {\r\n\t\t\t\tconst totalDuration = Date.now() - retryStartTime;\r\n\t\t\t\tlogger.error(\r\n\t\t\t\t\t\"[RETRY]\",\r\n\t\t\t\t\t`All ${MAX_RETRIES} attempts failed after ${totalDuration}ms`,\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tthrow lastError || new Error(\"Failed to scrape after all retries\");\r\n}\r\n\r\n/**\r\n * Main function to get data (with stale-while-revalidate caching)\r\n * Implements stale-while-revalidate pattern: returns stale data immediately if available,\r\n * then fetches fresh data in the background and updates cache\r\n * @param memberId - The member ID to get data for\r\n * @param grabLive - Whether to force a fresh scrape (bypass cache)\r\n * @returns The data and cache status\r\n */\r\nexport async function getData(\r\n\tmemberId: string,\r\n\tgrabLive = false,\r\n): Promise<GetDataResult> {\r\n\tlet data: ScrapedData | null = null;\r\n\tlet cacheStatus: GetDataResult[\"cacheStatus\"] = \"HIT\";\r\n\r\n\tif (grabLive) {\r\n\t\t// Force fresh scrape, bypass cache\r\n\t\tlogger.info(\r\n\t\t\t\"[LIVE]\",\r\n\t\t\t`grab-live parameter detected - forcing fresh scrape for memberId: ${memberId}`,\r\n\t\t);\r\n\t\tdata = await scrapeWithRetry(memberId);\r\n\t\tcacheStatus = \"LIVE\";\r\n\r\n\t\t// Store in cache with 5-minute TTL\r\n\t\tlogger.info(\r\n\t\t\t\"[CACHE]\",\r\n\t\t\t`Storing live data in cache with TTL: ${CACHE_TTL}ms for memberId: ${memberId}`,\r\n\t\t);\r\n\t\tsetCachedData(memberId, data, CACHE_TTL);\r\n\t\tlogger.info(\"[CACHE]\", \"Live data stored successfully\");\r\n\t} else {\r\n\t\t// Check cache first (fresh data)\r\n\t\tlogger.info(\"[CACHE]\", `Checking cache for memberId: ${memberId}`);\r\n\t\tdata = getCachedData(memberId);\r\n\r\n\t\tif (data) {\r\n\t\t\tconst cacheAge = Date.now() - data.timestamp;\r\n\t\t\tlogger.info(\r\n\t\t\t\t\"[CACHE]\",\r\n\t\t\t\t`Cache HIT - data age: ${Math.round(cacheAge / 1000)}s for memberId: ${memberId}`,\r\n\t\t\t\t{\r\n\t\t\t\t\tamount: data.amount,\r\n\t\t\t\t\ttarget: data.target,\r\n\t\t\t\t\ttimestamp: new Date(data.timestamp).toISOString(),\r\n\t\t\t\t},\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\t// Check for stale data (stale-while-revalidate pattern)\r\n\t\t\tconst staleData = getStaleCachedData(memberId);\r\n\t\t\tconst isStale = isCachedDataStale(memberId);\r\n\r\n\t\t\tif (staleData && isStale) {\r\n\t\t\t\t// Return stale data immediately (stale-while-revalidate)\r\n\t\t\t\tlogger.info(\r\n\t\t\t\t\t\"[CACHE]\",\r\n\t\t\t\t\t`Cache STALE - returning stale data immediately, fetching fresh data in background for memberId: ${memberId}`,\r\n\t\t\t\t);\r\n\t\t\t\tdata = staleData;\r\n\t\t\t\tcacheStatus = \"STALE\";\r\n\r\n\t\t\t\t// Fetch fresh data in background (don't await)\r\n\t\t\t\t// This updates the cache for the next request\r\n\t\t\t\tscrapeWithRetry(memberId)\r\n\t\t\t\t\t.then((freshData) => {\r\n\t\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\t\"[CACHE]\",\r\n\t\t\t\t\t\t\t`Background refresh completed for memberId: ${memberId}, updating cache`,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tsetCachedData(memberId, freshData, CACHE_TTL);\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.catch((error) => {\r\n\t\t\t\t\t\tlogger.error(\r\n\t\t\t\t\t\t\t\"[CACHE]\",\r\n\t\t\t\t\t\t\t`Background refresh failed for memberId: ${memberId}:`,\r\n\t\t\t\t\t\t\terror,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\t// No cache at all, need to scrape\r\n\t\t\t\tlogger.info(\r\n\t\t\t\t\t\"[CACHE]\",\r\n\t\t\t\t\t`Cache MISS - need to scrape for memberId: ${memberId}`,\r\n\t\t\t\t);\r\n\t\t\t\tdata = await scrapeWithRetry(memberId);\r\n\t\t\t\tcacheStatus = \"MISS\";\r\n\r\n\t\t\t\t// Store in cache with 5-minute TTL\r\n\t\t\t\tlogger.info(\r\n\t\t\t\t\t\"[CACHE]\",\r\n\t\t\t\t\t`Storing data in cache with TTL: ${CACHE_TTL}ms for memberId: ${memberId}`,\r\n\t\t\t\t);\r\n\t\t\t\tsetCachedData(memberId, data, CACHE_TTL);\r\n\t\t\t\tlogger.info(\"[CACHE]\", \"Data stored successfully\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn { data: data!, cacheStatus };\r\n}\r\n\r\n"],
  "mappings": "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",
  "names": ["MEMBER_SUBDOMAIN_MAP", "MOVEMBER_BASE_URL_TEMPLATE", "DEFAULT_MEMBER_ID", "RETRY_DELAYS", "SUBDOMAIN_CURRENCY_MAP", "getCurrencyFromSubdomain", "subdomain", "CURRENCY_SYMBOL_MAP", "getCurrencySymbol", "currencyCode", "getProxyUrl", "formatDuration", "ms", "seconds", "minutes", "remainingSeconds", "sleep", "resolve", "LOG_LEVELS", "currentLogLevel", "initializeLogLevel", "stored", "level", "error", "formatMessage", "prefix", "args", "shouldLog", "logger", "upperLevel", "name", "value", "logger_default", "parseAmount", "text", "subdomain", "cleaned", "currency", "getCurrencyFromSubdomain", "amountMatch", "isValidNumber", "value", "calculatePercentage", "raised", "target", "raisedNum", "targetNum", "URL_PATTERNS", "CURRENCY_CODE_PATTERNS", "COUNTRY_DETECTION_PATTERNS", "DOLLAR_AMOUNT_PATTERN", "RAISED_PATTERNS", "TARGET_PATTERNS", "RAISED_JSON_PATTERNS", "TARGET_JSON_PATTERNS", "GENERIC_RAISED_PATTERNS", "GENERIC_TARGET_PATTERNS", "extractRaisedAmountWithDOMParser", "html", "doc", "selectors", "selector", "elements", "element", "amountMatch", "isValidNumber", "logger_default", "dataRaised", "scriptTags", "script", "scriptContent", "i", "RAISED_JSON_PATTERNS", "pattern", "match", "captured", "error", "extractRaisedAmount", "raised", "RAISED_PATTERNS", "scriptTagMatches", "scriptTag", "GENERIC_RAISED_PATTERNS", "allDollarMatches", "scoredAmounts", "amount", "matchIndex", "contextStart", "contextEnd", "context", "raisedScore", "a", "b", "raisedCandidates", "extractTargetAmountWithDOMParser", "dataTarget", "TARGET_JSON_PATTERNS", "extractTargetAmount", "target", "TARGET_PATTERNS", "GENERIC_TARGET_PATTERNS", "j", "targetScore", "targetCandidates", "extractAmounts", "memberId", "subdomain", "extractStart", "extractDuration", "formatDuration", "ERROR_SEVERITY", "ERROR_CATEGORY", "trackError", "error", "context", "errorInfo", "logger_default", "storedErrors", "e", "trackScrapingError", "trackSubdomainError", "trackNetworkError", "extractSubdomainFromUrl", "url", "match", "URL_PATTERNS", "fetchViaProxy", "proxyUrl", "getProxyUrl", "response", "errorMessage", "errorData", "errorText", "e", "logger_default", "error", "trackNetworkError", "html", "finalUrl", "buildMovemberUrl", "memberId", "subdomain", "MOVEMBER_BASE_URL_TEMPLATE", "getCachedData", "memberId", "cacheKey", "cached", "entry", "error", "logger_default", "getStaleCachedData", "isCachedDataStale", "setCachedData", "data", "ttl", "cacheValue", "getCachedSubdomain", "setCachedSubdomain", "subdomain", "clearSubdomainCache", "subdomainKey", "oldAmountKey", "detectSubdomainFromHtml", "html", "COUNTRY_DETECTION_PATTERNS", "CURRENCY_CODE_PATTERNS", "DOLLAR_AMOUNT_PATTERN", "detectSubdomainForMember", "memberId", "forceRefresh", "logger_default", "cached", "getCachedSubdomain", "MEMBER_SUBDOMAIN_MAP", "subdomain", "setCachedSubdomain", "commonSubdomains", "fallbackSubdomain", "testSubdomainUrl", "buildMovemberUrl", "testHtml", "finalUrl", "fetchViaProxy", "actualSubdomain", "extractSubdomainFromUrl", "detectedSubdomain", "confirmedSubdomain", "fallbackSubdomainToUse", "e", "error", "testUrl", "trackSubdomainError", "getSubdomainForMember", "scrapeMovemberPage", "memberId", "clearSubdomainOn404", "subdomain", "getSubdomainForMember", "movemberUrl", "buildMovemberUrl", "startTime", "logger_default", "fetchStart", "html", "finalUrl", "result", "fetchViaProxy", "error", "clearSubdomainCache", "newSubdomain", "detectSubdomainForMember", "newUrl", "retryResult", "fetchDuration", "formatDuration", "actualSubdomain", "extractSubdomainFromUrl", "setCachedSubdomain", "htmlDetectedSubdomain", "detectSubdomainFromHtml", "raised", "target", "extractAmounts", "isValidNumber", "allDollarAmounts", "potentialAmounts", "errorDetails", "raisedValue", "currency", "parseAmount", "currencySymbol", "getCurrencySymbol", "targetValue", "targetFormatted", "calculatePercentage", "totalDuration", "errorMessage", "trackScrapingError", "scrapeWithRetry", "lastError", "retryStartTime", "attempt", "delay", "RETRY_DELAYS", "sleep", "getData", "grabLive", "data", "cacheStatus", "setCachedData", "getCachedData", "cacheAge", "staleData", "getStaleCachedData", "isStale", "isCachedDataStale", "freshData"]
}
