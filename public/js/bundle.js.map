{
  "version": 3,
  "sources": ["../../src/client/constants.ts", "../../src/client/formatting.ts", "../../src/client/logger.ts", "../../src/client/parsing.ts", "../../src/client/regex-patterns.ts", "../../src/client/scraper/html-parsing.ts", "../../src/client/error-tracking.ts", "../../src/client/scraper/network.ts", "../../src/client/cache.ts", "../../src/client/scraper/subdomain.ts", "../../src/client/scraper/orchestrator.ts"],
  "sourcesContent": ["// Mapping of member IDs to their subdomains (manual overrides)\n// Format: \"memberId\": \"subdomain\"\n// Example: \"15023456\": \"fr\" means member 15023456 uses fr.movember.com\n// Note: Subdomains are now auto-detected from redirects, but you can override here if needed\nexport const MEMBER_SUBDOMAIN_MAP: Record<string, string> = {\n\t// Add manual overrides here if needed\n\t// Example: \"15023456\": \"fr\",\n\t// Example: \"14810348\": \"au\",\n};\n\nexport const DEFAULT_SUBDOMAIN = \"au\"; // Default subdomain to try first\nexport const MOVEMBER_BASE_URL_TEMPLATE =\n\t\"https://{subdomain}.movember.com/donate/details\";\nexport const MOVEMBER_TEAM_URL_TEMPLATE =\n\t\"https://{subdomain}.movember.com/team/{id}\";\nexport const DEFAULT_MEMBER_ID = \"14810348\"; // Default member ID if none provided\nexport const CACHE_TTL = 300000; // 5 minutes in milliseconds\nexport const SUBDOMAIN_CACHE_TTL = 86400000; // 24 hours in milliseconds (subdomain mappings don't change often)\nexport const MAX_RETRIES = 3;\nexport const RETRY_DELAYS = [1000, 2000, 4000]; // Exponential backoff in milliseconds\n\n// Mapping of subdomain codes to currency codes\n// Format: \"subdomain\": \"CURRENCY_CODE\"\nexport const SUBDOMAIN_CURRENCY_MAP: Record<string, string> = {\n\tuk: \"GBP\", // United Kingdom - British Pound\n\tau: \"AUD\", // Australia - Australian Dollar\n\tus: \"USD\", // United States - US Dollar\n\tca: \"CAD\", // Canada - Canadian Dollar\n\tnz: \"NZD\", // New Zealand - New Zealand Dollar\n\tie: \"EUR\", // Ireland - Euro\n\tza: \"ZAR\", // South Africa - South African Rand\n\tnl: \"EUR\", // Netherlands - Euro\n\tde: \"EUR\", // Germany - Euro\n\tfr: \"EUR\", // France - Euro\n\tes: \"EUR\", // Spain - Euro\n\tit: \"EUR\", // Italy - Euro\n\tex: \"EUR\", // Unknown/Experimental - Euro (default)\n\tcz: \"CZK\", // Czech Republic - Czech Koruna\n\tdk: \"DKK\", // Denmark - Danish Krone\n\tse: \"SEK\", // Sweden - Swedish Krona\n};\n\n/**\n * Get currency code from subdomain\n * @param subdomain - The subdomain code (e.g., \"uk\", \"au\", \"us\")\n * @returns The currency code (e.g., \"GBP\", \"AUD\", \"USD\"), defaults to \"AUD\" if not found\n * @example\n * getCurrencyFromSubdomain(\"uk\") // \"GBP\"\n * getCurrencyFromSubdomain(\"au\") // \"AUD\"\n * getCurrencyFromSubdomain(\"us\") // \"USD\"\n */\nexport function getCurrencyFromSubdomain(\n\tsubdomain: string | null | undefined,\n): string {\n\tif (!subdomain) {\n\t\treturn \"AUD\"; // Default currency\n\t}\n\treturn SUBDOMAIN_CURRENCY_MAP[subdomain.toLowerCase()] || \"AUD\";\n}\n\n// Mapping of currency codes to currency symbols\nconst CURRENCY_SYMBOL_MAP: Record<string, string> = {\n\tUSD: \"$\", // US Dollar\n\tAUD: \"$\", // Australian Dollar\n\tCAD: \"$\", // Canadian Dollar\n\tNZD: \"$\", // New Zealand Dollar\n\tGBP: \"\u00A3\", // British Pound\n\tEUR: \"\u20AC\", // Euro\n\tJPY: \"\u00A5\", // Japanese Yen\n\tZAR: \"R\", // South African Rand\n\tCZK: \"K\u010D\", // Czech Koruna\n\tDKK: \"kr\", // Danish Krone\n\tSEK: \"kr\", // Swedish Krona\n};\n\n/**\n * Get currency symbol from currency code\n * @param currencyCode - The currency code (e.g., \"USD\", \"GBP\", \"EUR\")\n * @returns The currency symbol (e.g., \"$\", \"\u00A3\", \"\u20AC\"), defaults to \"$\" if not found\n * @example\n * getCurrencySymbol(\"USD\") // \"$\"\n * getCurrencySymbol(\"GBP\") // \"\u00A3\"\n * getCurrencySymbol(\"EUR\") // \"\u20AC\"\n */\nexport function getCurrencySymbol(\n\tcurrencyCode: string | null | undefined,\n): string {\n\tif (!currencyCode) {\n\t\treturn \"$\"; // Default symbol\n\t}\n\treturn CURRENCY_SYMBOL_MAP[currencyCode.toUpperCase()] || \"$\";\n}\n\n/**\n * Get the Worker's proxy URL\n * Uses the current origin (the Worker's domain) for the proxy endpoint\n * @returns The proxy URL (e.g., \"https://example.com/proxy\")\n * @example\n * getProxyUrl() // \"https://movember-tracker.example.com/proxy\"\n */\nexport function getProxyUrl(): string {\n\t// Use the current origin (the Worker's domain) for the proxy\n\treturn `${window.location.origin}/proxy`;\n}\n", "/**\n * Format duration in human-readable format\n * @param ms - Duration in milliseconds\n * @returns Formatted duration string (e.g., \"2m 30s (150000ms)\" or \"45s (45000ms)\")\n * @example\n * formatDuration(150000) // \"2m 30s (150000ms)\"\n * formatDuration(45000) // \"45s (45000ms)\"\n */\nexport const formatDuration = (ms: number): string => {\n\tconst seconds = Math.round(ms / 1000);\n\tconst minutes = Math.floor(seconds / 60);\n\tconst remainingSeconds = seconds % 60;\n\n\tif (minutes > 0) {\n\t\treturn `${minutes}m ${remainingSeconds}s (${ms}ms)`;\n\t}\n\treturn `${seconds}s (${ms}ms)`;\n};\n\n/**\n * Sleep for a specified duration (useful for delays/retries)\n * @param ms - Duration to sleep in milliseconds\n * @returns Promise that resolves after the specified duration\n * @example\n * await sleep(1000); // Sleep for 1 second\n */\nexport const sleep = (ms: number): Promise<void> =>\n\tnew Promise((resolve) => setTimeout(resolve, ms));\n", "/**\n * Structured logger for client-side code\n * Supports log levels: DEBUG, INFO, WARN, ERROR\n * Can be disabled in production by setting LOG_LEVEL to 'NONE'\n */\n\n// Log levels (higher number = more important)\nconst LOG_LEVELS = {\n\tDEBUG: 0,\n\tINFO: 1,\n\tWARN: 2,\n\tERROR: 3,\n\tNONE: 4,\n} as const;\n\ntype LogLevel = keyof typeof LOG_LEVELS;\n\n// Default log level (can be overridden via localStorage or environment)\nlet currentLogLevel: number = LOG_LEVELS.INFO;\n\n// Initialize log level from localStorage or default\nfunction initializeLogLevel(): void {\n\ttry {\n\t\tconst stored = localStorage.getItem(\"LOG_LEVEL\");\n\t\tif (stored) {\n\t\t\tconst level = stored.toUpperCase() as LogLevel;\n\t\t\tif (level in LOG_LEVELS) {\n\t\t\t\tcurrentLogLevel = LOG_LEVELS[level];\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t// localStorage unavailable (e.g., in private browsing mode)\n\t\t// Log to console as fallback since logger isn't initialized yet\n\t\tif (typeof console !== \"undefined\" && console.warn) {\n\t\t\tconsole.warn(\n\t\t\t\t\"[LOGGER] localStorage unavailable, using default log level:\",\n\t\t\t\terror instanceof Error ? error.message : String(error),\n\t\t\t);\n\t\t}\n\t}\n\n\t// Default to INFO in production, DEBUG in development\n\t// You can detect development mode via URL or other means\n\tconst isDevelopment =\n\t\twindow.location.hostname === \"localhost\" ||\n\t\twindow.location.hostname === \"127.0.0.1\" ||\n\t\twindow.location.search.includes(\"debug=true\");\n\n\tcurrentLogLevel = isDevelopment ? LOG_LEVELS.DEBUG : LOG_LEVELS.INFO;\n}\n\n// Initialize on load\ninitializeLogLevel();\n\n/**\n * Format log message with prefix\n */\nfunction formatMessage(\n\tlevel: string,\n\tprefix: string,\n\t...args: unknown[]\n): unknown[] {\n\tconst timestamp = new Date().toISOString();\n\treturn [`[${timestamp}] [${level}] ${prefix}`, ...args];\n}\n\n/**\n * Check if log level should be output\n */\nfunction shouldLog(level: LogLevel): boolean {\n\treturn LOG_LEVELS[level] >= currentLogLevel;\n}\n\n/**\n * Logger object with methods for each log level\n */\nexport const logger = {\n\t/**\n\t * Set the log level\n\t * @param level - One of: 'DEBUG', 'INFO', 'WARN', 'ERROR', 'NONE'\n\t */\n\tsetLevel(level: string): void {\n\t\tconst upperLevel = level.toUpperCase() as LogLevel;\n\t\tif (upperLevel in LOG_LEVELS) {\n\t\t\tcurrentLogLevel = LOG_LEVELS[upperLevel];\n\t\t\ttry {\n\t\t\t\tlocalStorage.setItem(\"LOG_LEVEL\", upperLevel);\n\t\t\t} catch (error) {\n\t\t\t\t// localStorage unavailable - log using logger itself\n\t\t\t\t// Use console as fallback if logger fails\n\t\t\t\ttry {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\"[LOGGER]\",\n\t\t\t\t\t\t\"Failed to persist log level to localStorage:\",\n\t\t\t\t\t\terror instanceof Error ? error.message : String(error),\n\t\t\t\t\t);\n\t\t\t\t} catch {\n\t\t\t\t\t// If logger also fails, use console directly\n\t\t\t\t\tif (typeof console !== \"undefined\" && console.warn) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t\"[LOGGER] Failed to persist log level:\",\n\t\t\t\t\t\t\terror instanceof Error ? error.message : String(error),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Get the current log level\n\t * @returns Current log level name\n\t */\n\tgetLevel(): string {\n\t\tfor (const [name, value] of Object.entries(LOG_LEVELS)) {\n\t\t\tif (value === currentLogLevel) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\t\treturn \"INFO\";\n\t},\n\n\t/**\n\t * Debug level logging (most verbose)\n\t */\n\tdebug(prefix: string, ...args: unknown[]): void {\n\t\tif (shouldLog(\"DEBUG\")) {\n\t\t\tconsole.debug(...formatMessage(\"DEBUG\", prefix, ...args));\n\t\t}\n\t},\n\n\t/**\n\t * Info level logging (default)\n\t */\n\tinfo(prefix: string, ...args: unknown[]): void {\n\t\tif (shouldLog(\"INFO\")) {\n\t\t\tconsole.log(...formatMessage(\"INFO\", prefix, ...args));\n\t\t}\n\t},\n\n\t/**\n\t * Warning level logging\n\t */\n\twarn(prefix: string, ...args: unknown[]): void {\n\t\tif (shouldLog(\"WARN\")) {\n\t\t\tconsole.warn(...formatMessage(\"WARN\", prefix, ...args));\n\t\t}\n\t},\n\n\t/**\n\t * Error level logging\n\t */\n\terror(prefix: string, ...args: unknown[]): void {\n\t\tif (shouldLog(\"ERROR\")) {\n\t\t\tconsole.error(...formatMessage(\"ERROR\", prefix, ...args));\n\t\t}\n\t},\n};\n\n// Export default logger\nexport default logger;\n", "import { getCurrencyFromSubdomain } from \"./constants.js\";\n\nexport interface ParsedAmount {\n\tvalue: string;\n\tcurrency: string;\n}\n\n/**\n * Extract amount from text and determine currency from subdomain\n * Currency is ALWAYS determined from subdomain, never from HTML/text parsing\n * @param text - The text containing the amount (may include currency symbols)\n * @param subdomain - Required subdomain (e.g., \"uk\", \"au\", \"us\") to determine currency\n * @returns Object containing the extracted amount value and currency code\n * @example\n * parseAmount(\"$1,234.56\", \"us\") // { value: \"1,234.56\", currency: \"USD\" }\n * parseAmount(\"\u00A3500\", \"uk\") // { value: \"500\", currency: \"GBP\" }\n */\nexport const parseAmount = (\n\ttext: string,\n\tsubdomain: string | null | undefined,\n): ParsedAmount => {\n\t// Remove whitespace and extract amount\n\tconst cleaned = text.trim();\n\n\t// Always use subdomain to determine currency - this is the source of truth\n\t// If subdomain is not provided, default to AUD\n\tconst currency = subdomain ? getCurrencyFromSubdomain(subdomain) : \"AUD\";\n\n\t// Extract amount (supports numbers with commas and optional decimals)\n\t// Remove currency symbols and codes before extracting number\n\tconst cleanedForAmount = cleaned\n\t\t.replace(/[$\u20AC\u00A3\u00A5]|\\b(USD|EUR|GBP|AUD|JPY|CAD|NZD|ZAR)\\b/gi, \"\")\n\t\t.trim();\n\tconst amountMatch = cleanedForAmount.match(/[\\d,]+\\.?\\d*/);\n\tconst amount = amountMatch ? amountMatch[0] : \"0\";\n\n\treturn { value: amount, currency };\n};\n\n/**\n * Validate that a captured value is a valid number\n * Checks for digits, removes currency symbols, and ensures the value is not just symbols\n * @param value - The value to validate\n * @returns True if the value is a valid number, false otherwise\n * @example\n * isValidNumber(\"1,234.56\") // true\n * isValidNumber(\"$500\") // true\n * isValidNumber(\"abc\") // false\n * isValidNumber(\"$\") // false\n */\nexport const isValidNumber = (value: string | null | undefined): boolean => {\n\tif (!value || typeof value !== \"string\") {\n\t\treturn false;\n\t}\n\t// Remove commas, spaces, and currency symbols, then check if we have at least one digit\n\tconst cleaned = value.replace(/[,.\\s$\u20AC\u00A3\u00A5]/g, \"\");\n\t// Must have at least one digit and be a valid number\n\tif (!cleaned || cleaned.length === 0 || !/^\\d+$/.test(cleaned)) {\n\t\treturn false;\n\t}\n\t// Additional check: the original value should contain at least one digit\n\tif (!/\\d/.test(value)) {\n\t\treturn false;\n\t}\n\t// Reject if value is just commas, spaces, or currency symbols\n\tif (/^[,.\\s$\u20AC\u00A3\u00A5]+$/.test(value)) {\n\t\treturn false;\n\t}\n\treturn true;\n};\n\n/**\n * Calculate percentage of raised amount relative to target\n * @param raised - The raised amount (may include commas)\n * @param target - The target amount (may include commas)\n * @returns The percentage (0-100), or 0 if target is 0\n * @example\n * calculatePercentage(\"2,500\", \"10,000\") // 25\n * calculatePercentage(\"500\", \"1,000\") // 50\n */\nexport const calculatePercentage = (raised: string, target: string): number => {\n\tconst raisedNum = parseFloat(raised.replace(/,/g, \"\"));\n\tconst targetNum = parseFloat(target.replace(/,/g, \"\"));\n\tif (targetNum === 0) return 0;\n\treturn Math.round((raisedNum / targetNum) * 100);\n};\n", "/**\n * Centralized regex patterns for Movember page scraping\n * All patterns are pre-compiled for better performance\n */\n\n// URL extraction patterns\nexport const URL_PATTERNS = {\n\t/**\n\t * Extract subdomain from Movember URL\n\t * Matches: https://uk.movember.com -> \"uk\"\n\t */\n\tSUBDOMAIN: /https?:\\/\\/([^.]+)\\.movember\\.com/,\n};\n\n// Currency code patterns for subdomain detection\nexport const CURRENCY_CODE_PATTERNS: RegExp[] = [\n\t/\\bGBP\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bGBP\\b|British\\s+Pound/i,\n\t/\\bEUR\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bEUR\\b|Euro[\\s:]*[\\d,]+/i,\n\t/\\bUSD\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bUSD\\b|US\\s+Dollar/i,\n\t/\\bAUD\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bAUD\\b|Australian\\s+Dollar/i,\n\t/\\bCAD\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bCAD\\b|Canadian\\s+Dollar/i,\n\t/\\bNZD\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bNZD\\b|New\\s+Zealand\\s+Dollar/i,\n\t/\\bZAR\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bZAR\\b|South\\s+African\\s+Rand/i,\n\t/\\bCZK\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bCZK\\b|Czech\\s+Koruna|K\u010D[\\d,]+/i,\n\t/\\bSEK\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bSEK\\b|Swedish\\s+Krona/i,\n\t/\\bDKK\\b[\\s:]*[\\d,]+|[\\d,]+[\\s:]*\\bDKK\\b|Danish\\s+Krone/i,\n];\n\n// Country detection patterns\nexport const COUNTRY_DETECTION_PATTERNS: Record<string, RegExp> = {\n\tIRELAND: /Ireland|Irish/i,\n\tNETHERLANDS: /Netherlands|Dutch/i,\n\tGERMANY: /Germany|German/i,\n\tFRANCE: /France|French/i,\n\tSPAIN: /Spain|Spanish/i,\n\tITALY: /Italy|Italian/i,\n\tUNITED_STATES: /United\\s+States|US\\s+Dollar/i,\n\tCANADA: /Canada|Canadian/i,\n\tNEW_ZEALAND: /New\\s+Zealand/i,\n\tAUSTRALIA: /Australia|Australian/i,\n};\n\n// Dollar amount pattern (ambiguous, used as fallback)\nexport const DOLLAR_AMOUNT_PATTERN = /\\$[\\d,]+/;\n\n// Raised amount extraction patterns (optimized with combined patterns)\n// Patterns are grouped by similarity and combined using alternation for better performance\nexport const RAISED_PATTERNS: RegExp[] = [\n\t// Group 1: AmountRaised object patterns (most reliable) - combined\n\t/\"AmountRaised\"[^}]*\"(?:convertedAmount|originalAmount)\"[\"\\s:]*[\"']([\\d,]+(?:\\.\\d+)?)/i,\n\t// Group 2: CSS class patterns with dollar sign - combined\n\t/donationProgress--amount__raised[^>]*>([^<]*\\$([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\n\t// Group 3: CSS class with class attribute - separate (different structure)\n\t/class=\"[^\"]*donationProgress--amount__raised[^\"]*\"[^>]*>[\\s\\S]*?\\$([\\d,]+(?:\\.\\d+)?)/i,\n\t// Group 4: JSON property patterns - combined\n\t/\"(?:raised|raisedAmount|currentAmount)\"[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Group 5: Data attribute patterns - combined\n\t/data-(?:raised|amount)=[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Group 6: CSS class with currency symbols - separate (different capture groups)\n\t/donationProgress--amount__raised[^>]*>([^<]*[\u20AC\u00A3$]([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\n\t// Group 7: CSS class with currency codes - separate (different capture groups)\n\t/donationProgress--amount__raised[^>]*>([^<]*(?:USD|EUR|GBP|AUD)\\s*([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\n];\n\n// Target amount extraction patterns (optimized with combined patterns)\n// Patterns are grouped by similarity and combined using alternation for better performance\nexport const TARGET_PATTERNS: RegExp[] = [\n\t// Group 1: target.fundraising.value (most reliable) - separate (most specific)\n\t/\"target\"[^}]*\"fundraising\"[^}]*\"value\"[\"\\s:]*[\"']([\\d,]+(?:\\.\\d+)?)/i,\n\t// Group 2: CSS class patterns with dollar sign - combined\n\t/donationProgress--amount__target[^>]*>([^<]*\\$([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\n\t// Group 3: CSS class with class attribute - separate (different structure)\n\t/class=\"[^\"]*donationProgress--amount__target[^\"]*\"[^>]*>[\\s\\S]*?\\$([\\d,]+(?:\\.\\d+)?)/i,\n\t// Group 4: JSON property patterns - combined\n\t/\"(?:target|targetAmount|goal)\"[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Group 5: Data attribute patterns - combined\n\t/data-(?:target|goal)=[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Group 6: CSS class with currency symbols - separate (different capture groups)\n\t/donationProgress--amount__target[^>]*>([^<]*[\u20AC\u00A3$]([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\n\t// Group 7: CSS class with currency codes - separate (different capture groups)\n\t/donationProgress--amount__target[^>]*>([^<]*(?:USD|EUR|GBP|AUD)\\s*([\\d,]+(?:\\.\\d+)?)[^<]*)/i,\n];\n\n// JSON script tag patterns for raised amounts (optimized with combined patterns)\nexport const RAISED_JSON_PATTERNS: RegExp[] = [\n\t// Pattern 1: AmountRaised object with originalAmount or convertedAmount (most reliable)\n\t/\"AmountRaised\"[^}]*\"(?:convertedAmount|originalAmount)\"[\"\\s:]*[\"']([\\d,]+(?:\\.\\d+)?)/i,\n\t// Pattern 2: Combined JSON property patterns\n\t/\"(?:raised|raisedAmount|currentAmount|donationAmount|amount)\"[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Pattern 3: Unquoted property pattern (separate due to different structure)\n\t/raised[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n];\n\n// JSON script tag patterns for target amounts (optimized with combined patterns)\nexport const TARGET_JSON_PATTERNS: RegExp[] = [\n\t// Pattern 1: target.fundraising.value (most reliable)\n\t/\"target\"[^}]*\"fundraising\"[^}]*\"value\"[\"\\s:]*[\"']([\\d,]+(?:\\.\\d+)?)/i,\n\t// Pattern 2: Combined JSON property patterns\n\t/\"(?:target|targetAmount|goal)\"[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Pattern 3: Unquoted property patterns - combined\n\t/(?:target|goal)[:\\s]*[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n];\n\n// Generic fallback patterns for raised amounts\nexport const GENERIC_RAISED_PATTERNS: RegExp[] = [\n\t// Look for $X,XXX pattern in common HTML structures\n\t/\\$([\\d,]+(?:\\.\\d+)?)\\s*(?:raised|donated|collected)/i,\n\t/(?:raised|donated|collected)[:\\s]*\\$([\\d,]+(?:\\.\\d+)?)/i,\n\t// Look for amounts in div/span elements\n\t/<[^>]+class=\"[^\"]*(?:amount|raised|donation|progress)[^\"]*\"[^>]*>\\s*\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Look for amounts in data attributes\n\t/data-[^=]*amount[^=]*=[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Look for amounts near \"of\" or \"out of\" (progress indicators)\n\t/\\$([\\d,]+(?:\\.\\d+)?)\\s*(?:of|out of)/i,\n\t// Look for amounts in JSON-like structures without quotes\n\t/raised[:\\s=]+[$]?([\\d,]+(?:\\.\\d+)?)/i,\n\t/amount[:\\s=]+[$]?([\\d,]+(?:\\.\\d+)?)/i,\n];\n\n// Generic fallback patterns for target amounts\nexport const GENERIC_TARGET_PATTERNS: RegExp[] = [\n\t// Look for $X,XXX pattern with target/goal keywords\n\t/\\$([\\d,]+(?:\\.\\d+)?)\\s*(?:target|goal)/i,\n\t/(?:target|goal)[:\\s]*\\$([\\d,]+(?:\\.\\d+)?)/i,\n\t// Look for amounts in div/span elements with target/goal classes\n\t/<[^>]+class=\"[^\"]*(?:target|goal)[^\"]*\"[^>]*>\\s*\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Look for amounts in data attributes\n\t/data-[^=]*(?:target|goal)[^=]*=[\"']?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n\t// Look for amounts near \"of\" or \"out of\" with target/goal context\n\t/\\$([\\d,]+(?:\\.\\d+)?)\\s*(?:of|out of)\\s*\\$([\\d,]+(?:\\.\\d+)?)/i,\n\t// Look for amounts in JSON-like structures without quotes\n\t/target[:\\s=]+[$]?([\\d,]+(?:\\.\\d+)?)/i,\n\t/goal[:\\s=]+[$]?([\\d,]+(?:\\.\\d+)?)/i,\n];\n", "/**\r\n * HTML parsing logic for extracting donation amounts from Movember pages\r\n * @module scraper/html-parsing\r\n */\r\n\r\nimport { formatDuration } from \"../formatting.js\";\r\nimport { logger } from \"../logger.js\";\r\nimport { isValidNumber } from \"../parsing.js\";\r\nimport {\r\n\tGENERIC_RAISED_PATTERNS,\r\n\tGENERIC_TARGET_PATTERNS,\r\n\tRAISED_JSON_PATTERNS,\r\n\tRAISED_PATTERNS,\r\n\tTARGET_JSON_PATTERNS,\r\n\tTARGET_PATTERNS,\r\n} from \"../regex-patterns.js\";\r\n\r\nexport interface ExtractedAmounts {\r\n\traised: string;\r\n\ttarget: string;\r\n}\r\n\r\n/**\r\n * Extract raised amount from HTML using DOMParser (primary method)\r\n * Falls back to regex if DOMParser fails or doesn't find results\r\n * @param html - The HTML content to parse\r\n * @returns The extracted raised amount or empty string if not found\r\n */\r\nfunction extractRaisedAmountWithDOMParser(html: string): string {\r\n\ttry {\r\n\t\tconst parser = new DOMParser();\r\n\t\tconst doc = parser.parseFromString(html, \"text/html\");\r\n\r\n\t\t// Try to find elements with donation-related classes\r\n\t\t// Prioritize team page selectors first, then member page selectors\r\n\t\tconst selectors = [\r\n\t\t\t// Team page selectors\r\n\t\t\t\"div.mospace-heroarea--donations-target-amount-wrapper > h1\",\r\n\t\t\t\"div.mospace-heroarea--donations-target-amount-wrapper h1\",\r\n\t\t\t// Member page selectors\r\n\t\t\t\"span.donationProgress--amount__raised\",\r\n\t\t\t\"span[class*='donationProgress--amount__raised']\",\r\n\t\t\t\".donationProgress--amount__raised\",\r\n\t\t\t'[class*=\"donationProgress--amount__raised\"]',\r\n\t\t\t'[class*=\"raised\"]',\r\n\t\t\t\"[data-raised]\",\r\n\t\t\t\"[data-amount]\",\r\n\t\t\t\"[data-raised-amount]\",\r\n\t\t];\r\n\r\n\t\tfor (const selector of selectors) {\r\n\t\t\tconst elements = doc.querySelectorAll(selector);\r\n\t\t\tfor (const element of Array.from(elements)) {\r\n\t\t\t\tconst text =\r\n\t\t\t\t\telement.textContent || (element as HTMLElement).innerText || \"\";\r\n\t\t\t\t// Try to extract amount from text\r\n\t\t\t\tconst amountMatch = text.match(/[\\d,]+(?:\\.\\d+)?/);\r\n\t\t\t\tif (amountMatch && isValidNumber(amountMatch[0])) {\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Found raised amount using DOMParser with selector \"${selector}\": ${amountMatch[0]}`,\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn amountMatch[0];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Try data attributes\r\n\t\t\t\tconst dataRaised =\r\n\t\t\t\t\telement.getAttribute(\"data-raised\") ||\r\n\t\t\t\t\telement.getAttribute(\"data-amount\") ||\r\n\t\t\t\t\telement.getAttribute(\"data-raised-amount\");\r\n\t\t\t\tif (dataRaised && isValidNumber(dataRaised)) {\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Found raised amount using DOMParser data attribute: ${dataRaised}`,\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn dataRaised;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Try to find JSON data in script tags using DOMParser\r\n\t\tconst scriptTags = doc.querySelectorAll(\"script\");\r\n\t\tfor (const script of Array.from(scriptTags)) {\r\n\t\t\tconst scriptContent = script.textContent || script.innerHTML || \"\";\r\n\t\t\tfor (let i = 0; i < RAISED_JSON_PATTERNS.length; i++) {\r\n\t\t\t\tconst pattern = RAISED_JSON_PATTERNS[i];\r\n\t\t\t\tconst match = scriptContent.match(pattern);\r\n\t\t\t\tif (match) {\r\n\t\t\t\t\tconst captured = match[1];\r\n\t\t\t\t\tif (isValidNumber(captured)) {\r\n\t\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t\t`Found raised amount in JSON using DOMParser: ${captured}`,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\treturn captured;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} catch (error) {\r\n\t\tlogger.warn(\r\n\t\t\t\"[SCRAPE]\",\r\n\t\t\t\"DOMParser extraction failed, falling back to regex:\",\r\n\t\t\terror,\r\n\t\t);\r\n\t}\r\n\r\n\treturn \"\";\r\n}\r\n\r\n/**\r\n * Extract raised amount from HTML using multiple pattern strategies\r\n * Tries DOMParser first, then falls back to regex patterns\r\n * @param html - The HTML content to parse\r\n * @returns The extracted raised amount or empty string if not found\r\n */\r\nexport function extractRaisedAmount(html: string): string {\r\n\t// Try DOMParser first (more reliable for structured HTML)\r\n\tlet raised = extractRaisedAmountWithDOMParser(html);\r\n\tif (raised) {\r\n\t\treturn raised;\r\n\t}\r\n\r\n\tlogger.info(\r\n\t\t\"[SCRAPE]\",\r\n\t\t\"DOMParser didn't find raised amount, trying regex patterns...\",\r\n\t);\r\n\traised = \"\";\r\n\r\n\t// Look for the raised amount in the HTML\r\n\t// Try multiple patterns to find the data\r\n\tfor (let i = 0; i < RAISED_PATTERNS.length; i++) {\r\n\t\tconst pattern = RAISED_PATTERNS[i];\r\n\t\tconst match = html.match(pattern);\r\n\t\tif (match) {\r\n\t\t\t// Get the last capture group (the amount), but also check all groups\r\n\t\t\tlet captured = match[match.length - 1];\r\n\r\n\t\t\t// If the last group is empty or invalid, try the second-to-last\r\n\t\t\tif (!captured || !isValidNumber(captured)) {\r\n\t\t\t\tif (match.length > 2) {\r\n\t\t\t\t\tcaptured = match[match.length - 2];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlogger.debug(\r\n\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t`Pattern ${i + 1} matched, all groups:`,\r\n\t\t\t\tmatch.slice(1),\r\n\t\t\t\t`using: \"${captured}\"`,\r\n\t\t\t);\r\n\r\n\t\t\t// Validate that we captured a valid number\r\n\t\t\tif (isValidNumber(captured)) {\r\n\t\t\t\traised = captured;\r\n\t\t\t\tlogger.info(\r\n\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t`Found valid raised amount using pattern ${i + 1}: ${raised}`,\r\n\t\t\t\t);\r\n\t\t\t\tbreak;\r\n\t\t\t} else {\r\n\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t`Pattern ${i + 1} matched but invalid number: \"${captured}\", trying next pattern...`,\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Fallback: Look for JSON data in script tags\r\n\tif (!raised) {\r\n\t\tlogger.info(\"[SCRAPE]\", \"Checking for JSON data in script tags...\");\r\n\t\tconst scriptTagMatches = html.match(/<script[^>]*>([\\s\\S]*?)<\\/script>/gi);\r\n\t\tif (scriptTagMatches) {\r\n\t\t\tfor (const scriptTag of scriptTagMatches) {\r\n\t\t\t\t// Look for JSON data containing donation amounts with improved patterns\r\n\t\t\t\t// Try to find raised amount in JSON\r\n\t\t\t\tfor (let i = 0; i < RAISED_JSON_PATTERNS.length; i++) {\r\n\t\t\t\t\tconst pattern = RAISED_JSON_PATTERNS[i];\r\n\t\t\t\t\tconst match = scriptTag.match(pattern);\r\n\t\t\t\t\tif (match) {\r\n\t\t\t\t\t\tconst captured = match[1];\r\n\t\t\t\t\t\tif (isValidNumber(captured)) {\r\n\t\t\t\t\t\t\traised = captured;\r\n\t\t\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t\t\t`Found valid raised amount in JSON using pattern ${i + 1}: ${raised}`,\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t\t\t`JSON raised pattern ${i + 1} matched but invalid number: \"${captured}\"`,\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (raised) break;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Last resort: Look for any dollar amounts in the HTML (more generic patterns)\r\n\tif (!raised) {\r\n\t\tlogger.info(\r\n\t\t\t\"[SCRAPE]\",\r\n\t\t\t\"Trying generic dollar amount patterns as last resort...\",\r\n\t\t);\r\n\t\tfor (let i = 0; i < GENERIC_RAISED_PATTERNS.length; i++) {\r\n\t\t\tconst pattern = GENERIC_RAISED_PATTERNS[i];\r\n\t\t\tconst match = html.match(pattern);\r\n\t\t\tif (match) {\r\n\t\t\t\tconst captured = match[1];\r\n\t\t\t\tif (isValidNumber(captured)) {\r\n\t\t\t\t\traised = captured;\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Found valid raised amount using generic pattern ${i + 1}: ${raised}`,\r\n\t\t\t\t\t);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Generic pattern ${i + 1} matched but invalid number: \"${captured}\"`,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Final aggressive search: Find all dollar amounts and check their context\r\n\tif (!raised) {\r\n\t\tlogger.info(\"[SCRAPE]\", \"Performing aggressive context-based search...\");\r\n\t\tconst allDollarMatches = [...html.matchAll(/\\$([\\d,]+(?:\\.\\d+)?)/g)];\r\n\t\tlogger.debug(\r\n\t\t\t\"[SCRAPE]\",\r\n\t\t\t`Found ${allDollarMatches.length} dollar amounts in HTML`,\r\n\t\t);\r\n\r\n\t\tif (allDollarMatches.length > 0) {\r\n\t\t\t// Score each dollar amount based on context\r\n\t\t\tconst scoredAmounts: Array<{\r\n\t\t\t\tamount: string;\r\n\t\t\t\tscore: number;\r\n\t\t\t\traisedScore: number;\r\n\t\t\t\tcontext: string;\r\n\t\t\t}> = [];\r\n\r\n\t\t\tfor (const match of allDollarMatches) {\r\n\t\t\t\tconst amount = match[1];\r\n\t\t\t\tif (!isValidNumber(amount)) continue;\r\n\r\n\t\t\t\tconst matchIndex = match.index ?? 0;\r\n\t\t\t\tconst contextStart = Math.max(0, matchIndex - 300);\r\n\t\t\t\tconst contextEnd = Math.min(\r\n\t\t\t\t\thtml.length,\r\n\t\t\t\t\tmatchIndex + match[0].length + 300,\r\n\t\t\t\t);\r\n\t\t\t\tconst context = html.substring(contextStart, contextEnd).toLowerCase();\r\n\r\n\t\t\t\tlet raisedScore = 0;\r\n\r\n\t\t\t\t// Score for raised amounts\r\n\t\t\t\tif (\r\n\t\t\t\t\t/(?:raised|donated|collected|current|funds?|progress|amount\\s*(?:raised|donated))/i.test(\r\n\t\t\t\t\t\tcontext,\r\n\t\t\t\t\t)\r\n\t\t\t\t) {\r\n\t\t\t\t\traisedScore += 10;\r\n\t\t\t\t}\r\n\t\t\t\tif (\r\n\t\t\t\t\t/(?:has\\s+raised|has\\s+donated|has\\s+collected|currently\\s+raised)/i.test(\r\n\t\t\t\t\t\tcontext,\r\n\t\t\t\t\t)\r\n\t\t\t\t) {\r\n\t\t\t\t\traisedScore += 5;\r\n\t\t\t\t}\r\n\t\t\t\tif (\r\n\t\t\t\t\t/\\$[\\d,]+(?:\\.\\d+)?\\s*(?:raised|donated|collected)/i.test(context)\r\n\t\t\t\t) {\r\n\t\t\t\t\traisedScore += 8;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Store with score\r\n\t\t\t\tif (raisedScore > 0) {\r\n\t\t\t\t\tscoredAmounts.push({\r\n\t\t\t\t\t\tamount,\r\n\t\t\t\t\t\tscore: raisedScore,\r\n\t\t\t\t\t\traisedScore,\r\n\t\t\t\t\t\tcontext: context.substring(0, 200),\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Sort by score and pick the best candidate\r\n\t\t\tscoredAmounts.sort((a, b) => b.raisedScore - a.raisedScore);\r\n\r\n\t\t\t// Try to find raised amount\r\n\t\t\tif (scoredAmounts.length > 0) {\r\n\t\t\t\t// Look for amounts with raised-related context, sorted by raisedScore\r\n\t\t\t\tconst raisedCandidates = scoredAmounts\r\n\t\t\t\t\t.filter((a) => a.raisedScore > 0)\r\n\t\t\t\t\t.sort((a, b) => b.raisedScore - a.raisedScore);\r\n\t\t\t\tif (raisedCandidates.length > 0) {\r\n\t\t\t\t\traised = raisedCandidates[0].amount;\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Found raised amount via context search: ${raised} (raisedScore: ${raisedCandidates[0].raisedScore})`,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn raised;\r\n}\r\n\r\n/**\r\n * Extract target amount from HTML using DOMParser (primary method)\r\n * Falls back to regex if DOMParser fails or doesn't find results\r\n * @param html - The HTML content to parse\r\n * @returns The extracted target amount or empty string if not found\r\n */\r\nfunction extractTargetAmountWithDOMParser(html: string): string {\r\n\ttry {\r\n\t\tconst parser = new DOMParser();\r\n\t\tconst doc = parser.parseFromString(html, \"text/html\");\r\n\r\n\t\t// Try to find elements with target-related classes\r\n\t\t// Prioritize team page selectors first, then member page selectors\r\n\t\tconst selectors = [\r\n\t\t\t// Team page selectors\r\n\t\t\t\"#mospace-heroarea--donations-target-text\",\r\n\t\t\t'[id*=\"mospace-heroarea--donations-target-text\"]',\r\n\t\t\t// Member page selectors\r\n\t\t\t\"span.donationProgress--amount__target\",\r\n\t\t\t\"span[class*='donationProgress--amount__target']\",\r\n\t\t\t\".donationProgress--amount__target\",\r\n\t\t\t'[class*=\"donationProgress--amount__target\"]',\r\n\t\t\t'[class*=\"target\"]',\r\n\t\t\t'[class*=\"goal\"]',\r\n\t\t\t\"[data-target]\",\r\n\t\t\t\"[data-goal]\",\r\n\t\t\t\"[data-target-amount]\",\r\n\t\t];\r\n\r\n\t\tfor (const selector of selectors) {\r\n\t\t\tconst elements = doc.querySelectorAll(selector);\r\n\t\t\tfor (const element of Array.from(elements)) {\r\n\t\t\t\tconst text =\r\n\t\t\t\t\telement.textContent || (element as HTMLElement).innerText || \"\";\r\n\t\t\t\t// Try to extract amount from text\r\n\t\t\t\tconst amountMatch = text.match(/[\\d,]+(?:\\.\\d+)?/);\r\n\t\t\t\tif (amountMatch && isValidNumber(amountMatch[0])) {\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Found target amount using DOMParser with selector \"${selector}\": ${amountMatch[0]}`,\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn amountMatch[0];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Try data attributes\r\n\t\t\t\tconst dataTarget =\r\n\t\t\t\t\telement.getAttribute(\"data-target\") ||\r\n\t\t\t\t\telement.getAttribute(\"data-goal\") ||\r\n\t\t\t\t\telement.getAttribute(\"data-target-amount\");\r\n\t\t\t\tif (dataTarget && isValidNumber(dataTarget)) {\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Found target amount using DOMParser data attribute: ${dataTarget}`,\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn dataTarget;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Try to find JSON data in script tags using DOMParser\r\n\t\tconst scriptTags = doc.querySelectorAll(\"script\");\r\n\t\tfor (const script of Array.from(scriptTags)) {\r\n\t\t\tconst scriptContent = script.textContent || script.innerHTML || \"\";\r\n\t\t\tfor (let i = 0; i < TARGET_JSON_PATTERNS.length; i++) {\r\n\t\t\t\tconst pattern = TARGET_JSON_PATTERNS[i];\r\n\t\t\t\tconst match = scriptContent.match(pattern);\r\n\t\t\t\tif (match) {\r\n\t\t\t\t\tconst captured = match[1];\r\n\t\t\t\t\tif (isValidNumber(captured)) {\r\n\t\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t\t`Found target amount in JSON using DOMParser: ${captured}`,\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\treturn captured;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} catch (error) {\r\n\t\tlogger.warn(\r\n\t\t\t\"[SCRAPE]\",\r\n\t\t\t\"DOMParser extraction failed, falling back to regex:\",\r\n\t\t\terror,\r\n\t\t);\r\n\t}\r\n\r\n\treturn \"\";\r\n}\r\n\r\n/**\r\n * Extract target amount from HTML using multiple pattern strategies\r\n * Tries DOMParser first, then falls back to regex patterns\r\n * @param html - The HTML content to parse\r\n * @returns The extracted target amount or empty string if not found\r\n */\r\nexport function extractTargetAmount(html: string): string {\r\n\t// Try DOMParser first (more reliable for structured HTML)\r\n\tlet target = extractTargetAmountWithDOMParser(html);\r\n\tif (target) {\r\n\t\treturn target;\r\n\t}\r\n\r\n\tlogger.info(\r\n\t\t\"[SCRAPE]\",\r\n\t\t\"DOMParser didn't find target amount, trying regex patterns...\",\r\n\t);\r\n\ttarget = \"\";\r\n\r\n\t// Look for the target amount in the HTML\r\n\tfor (let i = 0; i < TARGET_PATTERNS.length; i++) {\r\n\t\tconst pattern = TARGET_PATTERNS[i];\r\n\t\tconst match = html.match(pattern);\r\n\t\tif (match) {\r\n\t\t\t// Get the last capture group (the amount), but also check all groups\r\n\t\t\tlet captured = match[match.length - 1];\r\n\r\n\t\t\t// If the last group is empty or invalid, try the second-to-last\r\n\t\t\tif (!captured || !isValidNumber(captured)) {\r\n\t\t\t\tif (match.length > 2) {\r\n\t\t\t\t\tcaptured = match[match.length - 2];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlogger.debug(\r\n\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t`Target pattern ${i + 1} matched, all groups:`,\r\n\t\t\t\tmatch.slice(1),\r\n\t\t\t\t`using: \"${captured}\"`,\r\n\t\t\t);\r\n\r\n\t\t\t// Validate that we captured a valid number\r\n\t\t\tif (isValidNumber(captured)) {\r\n\t\t\t\ttarget = captured;\r\n\t\t\t\tlogger.info(\r\n\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t`Found valid target amount using pattern ${i + 1}: ${target}`,\r\n\t\t\t\t);\r\n\t\t\t\tbreak;\r\n\t\t\t} else {\r\n\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t`Target pattern ${i + 1} matched but invalid number: \"${captured}\", trying next pattern...`,\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Fallback: Look for JSON data in script tags\r\n\tif (!target) {\r\n\t\tconst scriptTagMatches = html.match(/<script[^>]*>([\\s\\S]*?)<\\/script>/gi);\r\n\t\tif (scriptTagMatches) {\r\n\t\t\tfor (const scriptTag of scriptTagMatches) {\r\n\t\t\t\t// Try to find target amount in JSON\r\n\t\t\t\tfor (let i = 0; i < TARGET_JSON_PATTERNS.length; i++) {\r\n\t\t\t\t\tconst pattern = TARGET_JSON_PATTERNS[i];\r\n\t\t\t\t\tconst match = scriptTag.match(pattern);\r\n\t\t\t\t\tif (match) {\r\n\t\t\t\t\t\tconst captured = match[1];\r\n\t\t\t\t\t\tif (isValidNumber(captured)) {\r\n\t\t\t\t\t\t\ttarget = captured;\r\n\t\t\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t\t\t`Found valid target amount in JSON using pattern ${i + 1}: ${target}`,\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t\t\t`JSON target pattern ${i + 1} matched but invalid number: \"${captured}\"`,\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (target) break;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Last resort: Look for any dollar amounts in the HTML (more generic patterns)\r\n\tif (!target) {\r\n\t\tlogger.info(\r\n\t\t\t\"[SCRAPE]\",\r\n\t\t\t\"Trying generic target amount patterns as last resort...\",\r\n\t\t);\r\n\t\tfor (let i = 0; i < GENERIC_TARGET_PATTERNS.length; i++) {\r\n\t\t\tconst pattern = GENERIC_TARGET_PATTERNS[i];\r\n\t\t\tconst match = html.match(pattern);\r\n\t\t\tif (match) {\r\n\t\t\t\t// Iterate backward from the last capture group to index 1\r\n\t\t\t\t// Pick the first non-empty capture that passes isValidNumber\r\n\t\t\t\tlet captured: string | null = null;\r\n\t\t\t\tfor (let j = match.length - 1; j >= 1; j--) {\r\n\t\t\t\t\tif (match[j] && isValidNumber(match[j])) {\r\n\t\t\t\t\t\tcaptured = match[j];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (captured) {\r\n\t\t\t\t\ttarget = captured;\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Found valid target amount using generic pattern ${i + 1}: ${target}`,\r\n\t\t\t\t\t);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Generic target pattern ${i + 1} matched but no valid number found in capture groups`,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Final aggressive search: Find all dollar amounts and check their context\r\n\tif (!target) {\r\n\t\tconst allDollarMatches = [...html.matchAll(/\\$([\\d,]+(?:\\.\\d+)?)/g)];\r\n\r\n\t\tif (allDollarMatches.length > 0) {\r\n\t\t\t// Score each dollar amount based on context\r\n\t\t\tconst scoredAmounts: Array<{\r\n\t\t\t\tamount: string;\r\n\t\t\t\tscore: number;\r\n\t\t\t\ttargetScore: number;\r\n\t\t\t\tcontext: string;\r\n\t\t\t}> = [];\r\n\r\n\t\t\tfor (const match of allDollarMatches) {\r\n\t\t\t\tconst amount = match[1];\r\n\t\t\t\tif (!isValidNumber(amount)) continue;\r\n\r\n\t\t\t\tconst matchIndex = match.index ?? 0;\r\n\t\t\t\tconst contextStart = Math.max(0, matchIndex - 300);\r\n\t\t\t\tconst contextEnd = Math.min(\r\n\t\t\t\t\thtml.length,\r\n\t\t\t\t\tmatchIndex + match[0].length + 300,\r\n\t\t\t\t);\r\n\t\t\t\tconst context = html.substring(contextStart, contextEnd).toLowerCase();\r\n\r\n\t\t\t\tlet targetScore = 0;\r\n\r\n\t\t\t\t// Score for target amounts\r\n\t\t\t\tif (/(?:target|goal|aim|objective|of\\s+\\$)/i.test(context)) {\r\n\t\t\t\t\ttargetScore += 10;\r\n\t\t\t\t}\r\n\t\t\t\tif (\r\n\t\t\t\t\t/(?:target\\s+(?:of|is)|goal\\s+(?:of|is)|aim\\s+(?:of|is))/i.test(\r\n\t\t\t\t\t\tcontext,\r\n\t\t\t\t\t)\r\n\t\t\t\t) {\r\n\t\t\t\t\ttargetScore += 5;\r\n\t\t\t\t}\r\n\t\t\t\tif (/\\$[\\d,]+(?:\\.\\d+)?\\s*(?:target|goal)/i.test(context)) {\r\n\t\t\t\t\ttargetScore += 8;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Store with score\r\n\t\t\t\tif (targetScore > 0) {\r\n\t\t\t\t\tscoredAmounts.push({\r\n\t\t\t\t\t\tamount,\r\n\t\t\t\t\t\tscore: targetScore,\r\n\t\t\t\t\t\ttargetScore,\r\n\t\t\t\t\t\tcontext: context.substring(0, 200),\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Sort by score and pick the best candidate\r\n\t\t\tscoredAmounts.sort((a, b) => b.targetScore - a.targetScore);\r\n\r\n\t\t\t// Try to find target amount\r\n\t\t\tif (scoredAmounts.length > 0) {\r\n\t\t\t\t// Look for amounts with target-related context, sorted by targetScore\r\n\t\t\t\tconst targetCandidates = scoredAmounts\r\n\t\t\t\t\t.filter((a) => a.targetScore > 0)\r\n\t\t\t\t\t.sort((a, b) => b.targetScore - a.targetScore);\r\n\t\t\t\tif (targetCandidates.length > 0) {\r\n\t\t\t\t\ttarget = targetCandidates[0].amount;\r\n\t\t\t\t\tlogger.info(\r\n\t\t\t\t\t\t\"[SCRAPE]\",\r\n\t\t\t\t\t\t`Found target amount via context search: ${target} (targetScore: ${targetCandidates[0].targetScore})`,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn target;\r\n}\r\n\r\n/**\r\n * Extract both raised and target amounts from HTML\r\n * @param html - The HTML content to parse\r\n * @param memberId - The member ID (for logging)\r\n * @param subdomain - The subdomain (for logging)\r\n * @returns Object containing extracted amounts\r\n */\r\nexport function extractAmounts(\r\n\thtml: string,\r\n\tmemberId: string,\r\n\tsubdomain: string,\r\n): ExtractedAmounts {\r\n\tconst extractStart = Date.now();\r\n\tlogger.info(\"[SCRAPE]\", \"Extracting data from HTML...\");\r\n\r\n\tconst raised = extractRaisedAmount(html);\r\n\tconst target = extractTargetAmount(html);\r\n\r\n\tconst extractDuration = Date.now() - extractStart;\r\n\tlogger.info(\r\n\t\t\"[SCRAPE]\",\r\n\t\t`Data extraction completed in ${formatDuration(extractDuration)}`,\r\n\t);\r\n\tlogger.debug(\r\n\t\t\"[SCRAPE]\",\r\n\t\t`Raw extracted data for memberId ${memberId} (subdomain: ${subdomain}):`,\r\n\t\t{\r\n\t\t\traised: raised || \"NOT FOUND\",\r\n\t\t\ttarget: target || \"NOT FOUND\",\r\n\t\t},\r\n\t);\r\n\r\n\treturn { raised, target };\r\n}\r\n", "/**\n * Structured error tracking module\n * Can be extended to integrate with Sentry or other error tracking services\n *\n * PRIVACY & COMPLIANCE NOTES:\n * - All PII (memberId, subdomain) is hashed before storage\n * - URLs are sanitized to remove sensitive query parameters and fragments\n * - Error messages and stack traces are redacted to remove tokens/emails\n * - localStorage writes fail silently to prevent quota errors\n * - Error logs have TTL-based retention (default: 7 days)\n * - Maximum retention: last 50 errors (configurable)\n *\n * @module error-tracking\n */\n\nimport logger from \"./logger.js\";\n\n/**\n * Error severity levels\n */\nexport const ERROR_SEVERITY = {\n\tLOW: \"low\",\n\tMEDIUM: \"medium\",\n\tHIGH: \"high\",\n\tCRITICAL: \"critical\",\n} as const;\n\n/**\n * Error categories\n */\nexport const ERROR_CATEGORY = {\n\tSCRAPING: \"scraping\",\n\tSUBDOMAIN: \"subdomain\",\n\tCACHE: \"cache\",\n\tNETWORK: \"network\",\n\tPARSING: \"parsing\",\n\tVALIDATION: \"validation\",\n\tUNKNOWN: \"unknown\",\n} as const;\n\nexport type ErrorSeverity =\n\t(typeof ERROR_SEVERITY)[keyof typeof ERROR_SEVERITY];\nexport type ErrorCategory =\n\t(typeof ERROR_CATEGORY)[keyof typeof ERROR_CATEGORY];\n\nexport interface ErrorContext {\n\tcategory?: ErrorCategory;\n\tseverity?: ErrorSeverity;\n\tmemberId?: string;\n\tsubdomain?: string;\n\turl?: string;\n\tmetadata?: Record<string, unknown>;\n}\n\nexport interface ErrorInfo {\n\ttimestamp: string;\n\texpiresAt?: string; // ISO timestamp for TTL-based retention\n\tmessage: string;\n\tmessageHash?: string; // Hashed summary of message for sensitive errors\n\tstack?: string;\n\tstackHash?: string; // Hashed summary of stack for sensitive errors\n\tcategory: ErrorCategory;\n\tseverity: ErrorSeverity;\n\tcontext: {\n\t\tmemberId?: string; // Hashed value\n\t\tsubdomain?: string; // Hashed value\n\t\turl?: string; // Sanitized (origin + pathname only)\n\t\t[key: string]: unknown;\n\t};\n}\n\n/**\n * Configuration constants for error tracking\n */\nconst ERROR_TRACKING_CONFIG = {\n\tMAX_ERRORS: 50, // Maximum number of errors to retain\n\tTTL_DAYS: 7, // Time-to-live in days for error entries\n\tMESSAGE_MAX_LENGTH: 200, // Maximum length for error messages\n\tSTACK_MAX_LENGTH: 500, // Maximum length for stack traces\n} as const;\n\n/**\n * Sensitive query parameters that should be stripped from URLs\n */\nconst SENSITIVE_QUERY_PARAMS = new Set([\n\t\"token\",\n\t\"access_token\",\n\t\"refresh_token\",\n\t\"api_key\",\n\t\"apikey\",\n\t\"password\",\n\t\"secret\",\n\t\"auth\",\n\t\"authorization\",\n\t\"session\",\n\t\"sessionid\",\n\t\"sid\",\n\t\"csrf\",\n\t\"csrf_token\",\n\t\"email\",\n\t\"user\",\n\t\"username\",\n\t\"memberid\",\n\t\"member_id\",\n]);\n\n/**\n * Whitelist of safe query parameters that can be stored\n * If empty, only origin + pathname is stored\n */\nconst SAFE_QUERY_PARAMS = new Set<string>([\n\t// Add safe query params here if needed, e.g. \"page\", \"limit\"\n]);\n\n/**\n * Patterns to redact from error messages and stack traces\n */\nconst SENSITIVE_PATTERNS = [\n\t/\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/g, // Email addresses\n\t/\\b(?:token|api[_-]?key|access[_-]?token|refresh[_-]?token|auth[_-]?token|bearer)\\s*[:=]\\s*['\"]?([A-Za-z0-9\\-._~+/]+=*)['\"]?/gi, // Tokens\n\t/\\b(?:password|passwd|pwd|secret)\\s*[:=]\\s*['\"]?([^\\s'\"]+)['\"]?/gi, // Passwords\n\t/\\b\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}\\b/g, // Credit card numbers\n];\n\n/**\n * Simple hash function for PII (non-cryptographic, for privacy only)\n * Uses a simple string hash algorithm\n */\nfunction hashValue(value: string): string {\n\tif (!value) return \"\";\n\n\t// Simple hash function (FNV-1a inspired)\n\tlet hash = 2166136261;\n\tfor (let i = 0; i < value.length; i++) {\n\t\thash ^= value.charCodeAt(i);\n\t\thash +=\n\t\t\t(hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n\t}\n\n\t// Convert to hex and take first 16 chars\n\treturn `hash_${Math.abs(hash).toString(16).substring(0, 16)}`;\n}\n\n/**\n * Redact sensitive patterns from text\n */\nfunction redactSensitive(text: string): string {\n\tlet redacted = text;\n\tfor (const pattern of SENSITIVE_PATTERNS) {\n\t\tredacted = redacted.replace(pattern, \"[REDACTED]\");\n\t}\n\treturn redacted;\n}\n\n/**\n * Sanitize error message by redacting sensitive info and truncating\n */\nfunction sanitizeMessage(message: string): { message: string; hash?: string } {\n\tconst redacted = redactSensitive(message);\n\tconst truncated =\n\t\tredacted.length > ERROR_TRACKING_CONFIG.MESSAGE_MAX_LENGTH\n\t\t\t? `${redacted.substring(0, ERROR_TRACKING_CONFIG.MESSAGE_MAX_LENGTH)}...`\n\t\t\t: redacted;\n\n\t// If message was redacted or truncated, store hash of original\n\tconst needsHash = redacted !== message || truncated !== redacted;\n\tconst hash = needsHash ? hashValue(message) : undefined;\n\n\treturn { message: truncated, hash };\n}\n\n/**\n * Sanitize stack trace by redacting sensitive info and truncating\n */\nfunction sanitizeStack(stack: string | undefined): {\n\tstack?: string;\n\thash?: string;\n} {\n\tif (!stack) return {};\n\n\tconst redacted = redactSensitive(stack);\n\tconst truncated =\n\t\tredacted.length > ERROR_TRACKING_CONFIG.STACK_MAX_LENGTH\n\t\t\t? `${redacted.substring(0, ERROR_TRACKING_CONFIG.STACK_MAX_LENGTH)}...`\n\t\t\t: redacted;\n\n\t// If stack was redacted or truncated, store hash of original\n\tconst needsHash = redacted !== stack || truncated !== redacted;\n\tconst hash = needsHash ? hashValue(stack) : undefined;\n\n\treturn { stack: truncated, hash };\n}\n\n/**\n * Sanitize URL by removing sensitive query parameters and fragments\n * Only stores origin + pathname, or origin + pathname + safe query params\n */\nfunction sanitizeUrl(url: string | undefined): string | undefined {\n\tif (!url) return undefined;\n\n\ttry {\n\t\tconst urlObj = new URL(url);\n\t\tconst origin = urlObj.origin;\n\t\tconst pathname = urlObj.pathname;\n\n\t\t// If no safe query params whitelist, return only origin + pathname\n\t\tif (SAFE_QUERY_PARAMS.size === 0) {\n\t\t\treturn `${origin}${pathname}`;\n\t\t}\n\n\t\t// Otherwise, include only safe query parameters\n\t\tconst safeParams = new URLSearchParams();\n\t\turlObj.searchParams.forEach((value, key) => {\n\t\t\tconst lowerKey = key.toLowerCase();\n\t\t\tif (\n\t\t\t\tSAFE_QUERY_PARAMS.has(lowerKey) &&\n\t\t\t\t!SENSITIVE_QUERY_PARAMS.has(lowerKey)\n\t\t\t) {\n\t\t\t\tsafeParams.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\tconst queryString = safeParams.toString();\n\t\treturn queryString\n\t\t\t? `${origin}${pathname}?${queryString}`\n\t\t\t: `${origin}${pathname}`;\n\t} catch {\n\t\t// If URL parsing fails, return a sanitized version\n\t\t// Remove fragments and try to extract origin + pathname\n\t\tconst withoutFragment = url.split(\"#\")[0];\n\t\tconst withoutQuery = withoutFragment.split(\"?\")[0];\n\t\ttry {\n\t\t\tconst urlObj = new URL(withoutQuery);\n\t\t\treturn `${urlObj.origin}${urlObj.pathname}`;\n\t\t} catch {\n\t\t\t// If still fails, return a generic placeholder\n\t\t\treturn \"[INVALID_URL]\";\n\t\t}\n\t}\n}\n\n/**\n * Purge expired errors based on TTL\n */\nfunction purgeExpiredErrors(errors: ErrorInfo[]): ErrorInfo[] {\n\tconst now = Date.now();\n\treturn errors.filter((error) => {\n\t\tif (!error.expiresAt) return true; // Keep errors without expiry (legacy)\n\t\ttry {\n\t\t\tconst expiresAt = new Date(error.expiresAt).getTime();\n\t\t\treturn expiresAt > now;\n\t\t} catch {\n\t\t\treturn false; // Remove errors with invalid expiry\n\t\t}\n\t});\n}\n\n/**\n * Enforce retention limits (max N errors)\n */\nfunction enforceRetentionLimit(errors: ErrorInfo[]): ErrorInfo[] {\n\tif (errors.length <= ERROR_TRACKING_CONFIG.MAX_ERRORS) {\n\t\treturn errors;\n\t}\n\t// Keep only the most recent N errors\n\treturn errors.slice(-ERROR_TRACKING_CONFIG.MAX_ERRORS);\n}\n\n/**\n * Track an error with structured context\n * All PII is sanitized/hashed before storage for privacy compliance.\n *\n * @param error - The error object or error message\n * @param context - Additional context about the error\n * @returns The tracked error information (sanitized)\n */\nexport function trackError(\n\terror: Error | string,\n\tcontext: ErrorContext = {},\n): ErrorInfo {\n\tconst rawMessage = error instanceof Error ? error.message : String(error);\n\tconst rawStack = error instanceof Error ? error.stack : undefined;\n\n\t// Sanitize message and stack\n\tconst { message, hash: messageHash } = sanitizeMessage(rawMessage);\n\tconst { stack, hash: stackHash } = sanitizeStack(rawStack);\n\n\t// Calculate expiry timestamp (TTL-based retention)\n\tconst now = new Date();\n\tconst expiresAt = new Date(\n\t\tnow.getTime() + ERROR_TRACKING_CONFIG.TTL_DAYS * 24 * 60 * 60 * 1000,\n\t);\n\n\t// Build sanitized error info\n\tconst errorInfo: ErrorInfo = {\n\t\ttimestamp: now.toISOString(),\n\t\texpiresAt: expiresAt.toISOString(),\n\t\tmessage,\n\t\t...(messageHash && { messageHash }),\n\t\t...(stack && { stack }),\n\t\t...(stackHash && { stackHash }),\n\t\tcategory: context.category || ERROR_CATEGORY.UNKNOWN,\n\t\tseverity: context.severity || ERROR_SEVERITY.MEDIUM,\n\t\tcontext: {\n\t\t\t// Hash PII before storage\n\t\t\t...(context.memberId && { memberId: hashValue(context.memberId) }),\n\t\t\t...(context.subdomain && { subdomain: hashValue(context.subdomain) }),\n\t\t\t// Sanitize URL (remove sensitive query params and fragments)\n\t\t\t...(context.url && { url: sanitizeUrl(context.url) }),\n\t\t\t// Sanitize metadata if present (redact sensitive patterns)\n\t\t\t...(context.metadata &&\n\t\t\t\tObject.keys(context.metadata).length > 0 && {\n\t\t\t\t\tmetadata: Object.fromEntries(\n\t\t\t\t\t\tObject.entries(context.metadata).map(([key, value]) => [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\ttypeof value === \"string\" ? redactSensitive(value) : value,\n\t\t\t\t\t\t]),\n\t\t\t\t\t),\n\t\t\t\t}),\n\t\t},\n\t};\n\n\t// Log the error with structured information (original message for debugging)\n\tlogger.error(\n\t\t\"[ERROR_TRACKING]\",\n\t\t`[${errorInfo.category}] [${errorInfo.severity}] ${rawMessage}`,\n\t\terrorInfo,\n\t);\n\n\t// In the future, this can be extended to send to Sentry:\n\t// if (window.Sentry) {\n\t//   window.Sentry.captureException(error, {\n\t//     tags: {\n\t//       category: errorInfo.category,\n\t//       severity: errorInfo.severity,\n\t//     },\n\t//     extra: errorInfo.context,\n\t//   });\n\t// }\n\n\t// Store errors in localStorage for debugging\n\t// localStorage writes fail silently to prevent quota errors (compliance requirement)\n\ttry {\n\t\t// Get existing errors\n\t\tconst storedErrors = JSON.parse(\n\t\t\tlocalStorage.getItem(\"error_tracking_log\") || \"[]\",\n\t\t) as ErrorInfo[];\n\n\t\t// Purge expired errors (TTL-based retention)\n\t\tconst activeErrors = purgeExpiredErrors(storedErrors);\n\n\t\t// Add new error\n\t\tactiveErrors.push(errorInfo);\n\n\t\t// Enforce retention limit (max N errors)\n\t\tconst trimmedErrors = enforceRetentionLimit(activeErrors);\n\n\t\t// Store back to localStorage (fail silently if quota exceeded)\n\t\tlocalStorage.setItem(\"error_tracking_log\", JSON.stringify(trimmedErrors));\n\t} catch (e) {\n\t\t// Fail silently - localStorage may be unavailable or quota exceeded\n\t\t// This is intentional for compliance (don't break app if storage fails)\n\t\t// Only log to console if logger is available (won't affect user experience)\n\t\tif (logger?.warn) {\n\t\t\ttry {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t\"[ERROR_TRACKING]\",\n\t\t\t\t\t\"Failed to store error in localStorage (quota exceeded or unavailable):\",\n\t\t\t\t\te instanceof Error ? e.message : String(e),\n\t\t\t\t);\n\t\t\t} catch {\n\t\t\t\t// If logger also fails, fail completely silently\n\t\t\t}\n\t\t}\n\t}\n\n\treturn errorInfo;\n}\n\n/**\n * Track a scraping error\n * @param error - The error object\n * @param context - Additional context\n */\nexport function trackScrapingError(\n\terror: Error,\n\tcontext: Omit<ErrorContext, \"category\" | \"severity\"> = {},\n): ErrorInfo {\n\treturn trackError(error, {\n\t\tcategory: ERROR_CATEGORY.SCRAPING,\n\t\tseverity: ERROR_SEVERITY.HIGH,\n\t\t...context,\n\t});\n}\n\n/**\n * Track a subdomain detection error\n * @param error - The error object\n * @param context - Additional context\n */\nexport function trackSubdomainError(\n\terror: Error,\n\tcontext: Omit<ErrorContext, \"category\" | \"severity\"> = {},\n): ErrorInfo {\n\treturn trackError(error, {\n\t\tcategory: ERROR_CATEGORY.SUBDOMAIN,\n\t\tseverity: ERROR_SEVERITY.MEDIUM,\n\t\t...context,\n\t});\n}\n\n/**\n * Track a network error\n * @param error - The error object\n * @param context - Additional context\n */\nexport function trackNetworkError(\n\terror: Error,\n\tcontext: Omit<ErrorContext, \"category\" | \"severity\"> = {},\n): ErrorInfo {\n\treturn trackError(error, {\n\t\tcategory: ERROR_CATEGORY.NETWORK,\n\t\tseverity: ERROR_SEVERITY.HIGH,\n\t\t...context,\n\t});\n}\n\n/**\n * Track a parsing error\n * @param error - The error object\n * @param context - Additional context\n */\nexport function trackParsingError(\n\terror: Error,\n\tcontext: Omit<ErrorContext, \"category\" | \"severity\"> = {},\n): ErrorInfo {\n\treturn trackError(error, {\n\t\tcategory: ERROR_CATEGORY.PARSING,\n\t\tseverity: ERROR_SEVERITY.MEDIUM,\n\t\t...context,\n\t});\n}\n\n/**\n * Get recent errors from localStorage\n * Automatically purges expired errors based on TTL.\n *\n * @param limit - Maximum number of errors to return\n * @returns Array of recent errors (sanitized)\n */\nexport function getRecentErrors(limit = 10): ErrorInfo[] {\n\ttry {\n\t\tconst storedErrors = JSON.parse(\n\t\t\tlocalStorage.getItem(\"error_tracking_log\") || \"[]\",\n\t\t) as ErrorInfo[];\n\n\t\t// Purge expired errors (TTL-based retention)\n\t\tconst activeErrors = purgeExpiredErrors(storedErrors);\n\n\t\t// If expired errors were removed, update localStorage\n\t\tif (activeErrors.length !== storedErrors.length) {\n\t\t\ttry {\n\t\t\t\tconst trimmedErrors = enforceRetentionLimit(activeErrors);\n\t\t\t\tlocalStorage.setItem(\n\t\t\t\t\t\"error_tracking_log\",\n\t\t\t\t\tJSON.stringify(trimmedErrors),\n\t\t\t\t);\n\t\t\t} catch {\n\t\t\t\t// Fail silently if localStorage update fails\n\t\t\t}\n\t\t}\n\n\t\treturn activeErrors.slice(-limit);\n\t} catch (e) {\n\t\t// Fail silently - localStorage may be unavailable\n\t\tif (logger?.warn) {\n\t\t\ttry {\n\t\t\t\tlogger.warn(\"[ERROR_TRACKING]\", \"Failed to get recent errors:\", e);\n\t\t\t} catch {\n\t\t\t\t// If logger fails, fail completely silently\n\t\t\t}\n\t\t}\n\t\treturn [];\n\t}\n}\n\n/**\n * Clear error tracking log\n * Fails silently if localStorage is unavailable (compliance requirement).\n */\nexport function clearErrorLog(): void {\n\ttry {\n\t\tlocalStorage.removeItem(\"error_tracking_log\");\n\t\tif (logger?.info) {\n\t\t\ttry {\n\t\t\t\tlogger.info(\"[ERROR_TRACKING]\", \"Error log cleared\");\n\t\t\t} catch {\n\t\t\t\t// If logger fails, fail completely silently\n\t\t\t}\n\t\t}\n\t} catch (e) {\n\t\t// Fail silently - localStorage may be unavailable\n\t\t// This is intentional for compliance (don't break app if storage fails)\n\t\tif (logger?.warn) {\n\t\t\ttry {\n\t\t\t\tlogger.warn(\"[ERROR_TRACKING]\", \"Failed to clear error log:\", e);\n\t\t\t} catch {\n\t\t\t\t// If logger also fails, fail completely silently\n\t\t\t}\n\t\t}\n\t}\n}\n", "/**\n * Network utilities for fetching Movember pages via proxy\n * @module scraper/network\n */\n\nimport {\n\tgetProxyUrl,\n\tMOVEMBER_BASE_URL_TEMPLATE,\n\tMOVEMBER_TEAM_URL_TEMPLATE,\n} from \"../constants.js\";\nimport { trackNetworkError } from \"../error-tracking.js\";\nimport logger from \"../logger.js\";\nimport { URL_PATTERNS } from \"../regex-patterns.js\";\n\nexport interface FetchResult {\n\thtml: string;\n\tfinalUrl: string;\n}\n\n/**\n * Extract subdomain from a Movember URL\n * @param url - The Movember URL\n * @returns The subdomain (e.g., \"uk\", \"au\", \"us\") or null if not found\n */\nexport function extractSubdomainFromUrl(url: string): string | null {\n\tconst match = url.match(URL_PATTERNS.SUBDOMAIN);\n\treturn match ? match[1] : null;\n}\n\n/**\n * Fetch HTML using Worker's CORS proxy\n * Returns both HTML and the final URL after redirects\n * @param url - The URL to fetch\n * @returns The HTML content and final URL\n * @throws If the proxy request fails\n */\nexport async function fetchViaProxy(url: string): Promise<FetchResult> {\n\tconst proxyUrl = `${getProxyUrl()}?url=${encodeURIComponent(url)}`;\n\tconst response = await fetch(proxyUrl);\n\n\tif (!response.ok) {\n\t\t// Try to get error message from response\n\t\tlet errorMessage = `Proxy error! status: ${response.status}`;\n\t\ttry {\n\t\t\tconst contentType = response.headers.get(\"content-type\");\n\t\t\tif (contentType?.includes(\"application/json\")) {\n\t\t\t\tconst errorData = (await response.json()) as { message?: string };\n\t\t\t\tif (errorData.message) {\n\t\t\t\t\terrorMessage = errorData.message;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst errorText = await response.text();\n\t\t\t\tif (errorText) {\n\t\t\t\t\terrorMessage = errorText.substring(0, 200); // Limit error message length\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// Ignore parse errors, use default error message\n\t\t\tlogger.warn(\"[PROXY]\", \"Could not parse error response:\", e);\n\t\t}\n\n\t\tconst error = new Error(errorMessage);\n\t\t// Track network error with structured context\n\t\ttrackNetworkError(error, {\n\t\t\turl,\n\t\t\tmetadata: {\n\t\t\t\tstatus: response.status,\n\t\t\t\tstatusText: response.statusText,\n\t\t\t},\n\t\t});\n\n\t\tthrow error;\n\t}\n\n\t// Worker proxy returns HTML directly\n\tconst html = await response.text();\n\t// Get final URL after redirects from response header\n\tconst finalUrl = response.headers.get(\"X-Final-URL\") || url;\n\n\treturn { html, finalUrl };\n}\n\n/**\n * Build Movember URL with correct subdomain for a member\n * @param memberId - The member ID\n * @param subdomain - The subdomain to use\n * @returns The complete Movember URL\n */\nexport function buildMovemberUrl(memberId: string, subdomain: string): string {\n\tconst baseUrl = MOVEMBER_BASE_URL_TEMPLATE.replace(\"{subdomain}\", subdomain);\n\treturn `${baseUrl}?memberId=${memberId}`;\n}\n\n/**\n * Build Movember team URL with correct subdomain for a team\n * @param teamId - The team ID\n * @param subdomain - The subdomain to use\n * @returns The complete Movember team URL\n */\nexport function buildTeamUrl(teamId: string, subdomain: string): string {\n\tconst baseUrl = MOVEMBER_TEAM_URL_TEMPLATE.replace(\"{subdomain}\", subdomain);\n\treturn baseUrl.replace(\"{id}\", teamId);\n}\n", "// localStorage cache manager with TTL support\n// Subdomain stored in separate cache key (movember:subdomain:${type}:${id}) with 24h TTL\n// Data stored in separate cache key (movember:data:${type}:${id}) with 5min TTL\n// Types: \"member\" or \"team\"\nimport logger from \"./logger.js\";\n\n/**\n * Create cache key with proper namespacing for member or team\n * @param type - \"member\" or \"team\"\n * @param id - The ID (memberId or teamId)\n * @param prefix - Cache prefix (e.g., \"data\" or \"subdomain\")\n * @returns The cache key\n */\nfunction createCacheKey(\n\ttype: \"member\" | \"team\",\n\tid: string,\n\tprefix: string,\n): string {\n\treturn `movember:${prefix}:${type}:${id}`;\n}\n\nexport interface CachedData {\n\tamount: string;\n\tcurrency: string;\n\tsubdomain: string;\n\ttimestamp: number;\n\ttarget?: string;\n\tpercentage?: number;\n}\n\ninterface CacheEntry<T> {\n\tdata: T;\n\tcachedAt: number;\n\tttl: number;\n}\n\ninterface SubdomainCacheEntry {\n\tsubdomain: string;\n\tcachedAt: number;\n\tttl: number;\n}\n\n/**\n * Get cached donation data for a member or team (includes subdomain)\n * @param type - \"member\" or \"team\"\n * @param id - Member ID or Team ID\n * @returns Cached data or null if expired/not found\n * Data structure: { amount, currency, target, percentage, timestamp, subdomain }\n */\nexport function getCachedData(\n\ttype: \"member\" | \"team\",\n\tid: string,\n): CachedData | null {\n\ttry {\n\t\tconst cacheKey = createCacheKey(type, id, \"data\");\n\t\tconst cached = localStorage.getItem(cacheKey);\n\t\tif (!cached) return null;\n\n\t\tconst entry = JSON.parse(cached) as CacheEntry<CachedData>;\n\t\tconst now = Date.now();\n\n\t\t// Check if cache is expired\n\t\tif (now - entry.cachedAt > entry.ttl) {\n\t\t\tlocalStorage.removeItem(cacheKey);\n\t\t\treturn null;\n\t\t}\n\n\t\treturn entry.data;\n\t} catch (error) {\n\t\tlogger.warn(\"[CACHE]\", \"Error reading cached data:\", error);\n\t\treturn null;\n\t}\n}\n\n/**\n * Get stale cached data for a member or team (even if expired)\n * Used for stale-while-revalidate pattern\n * @param type - \"member\" or \"team\"\n * @param id - Member ID or Team ID\n * @returns Stale cached data or null if not found\n * Data structure: { amount, currency, target, percentage, timestamp, subdomain }\n */\nexport function getStaleCachedData(\n\ttype: \"member\" | \"team\",\n\tid: string,\n): CachedData | null {\n\ttry {\n\t\tconst cacheKey = createCacheKey(type, id, \"data\");\n\t\tconst cached = localStorage.getItem(cacheKey);\n\t\tif (!cached) return null;\n\n\t\tconst entry = JSON.parse(cached) as CacheEntry<CachedData>;\n\n\t\t// Return data even if expired (for stale-while-revalidate)\n\t\t// Only return null if cache doesn't exist\n\t\treturn entry.data;\n\t} catch (error) {\n\t\tlogger.warn(\"[CACHE]\", \"Error reading stale cached data:\", error);\n\t\treturn null;\n\t}\n}\n\n/**\n * Check if cached data is stale (expired but still available)\n * @param type - \"member\" or \"team\"\n * @param id - Member ID or Team ID\n * @returns True if data exists but is expired, false otherwise\n */\nexport function isCachedDataStale(\n\ttype: \"member\" | \"team\",\n\tid: string,\n): boolean {\n\ttry {\n\t\tconst cacheKey = createCacheKey(type, id, \"data\");\n\t\tconst cached = localStorage.getItem(cacheKey);\n\t\tif (!cached) return false;\n\n\t\tconst entry = JSON.parse(cached) as CacheEntry<CachedData>;\n\t\tconst now = Date.now();\n\n\t\t// Check if cache is expired\n\t\treturn now - entry.cachedAt > entry.ttl;\n\t} catch (error) {\n\t\tlogger.warn(\"[CACHE]\", \"Error checking if cached data is stale:\", error);\n\t\treturn false;\n\t}\n}\n\n/**\n * Set cached donation data for a member or team (includes subdomain)\n * @param type - \"member\" or \"team\"\n * @param id - Member ID or Team ID\n * @param data - Data to cache (must include subdomain)\n * @param ttl - Time to live in milliseconds\n */\nexport function setCachedData(\n\ttype: \"member\" | \"team\",\n\tid: string,\n\tdata: CachedData,\n\tttl: number,\n): void {\n\ttry {\n\t\tconst cacheKey = createCacheKey(type, id, \"data\");\n\t\tconst cacheValue: CacheEntry<CachedData> = {\n\t\t\tdata,\n\t\t\tcachedAt: Date.now(),\n\t\t\tttl,\n\t\t};\n\t\tlocalStorage.setItem(cacheKey, JSON.stringify(cacheValue));\n\t} catch (error) {\n\t\tlogger.warn(\"[CACHE]\", \"Error setting cached data:\", error);\n\t}\n}\n\n/**\n * Get cached subdomain for a member or team (from separate cache key)\n * Uses subdomain TTL (24h) independent of data TTL (5min) - subdomain persists longer\n * @param type - \"member\" or \"team\"\n * @param id - Member ID or Team ID\n * @returns Cached subdomain or null if expired/not found\n */\nexport function getCachedSubdomain(\n\ttype: \"member\" | \"team\",\n\tid: string,\n): string | null {\n\ttry {\n\t\tconst cacheKey = createCacheKey(type, id, \"subdomain\");\n\t\tconst cached = localStorage.getItem(cacheKey);\n\t\tif (!cached) return null;\n\n\t\tconst entry = JSON.parse(cached) as SubdomainCacheEntry;\n\t\tconst now = Date.now();\n\n\t\t// Check if cache is expired using the stored TTL\n\t\tif (now - entry.cachedAt > entry.ttl) {\n\t\t\tlocalStorage.removeItem(cacheKey);\n\t\t\treturn null;\n\t\t}\n\n\t\treturn entry.subdomain;\n\t} catch (error) {\n\t\tlogger.warn(\"[CACHE]\", \"Error reading cached subdomain:\", error);\n\t\treturn null;\n\t}\n}\n\n/**\n * Set cached subdomain for a member or team (uses separate cache key with independent TTL)\n * @param type - \"member\" or \"team\"\n * @param id - Member ID or Team ID\n * @param subdomain - Subdomain to cache\n * @param ttl - Time to live in milliseconds (typically SUBDOMAIN_CACHE_TTL)\n */\nexport function setCachedSubdomain(\n\ttype: \"member\" | \"team\",\n\tid: string,\n\tsubdomain: string,\n\tttl: number,\n): void {\n\ttry {\n\t\tconst cacheKey = createCacheKey(type, id, \"subdomain\");\n\t\tconst cacheValue: SubdomainCacheEntry = {\n\t\t\tsubdomain,\n\t\t\tcachedAt: Date.now(),\n\t\t\tttl,\n\t\t};\n\t\tlocalStorage.setItem(cacheKey, JSON.stringify(cacheValue));\n\t} catch (error) {\n\t\tlogger.warn(\"[CACHE]\", \"Error setting cached subdomain:\", error);\n\t}\n}\n\n/**\n * Clear cached data for a member or team (clears both data and subdomain)\n * @param type - \"member\" or \"team\"\n * @param id - Member ID or Team ID\n */\nexport function clearSubdomainCache(type: \"member\" | \"team\", id: string): void {\n\ttry {\n\t\tconst cacheKey = createCacheKey(type, id, \"data\");\n\t\tlocalStorage.removeItem(cacheKey);\n\n\t\t// Clear separate subdomain cache\n\t\tconst subdomainKey = createCacheKey(type, id, \"subdomain\");\n\t\tlocalStorage.removeItem(subdomainKey);\n\n\t\t// Also clear old amount cache if it exists (migration cleanup)\n\t\tconst oldAmountKey = `movember:amount:${type}:${id}`;\n\t\tlocalStorage.removeItem(oldAmountKey);\n\t} catch (error) {\n\t\tlogger.warn(\"[CACHE]\", \"Error clearing cached data:\", error);\n\t}\n}\n", "/**\n * Subdomain detection logic for Movember pages\n * @module scraper/subdomain\n */\n\nimport { getCachedSubdomain, setCachedSubdomain } from \"../cache.js\";\nimport {\n\tDEFAULT_SUBDOMAIN,\n\tMEMBER_SUBDOMAIN_MAP,\n\tSUBDOMAIN_CACHE_TTL,\n} from \"../constants.js\";\nimport { trackSubdomainError } from \"../error-tracking.js\";\nimport logger from \"../logger.js\";\nimport {\n\tCOUNTRY_DETECTION_PATTERNS,\n\tCURRENCY_CODE_PATTERNS,\n\tDOLLAR_AMOUNT_PATTERN,\n} from \"../regex-patterns.js\";\nimport {\n\tbuildMovemberUrl,\n\tbuildTeamUrl,\n\textractSubdomainFromUrl,\n\tfetchViaProxy,\n} from \"./network.js\";\n\n/**\n * Detect subdomain from HTML content by checking currency symbols\n * This is used for verification - if currency doesn't match URL subdomain, we skip it\n * Made more aggressive: checks for currency symbols anywhere, not just near amounts\n * @param html - The HTML content to analyze\n * @returns The detected subdomain or null if not found\n */\nexport function detectSubdomainFromHtml(\n\thtml: string | null | undefined,\n): string | null {\n\tif (!html) return null;\n\n\t// First, check for unambiguous currency symbols anywhere in HTML (most reliable)\n\t// \u00A3 symbol anywhere indicates UK (GBP)\n\tif (\n\t\thtml.includes(\"\u00A3\") ||\n\t\thtml.includes(\"&pound;\") ||\n\t\thtml.includes(\"&#163;\")\n\t) {\n\t\treturn \"uk\";\n\t}\n\n\t// \u20AC symbol anywhere indicates EU\n\tif (\n\t\thtml.includes(\"\u20AC\") ||\n\t\thtml.includes(\"&euro;\") ||\n\t\thtml.includes(\"&#8364;\")\n\t) {\n\t\t// Try to determine which EU country by checking for country-specific text\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.IRELAND)) return \"ie\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.NETHERLANDS)) return \"nl\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.GERMANY)) return \"de\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.FRANCE)) return \"fr\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.SPAIN)) return \"es\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.ITALY)) return \"it\";\n\t\t// Default to first EU country if we can't determine\n\t\treturn \"ie\";\n\t}\n\n\t// Look for currency codes near amounts (secondary check)\n\t// Pattern: currency code followed by amount, or amount followed by currency code\n\n\t// Check for GBP code near amounts (UK) - secondary check after symbol check\n\tif (CURRENCY_CODE_PATTERNS[0].test(html)) {\n\t\treturn \"uk\";\n\t}\n\n\t// Check for EUR/\u20AC near amounts (EU countries)\n\tif (CURRENCY_CODE_PATTERNS[1].test(html)) {\n\t\t// Try to determine which EU country by checking for country-specific text\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.IRELAND)) return \"ie\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.NETHERLANDS)) return \"nl\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.GERMANY)) return \"de\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.FRANCE)) return \"fr\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.SPAIN)) return \"es\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.ITALY)) return \"it\";\n\t\t// Default to first EU country if we can't determine\n\t\treturn \"ie\";\n\t}\n\n\t// Check for USD near amounts (US)\n\tif (CURRENCY_CODE_PATTERNS[2].test(html)) {\n\t\treturn \"us\";\n\t}\n\n\t// Check for AUD near amounts (Australia) - check before generic $\n\tif (CURRENCY_CODE_PATTERNS[3].test(html)) {\n\t\treturn \"au\";\n\t}\n\n\t// Check for CAD near amounts (Canada)\n\tif (CURRENCY_CODE_PATTERNS[4].test(html)) {\n\t\treturn \"ca\";\n\t}\n\n\t// Check for NZD near amounts (New Zealand)\n\tif (CURRENCY_CODE_PATTERNS[5].test(html)) {\n\t\treturn \"nz\";\n\t}\n\n\t// Check for ZAR near amounts (South Africa)\n\tif (CURRENCY_CODE_PATTERNS[6].test(html)) {\n\t\treturn \"za\";\n\t}\n\n\t// Check for CZK/K\u010D near amounts (Czech Republic)\n\tif (CURRENCY_CODE_PATTERNS[7].test(html)) {\n\t\treturn \"cz\";\n\t}\n\n\t// Check for SEK near amounts (Sweden)\n\tif (CURRENCY_CODE_PATTERNS[8].test(html)) {\n\t\treturn \"se\";\n\t}\n\n\t// Check for DKK near amounts (Denmark)\n\tif (CURRENCY_CODE_PATTERNS[9].test(html)) {\n\t\treturn \"dk\";\n\t}\n\n\t// Fallback: Check for $ near amounts (but this is ambiguous)\n\t// Only use if we see $ followed by digits, and prefer AUD as default\n\tif (DOLLAR_AMOUNT_PATTERN.test(html)) {\n\t\t// Try to find country indicators\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.UNITED_STATES)) return \"us\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.CANADA)) return \"ca\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.NEW_ZEALAND)) return \"nz\";\n\t\tif (html.match(COUNTRY_DETECTION_PATTERNS.AUSTRALIA)) return \"au\";\n\t\t// Default to AUD if we can't determine (since au is default subdomain)\n\t\treturn \"au\";\n\t}\n\n\treturn null;\n}\n\n/**\n * Detect subdomain by following redirects and checking HTML content\n * @param memberId - The member ID\n * @param forceRefresh - Whether to force refresh (skip cache)\n * @returns The detected subdomain\n */\nexport async function detectSubdomainForMember(\n\tmemberId: string,\n\tforceRefresh = false,\n): Promise<string> {\n\t// Check cache first (unless forcing refresh)\n\tif (!forceRefresh) {\n\t\tconst cached = getCachedSubdomain(\"member\", memberId);\n\t\tif (cached) {\n\t\t\tlogger.info(\n\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t`Found cached subdomain for memberId ${memberId}: ${cached}`,\n\t\t\t);\n\t\t\treturn cached;\n\t\t}\n\t} else {\n\t\tlogger.info(\n\t\t\t\"[SUBDOMAIN]\",\n\t\t\t`Force refresh requested, skipping cache for memberId ${memberId}`,\n\t\t);\n\t}\n\n\t// Check manual override\n\tif (MEMBER_SUBDOMAIN_MAP[memberId]) {\n\t\tconst subdomain = MEMBER_SUBDOMAIN_MAP[memberId];\n\t\tlogger.info(\n\t\t\t\"[SUBDOMAIN]\",\n\t\t\t`Using manual override for memberId ${memberId}: ${subdomain}`,\n\t\t);\n\t\t// Cache the manual override\n\t\tsetCachedSubdomain(\"member\", memberId, subdomain, SUBDOMAIN_CACHE_TTL);\n\t\treturn subdomain;\n\t}\n\n\t// Try to detect by checking common subdomains and their HTML content\n\tlogger.info(\"[SUBDOMAIN]\", `Detecting subdomain for memberId ${memberId}...`);\n\t// Optimized: Prioritize most common subdomains first (based on usage statistics)\n\t// This reduces average detection time by testing high-probability subdomains first\n\tconst commonSubdomains = [\n\t\t\"au\", // Most common (default)\n\t\t\"uk\", // Very common\n\t\t\"us\", // Very common\n\t\t\"ca\", // Common\n\t\t\"nz\", // Common\n\t\t\"ie\", // Common (EU)\n\t\t\"za\", // Less common\n\t\t\"nl\", // Less common (EU)\n\t\t\"de\", // Less common (EU)\n\t\t\"fr\", // Less common (EU)\n\t\t\"es\", // Less common (EU)\n\t\t\"it\", // Less common (EU)\n\t\t\"cz\", // Rare\n\t\t\"dk\", // Rare\n\t\t\"se\", // Rare\n\t\t\"ex\", // Rare (experimental)\n\t];\n\n\ttry {\n\t\t// Try common subdomains and check for currency indicators\n\t\t// Primary method: Verify with HTML currency check (most reliable)\n\t\t// Secondary method: Use URL subdomain as fallback if currency check is inconclusive\n\t\tlet fallbackSubdomain: string | null = null;\n\n\t\t// Optimized: Test subdomains with early exit when match is found\n\t\t// This reduces average detection time significantly\n\t\tfor (const subdomain of commonSubdomains) {\n\t\t\tconst testSubdomainUrl = buildMovemberUrl(memberId, subdomain);\n\t\t\ttry {\n\t\t\t\tconst { html: testHtml, finalUrl } =\n\t\t\t\t\tawait fetchViaProxy(testSubdomainUrl);\n\n\t\t\t\t// Extract actual subdomain from final URL (after redirects)\n\t\t\t\tconst actualSubdomain = extractSubdomainFromUrl(finalUrl);\n\n\t\t\t\t// Early exit optimization: If we get a redirect to a valid subdomain, use it immediately\n\t\t\t\tif (actualSubdomain && actualSubdomain !== subdomain) {\n\t\t\t\t\t// URL redirected to a different subdomain - use the actual one (most reliable)\n\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t\t\t`URL redirected from ${subdomain} to ${actualSubdomain} for memberId ${memberId} (early exit)`,\n\t\t\t\t\t);\n\t\t\t\t\tsetCachedSubdomain(\n\t\t\t\t\t\t\"member\",\n\t\t\t\t\t\tmemberId,\n\t\t\t\t\t\tactualSubdomain,\n\t\t\t\t\t\tSUBDOMAIN_CACHE_TTL,\n\t\t\t\t\t);\n\t\t\t\t\treturn actualSubdomain;\n\t\t\t\t}\n\n\t\t\t\tif (testHtml && testHtml.length > 1000) {\n\t\t\t\t\t// Check HTML for currency indicators\n\t\t\t\t\tconst detectedSubdomain = detectSubdomainFromHtml(testHtml);\n\n\t\t\t\t\t// Priority 1: If HTML currency check confirms the subdomain, use it (early exit)\n\t\t\t\t\tif (\n\t\t\t\t\t\tdetectedSubdomain === subdomain ||\n\t\t\t\t\t\tdetectedSubdomain === actualSubdomain\n\t\t\t\t\t) {\n\t\t\t\t\t\t// HTML matches this subdomain's currency - this is correct\n\t\t\t\t\t\tconst confirmedSubdomain = actualSubdomain || subdomain;\n\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t\t\t\t`Found matching subdomain for memberId ${memberId}: ${confirmedSubdomain} (verified by currency, early exit)`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tsetCachedSubdomain(\n\t\t\t\t\t\t\t\"member\",\n\t\t\t\t\t\t\tmemberId,\n\t\t\t\t\t\t\tconfirmedSubdomain,\n\t\t\t\t\t\t\tSUBDOMAIN_CACHE_TTL,\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn confirmedSubdomain;\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tdetectedSubdomain &&\n\t\t\t\t\t\tdetectedSubdomain !== subdomain &&\n\t\t\t\t\t\tdetectedSubdomain !== actualSubdomain\n\t\t\t\t\t) {\n\t\t\t\t\t\t// HTML indicates a different subdomain - use the detected one (currency is reliable, early exit)\n\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t\t\t\t`HTML currency indicates ${detectedSubdomain} (tested ${subdomain}, final URL: ${actualSubdomain || subdomain}), using detected subdomain (early exit)`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tsetCachedSubdomain(\n\t\t\t\t\t\t\t\"member\",\n\t\t\t\t\t\t\tmemberId,\n\t\t\t\t\t\t\tdetectedSubdomain,\n\t\t\t\t\t\t\tSUBDOMAIN_CACHE_TTL,\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn detectedSubdomain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Can't determine from currency, but HTML is valid\n\t\t\t\t\t\t// Use actual subdomain from final URL, or tested subdomain as fallback\n\t\t\t\t\t\tconst fallbackSubdomainToUse = actualSubdomain || subdomain;\n\t\t\t\t\t\tif (!fallbackSubdomain) {\n\t\t\t\t\t\t\tfallbackSubdomain = fallbackSubdomainToUse;\n\t\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t\t\t\t\t`Found valid HTML for subdomain ${fallbackSubdomainToUse} (currency check inconclusive, storing as fallback)`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Continue to next subdomain (optimized: don't log every error to reduce noise)\n\t\t\t\tconst error = e instanceof Error ? e : new Error(String(e));\n\t\t\t\tif (error.message && !error.message.includes(\"404\")) {\n\t\t\t\t\tlogger.warn(\"[SUBDOMAIN]\", `Error trying subdomain ${subdomain}:`, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we found a fallback subdomain (valid HTML but inconclusive currency), use it\n\t\tif (fallbackSubdomain) {\n\t\t\tlogger.info(\n\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t`Using fallback subdomain for memberId ${memberId}: ${fallbackSubdomain} (no currency match found)`,\n\t\t\t);\n\t\t\tsetCachedSubdomain(\n\t\t\t\t\"member\",\n\t\t\t\tmemberId,\n\t\t\t\tfallbackSubdomain,\n\t\t\t\tSUBDOMAIN_CACHE_TTL,\n\t\t\t);\n\t\t\treturn fallbackSubdomain;\n\t\t}\n\n\t\t// If we couldn't determine by currency, try default subdomain\n\t\tconst testUrl = buildMovemberUrl(memberId, DEFAULT_SUBDOMAIN);\n\t\ttry {\n\t\t\tconst { html, finalUrl } = await fetchViaProxy(testUrl);\n\t\t\tif (html && html.length > 1000) {\n\t\t\t\t// Extract actual subdomain from final URL (after redirects)\n\t\t\t\tconst actualSubdomain =\n\t\t\t\t\textractSubdomainFromUrl(finalUrl) || DEFAULT_SUBDOMAIN;\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t\t`Using default subdomain for memberId ${memberId}: ${actualSubdomain}`,\n\t\t\t\t);\n\t\t\t\tsetCachedSubdomain(\n\t\t\t\t\t\"member\",\n\t\t\t\t\tmemberId,\n\t\t\t\t\tactualSubdomain,\n\t\t\t\t\tSUBDOMAIN_CACHE_TTL,\n\t\t\t\t);\n\t\t\t\treturn actualSubdomain;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// Continue to fallback\n\t\t\tlogger.warn(\"[SUBDOMAIN]\", \"Error trying default subdomain:\", e);\n\t\t}\n\n\t\t// Fallback to default\n\t\tlogger.warn(\n\t\t\t\"[SUBDOMAIN]\",\n\t\t\t`Could not find working subdomain for memberId ${memberId}, using default: ${DEFAULT_SUBDOMAIN}`,\n\t\t);\n\t\tsetCachedSubdomain(\n\t\t\t\"member\",\n\t\t\tmemberId,\n\t\t\tDEFAULT_SUBDOMAIN,\n\t\t\tSUBDOMAIN_CACHE_TTL,\n\t\t);\n\t\treturn DEFAULT_SUBDOMAIN;\n\t} catch (error) {\n\t\t// Track error with structured context\n\t\ttrackSubdomainError(\n\t\t\terror instanceof Error ? error : new Error(String(error)),\n\t\t\t{\n\t\t\t\tmemberId,\n\t\t\t\tmetadata: {\n\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\n\t\tlogger.warn(\n\t\t\t\"[SUBDOMAIN]\",\n\t\t\t`Failed to detect subdomain for memberId ${memberId}, using default:`,\n\t\t\terror,\n\t\t);\n\t\tsetCachedSubdomain(\n\t\t\t\"member\",\n\t\t\tmemberId,\n\t\t\tDEFAULT_SUBDOMAIN,\n\t\t\tSUBDOMAIN_CACHE_TTL,\n\t\t);\n\t\treturn DEFAULT_SUBDOMAIN;\n\t}\n}\n\n/**\n * Get subdomain for a member ID (with auto-detection)\n * @param memberId - The member ID\n * @returns The subdomain for the member\n */\nexport async function getSubdomainForMember(memberId: string): Promise<string> {\n\t// Check manual override first\n\tif (MEMBER_SUBDOMAIN_MAP[memberId]) {\n\t\treturn MEMBER_SUBDOMAIN_MAP[memberId];\n\t}\n\n\t// Auto-detect (will check cache internally)\n\treturn await detectSubdomainForMember(memberId);\n}\n\n/**\n * Detect subdomain by following redirects and checking HTML content for teams\n * @param teamId - The team ID\n * @param forceRefresh - Whether to force refresh (skip cache)\n * @returns The detected subdomain\n */\nexport async function detectSubdomainForTeam(\n\tteamId: string,\n\tforceRefresh = false,\n): Promise<string> {\n\t// Check cache first (unless forcing refresh)\n\tif (!forceRefresh) {\n\t\tconst cached = getCachedSubdomain(\"team\", teamId);\n\t\tif (cached) {\n\t\t\tlogger.info(\n\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t`Found cached subdomain for teamId ${teamId}: ${cached}`,\n\t\t\t);\n\t\t\treturn cached;\n\t\t}\n\t} else {\n\t\tlogger.info(\n\t\t\t\"[SUBDOMAIN]\",\n\t\t\t`Force refresh requested, skipping cache for teamId ${teamId}`,\n\t\t);\n\t}\n\n\t// Try to detect by checking common subdomains and their HTML content\n\tlogger.info(\"[SUBDOMAIN]\", `Detecting subdomain for teamId ${teamId}...`);\n\tconst commonSubdomains = [\n\t\t\"au\", // Most common (default)\n\t\t\"uk\", // Very common\n\t\t\"us\", // Very common\n\t\t\"ca\", // Common\n\t\t\"nz\", // Common\n\t\t\"ie\", // Common (EU)\n\t\t\"za\", // Less common\n\t\t\"nl\", // Less common (EU)\n\t\t\"de\", // Less common (EU)\n\t\t\"fr\", // Less common (EU)\n\t\t\"es\", // Less common (EU)\n\t\t\"it\", // Less common (EU)\n\t\t\"cz\", // Rare\n\t\t\"dk\", // Rare\n\t\t\"se\", // Rare\n\t\t\"ex\", // Rare (experimental)\n\t];\n\n\ttry {\n\t\tlet fallbackSubdomain: string | null = null;\n\n\t\tfor (const subdomain of commonSubdomains) {\n\t\t\tconst testSubdomainUrl = buildTeamUrl(teamId, subdomain);\n\t\t\ttry {\n\t\t\t\tconst { html: testHtml, finalUrl } =\n\t\t\t\t\tawait fetchViaProxy(testSubdomainUrl);\n\n\t\t\t\t// Extract actual subdomain from final URL (after redirects)\n\t\t\t\tconst actualSubdomain = extractSubdomainFromUrl(finalUrl);\n\n\t\t\t\t// Early exit optimization: If we get a redirect to a valid subdomain, use it immediately\n\t\t\t\tif (actualSubdomain && actualSubdomain !== subdomain) {\n\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t\t\t`URL redirected from ${subdomain} to ${actualSubdomain} for teamId ${teamId} (early exit)`,\n\t\t\t\t\t);\n\t\t\t\t\tsetCachedSubdomain(\n\t\t\t\t\t\t\"team\",\n\t\t\t\t\t\tteamId,\n\t\t\t\t\t\tactualSubdomain,\n\t\t\t\t\t\tSUBDOMAIN_CACHE_TTL,\n\t\t\t\t\t);\n\t\t\t\t\treturn actualSubdomain;\n\t\t\t\t}\n\n\t\t\t\tif (testHtml && testHtml.length > 1000) {\n\t\t\t\t\t// Check HTML for currency indicators\n\t\t\t\t\tconst detectedSubdomain = detectSubdomainFromHtml(testHtml);\n\n\t\t\t\t\t// Priority 1: If HTML currency check confirms the subdomain, use it (early exit)\n\t\t\t\t\tif (\n\t\t\t\t\t\tdetectedSubdomain === subdomain ||\n\t\t\t\t\t\tdetectedSubdomain === actualSubdomain\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst confirmedSubdomain = actualSubdomain || subdomain;\n\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t\t\t\t`Found matching subdomain for teamId ${teamId}: ${confirmedSubdomain} (verified by currency, early exit)`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tsetCachedSubdomain(\n\t\t\t\t\t\t\t\"team\",\n\t\t\t\t\t\t\tteamId,\n\t\t\t\t\t\t\tconfirmedSubdomain,\n\t\t\t\t\t\t\tSUBDOMAIN_CACHE_TTL,\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn confirmedSubdomain;\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tdetectedSubdomain &&\n\t\t\t\t\t\tdetectedSubdomain !== subdomain &&\n\t\t\t\t\t\tdetectedSubdomain !== actualSubdomain\n\t\t\t\t\t) {\n\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t\t\t\t`HTML currency indicates ${detectedSubdomain} (tested ${subdomain}, final URL: ${actualSubdomain || subdomain}), using detected subdomain (early exit)`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tsetCachedSubdomain(\n\t\t\t\t\t\t\t\"team\",\n\t\t\t\t\t\t\tteamId,\n\t\t\t\t\t\t\tdetectedSubdomain,\n\t\t\t\t\t\t\tSUBDOMAIN_CACHE_TTL,\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn detectedSubdomain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst fallbackSubdomainToUse = actualSubdomain || subdomain;\n\t\t\t\t\t\tif (!fallbackSubdomain) {\n\t\t\t\t\t\t\tfallbackSubdomain = fallbackSubdomainToUse;\n\t\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t\t\t\t\t`Found valid HTML for subdomain ${fallbackSubdomainToUse} (currency check inconclusive, storing as fallback)`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconst error = e instanceof Error ? e : new Error(String(e));\n\t\t\t\tif (error.message && !error.message.includes(\"404\")) {\n\t\t\t\t\tlogger.warn(\"[SUBDOMAIN]\", `Error trying subdomain ${subdomain}:`, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we found a fallback subdomain (valid HTML but inconclusive currency), use it\n\t\tif (fallbackSubdomain) {\n\t\t\tlogger.info(\n\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t`Using fallback subdomain for teamId ${teamId}: ${fallbackSubdomain} (no currency match found)`,\n\t\t\t);\n\t\t\tsetCachedSubdomain(\n\t\t\t\t\"team\",\n\t\t\t\tteamId,\n\t\t\t\tfallbackSubdomain,\n\t\t\t\tSUBDOMAIN_CACHE_TTL,\n\t\t\t);\n\t\t\treturn fallbackSubdomain;\n\t\t}\n\n\t\t// If we couldn't determine by currency, try default subdomain\n\t\tconst testUrl = buildTeamUrl(teamId, DEFAULT_SUBDOMAIN);\n\t\ttry {\n\t\t\tconst { html, finalUrl } = await fetchViaProxy(testUrl);\n\t\t\tif (html && html.length > 1000) {\n\t\t\t\tconst actualSubdomain =\n\t\t\t\t\textractSubdomainFromUrl(finalUrl) || DEFAULT_SUBDOMAIN;\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"[SUBDOMAIN]\",\n\t\t\t\t\t`Using default subdomain for teamId ${teamId}: ${actualSubdomain}`,\n\t\t\t\t);\n\t\t\t\tsetCachedSubdomain(\n\t\t\t\t\t\"team\",\n\t\t\t\t\tteamId,\n\t\t\t\t\tactualSubdomain,\n\t\t\t\t\tSUBDOMAIN_CACHE_TTL,\n\t\t\t\t);\n\t\t\t\treturn actualSubdomain;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tlogger.warn(\"[SUBDOMAIN]\", \"Error trying default subdomain:\", e);\n\t\t}\n\n\t\t// Fallback to default\n\t\tlogger.warn(\n\t\t\t\"[SUBDOMAIN]\",\n\t\t\t`Could not find working subdomain for teamId ${teamId}, using default: ${DEFAULT_SUBDOMAIN}`,\n\t\t);\n\t\tsetCachedSubdomain(\"team\", teamId, DEFAULT_SUBDOMAIN, SUBDOMAIN_CACHE_TTL);\n\t\treturn DEFAULT_SUBDOMAIN;\n\t} catch (error) {\n\t\ttrackSubdomainError(\n\t\t\terror instanceof Error ? error : new Error(String(error)),\n\t\t\t{\n\t\t\t\tmemberId: teamId,\n\t\t\t\tmetadata: {\n\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\n\t\tlogger.warn(\n\t\t\t\"[SUBDOMAIN]\",\n\t\t\t`Failed to detect subdomain for teamId ${teamId}, using default:`,\n\t\t\terror,\n\t\t);\n\t\tsetCachedSubdomain(\"team\", teamId, DEFAULT_SUBDOMAIN, SUBDOMAIN_CACHE_TTL);\n\t\treturn DEFAULT_SUBDOMAIN;\n\t}\n}\n\n/**\n * Get subdomain for a team ID (with auto-detection)\n * @param teamId - The team ID\n * @returns The subdomain for the team\n */\nexport async function getSubdomainForTeam(teamId: string): Promise<string> {\n\t// Auto-detect (will check cache internally)\n\treturn await detectSubdomainForTeam(teamId);\n}\n", "/**\n * Main orchestration logic for scraping Movember pages\n * @module scraper/orchestrator\n */\n\nimport {\n\ttype CachedData,\n\tclearSubdomainCache,\n\tgetCachedData,\n\tgetStaleCachedData,\n\tisCachedDataStale,\n\tsetCachedData,\n\tsetCachedSubdomain,\n} from \"../cache.js\";\nimport {\n\tCACHE_TTL,\n\tgetCurrencySymbol,\n\tMAX_RETRIES,\n\tRETRY_DELAYS,\n\tSUBDOMAIN_CACHE_TTL,\n} from \"../constants.js\";\nimport { trackScrapingError } from \"../error-tracking.js\";\nimport { formatDuration, sleep } from \"../formatting.js\";\nimport logger from \"../logger.js\";\nimport { calculatePercentage, isValidNumber, parseAmount } from \"../parsing.js\";\nimport { extractAmounts } from \"./html-parsing.js\";\nimport {\n\tbuildMovemberUrl,\n\tbuildTeamUrl,\n\textractSubdomainFromUrl,\n\tfetchViaProxy,\n} from \"./network.js\";\nimport {\n\tdetectSubdomainForMember,\n\tdetectSubdomainForTeam,\n\tdetectSubdomainFromHtml,\n\tgetSubdomainForMember,\n\tgetSubdomainForTeam,\n} from \"./subdomain.js\";\n\nexport interface ScrapedData extends CachedData {\n\tamount: string;\n\tcurrency: string;\n\tsubdomain: string;\n\ttimestamp: number;\n\ttarget?: string;\n\tpercentage?: number;\n}\n\nexport interface GetDataResult {\n\tdata: ScrapedData;\n\tcacheStatus: \"HIT\" | \"MISS\" | \"STALE\" | \"LIVE\";\n}\n\n/**\n * Scrape the Movember page using Worker's CORS proxy and HTML parsing\n * @param memberId - The member ID to scrape\n * @param clearSubdomainOn404 - Whether to clear subdomain cache on 404 errors\n * @returns The scraped data\n * @throws If scraping fails\n */\nexport async function scrapeMovemberPage(\n\tmemberId: string,\n\tclearSubdomainOn404 = false,\n): Promise<ScrapedData> {\n\tlet subdomain = await getSubdomainForMember(memberId);\n\tconst movemberUrl = buildMovemberUrl(memberId, subdomain);\n\tconst startTime = Date.now();\n\tlogger.info(\n\t\t\"[SCRAPE]\",\n\t\t`Starting scrape of Movember page: ${movemberUrl} (subdomain: ${subdomain})`,\n\t);\n\n\ttry {\n\t\t// Fetch the HTML via Worker's CORS proxy\n\t\tlogger.info(\"[SCRAPE]\", `Fetching HTML from ${movemberUrl} via proxy...`);\n\t\tconst fetchStart = Date.now();\n\t\tlet html: string;\n\t\tlet finalUrl: string;\n\n\t\ttry {\n\t\t\tconst result = await fetchViaProxy(movemberUrl);\n\t\t\thtml = result.html;\n\t\t\tfinalUrl = result.finalUrl;\n\t\t} catch (error) {\n\t\t\t// If we get an error, try clearing subdomain cache and re-detecting\n\t\t\tif (\n\t\t\t\tclearSubdomainOn404 &&\n\t\t\t\terror instanceof Error &&\n\t\t\t\terror.message.includes(\"404\")\n\t\t\t) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t`Got 404 for ${movemberUrl}, clearing cached subdomain and re-detecting...`,\n\t\t\t\t);\n\t\t\t\tclearSubdomainCache(\"member\", memberId);\n\t\t\t\t// Re-detect subdomain with force refresh\n\t\t\t\tconst newSubdomain = await detectSubdomainForMember(memberId, true);\n\t\t\t\tif (newSubdomain !== subdomain) {\n\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t\t`Re-detected subdomain: ${newSubdomain} (was ${subdomain}), retrying with new subdomain...`,\n\t\t\t\t\t);\n\t\t\t\t\t// Retry with new subdomain\n\t\t\t\t\tconst newUrl = buildMovemberUrl(memberId, newSubdomain);\n\t\t\t\t\tconst retryResult = await fetchViaProxy(newUrl);\n\t\t\t\t\thtml = retryResult.html;\n\t\t\t\t\tfinalUrl = retryResult.finalUrl;\n\t\t\t\t\tsubdomain = newSubdomain;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`HTTP error! status: 404 (page not found - member may not exist)`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\tconst fetchDuration = Date.now() - fetchStart;\n\t\tlogger.info(\n\t\t\t\"[SCRAPE]\",\n\t\t\t`HTML fetched successfully in ${formatDuration(fetchDuration)} (${html.length} characters)`,\n\t\t);\n\n\t\t// Check if URL redirected to a different subdomain\n\t\tconst actualSubdomain = extractSubdomainFromUrl(finalUrl);\n\t\tif (actualSubdomain && actualSubdomain !== subdomain) {\n\t\t\tlogger.info(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`URL redirected from ${subdomain} to ${actualSubdomain}, updating subdomain...`,\n\t\t\t);\n\t\t\tsubdomain = actualSubdomain;\n\t\t\t// Update cache with correct subdomain\n\t\t\tsetCachedSubdomain(\"member\", memberId, subdomain, SUBDOMAIN_CACHE_TTL);\n\t\t}\n\n\t\t// Verify subdomain by checking HTML content for currency indicators (optional verification only)\n\t\tconst htmlDetectedSubdomain = detectSubdomainFromHtml(html);\n\t\tif (htmlDetectedSubdomain && htmlDetectedSubdomain !== subdomain) {\n\t\t\tlogger.warn(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`HTML currency indicates subdomain ${htmlDetectedSubdomain} but URL subdomain is ${subdomain}. Trusting URL subdomain (primary source).`,\n\t\t\t);\n\t\t\t// Don't override - trust the URL subdomain we're using\n\t\t} else if (htmlDetectedSubdomain === subdomain) {\n\t\t\tlogger.info(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`HTML currency verification confirms subdomain ${subdomain}`,\n\t\t\t);\n\t\t}\n\n\t\t// Extract data from HTML\n\t\tconst { raised, target } = extractAmounts(html, memberId, subdomain);\n\n\t\t// Final validation check - ensure raised is actually valid before using\n\t\tif (!raised || !isValidNumber(raised)) {\n\t\t\t// Debug: Try to find any dollar amounts in the HTML to help diagnose\n\t\t\tconst allDollarAmounts = html.match(/\\$[\\d,]+(?:\\.\\d+)?/g);\n\t\t\tlogger.warn(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`Found ${allDollarAmounts ? allDollarAmounts.length : 0} dollar amounts in HTML:`,\n\t\t\t\tallDollarAmounts ? allDollarAmounts.slice(0, 10) : [],\n\t\t\t); // Show first 10\n\n\t\t\t// Try to find any numbers that might be amounts\n\t\t\tconst potentialAmounts = html.match(/[\\d,]{3,}(?:\\.\\d+)?/g);\n\t\t\tlogger.warn(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`Found ${potentialAmounts ? potentialAmounts.length : 0} potential amount numbers in HTML (showing first 20):`,\n\t\t\t\tpotentialAmounts ? potentialAmounts.slice(0, 20) : [],\n\t\t\t);\n\n\t\t\tconst errorDetails = {\n\t\t\t\tmemberId,\n\t\t\t\tsubdomain,\n\t\t\t\turl: movemberUrl,\n\t\t\t\tmessage:\n\t\t\t\t\t\"Could not find raised amount in HTML. The page may require JavaScript execution or the HTML structure may have changed.\",\n\t\t\t\thtmlLength: html.length,\n\t\t\t\tdollarAmountsFound: allDollarAmounts ? allDollarAmounts.length : 0,\n\t\t\t\traisedValue: raised || \"empty\",\n\t\t\t};\n\t\t\tlogger.error(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\"Failed to extract raised amount:\",\n\t\t\t\terrorDetails,\n\t\t\t);\n\t\t\tthrow new Error(\n\t\t\t\t`Could not find raised amount in HTML for memberId ${memberId} (subdomain: ${subdomain}). The page may require JavaScript execution or the HTML structure may have changed. Found ${allDollarAmounts ? allDollarAmounts.length : 0} dollar amounts in HTML.`,\n\t\t\t);\n\t\t}\n\n\t\t// Double-check that raised is valid before parsing\n\t\tif (!isValidNumber(raised)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Invalid raised value captured: \"${raised}\" for memberId ${memberId}`,\n\t\t\t);\n\t\t}\n\n\t\t// Parse amount with subdomain to determine correct currency\n\t\tconst { value: raisedValue, currency } = parseAmount(\n\t\t\t`$${raised}`,\n\t\t\tsubdomain,\n\t\t);\n\n\t\t// Validate the parsed value is not empty or zero (unless it's actually zero)\n\t\tif (!raisedValue || raisedValue === \"0\" || raisedValue === \"\") {\n\t\t\tlogger.warn(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`Parsed raised value is invalid: \"${raisedValue}\" from input: \"${raised}\"`,\n\t\t\t);\n\t\t}\n\n\t\t// Format amount with appropriate currency symbol\n\t\tconst currencySymbol = getCurrencySymbol(currency);\n\t\tconst raisedFormatted = `${currencySymbol}${raisedValue}`;\n\n\t\tconst result: ScrapedData = {\n\t\t\tamount: raisedFormatted,\n\t\t\tcurrency,\n\t\t\tsubdomain, // Include subdomain in result for consolidated cache\n\t\t\ttimestamp: Date.now(),\n\t\t};\n\n\t\tif (target && isValidNumber(target)) {\n\t\t\tconst { value: targetValue } = parseAmount(`$${target}`, subdomain);\n\t\t\t// Use the same currency symbol for consistency\n\t\t\tconst targetFormatted = `${currencySymbol}${targetValue}`;\n\t\t\tresult.target = targetFormatted;\n\t\t\tresult.percentage = calculatePercentage(raisedValue, targetValue);\n\t\t} else if (target) {\n\t\t\tlogger.warn(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`Target value \"${target}\" failed validation, skipping target`,\n\t\t\t);\n\t\t}\n\n\t\tconst totalDuration = Date.now() - startTime;\n\t\tlogger.info(\n\t\t\t\"[SCRAPE]\",\n\t\t\t`Scraping completed successfully in ${formatDuration(totalDuration)}:`,\n\t\t\t{\n\t\t\t\tamount: result.amount,\n\t\t\t\ttarget: result.target,\n\t\t\t\tpercentage: result.percentage,\n\t\t\t\tcurrency: result.currency,\n\t\t\t\tsubdomain: result.subdomain,\n\t\t\t},\n\t\t);\n\n\t\treturn result;\n\t} catch (error) {\n\t\tconst totalDuration = Date.now() - startTime;\n\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\n\t\t// Track error with structured context\n\t\ttrackScrapingError(\n\t\t\terror instanceof Error ? error : new Error(errorMessage),\n\t\t\t{\n\t\t\t\tmemberId,\n\t\t\t\tsubdomain,\n\t\t\t\turl: movemberUrl,\n\t\t\t\tmetadata: {\n\t\t\t\t\tduration: totalDuration,\n\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\n\t\tlogger.error(\n\t\t\t\"[SCRAPE]\",\n\t\t\t`Scraping failed after ${formatDuration(totalDuration)}:`,\n\t\t\terrorMessage,\n\t\t\terror,\n\t\t);\n\t\tthrow error;\n\t}\n}\n\n/**\n * Retry wrapper with exponential backoff\n * @param memberId - The member ID to scrape\n * @returns The scraped data\n * @throws If all retries fail\n */\nexport async function scrapeWithRetry(memberId: string): Promise<ScrapedData> {\n\tlet lastError: Error | null = null;\n\tconst retryStartTime = Date.now();\n\n\tlogger.info(\n\t\t\"[RETRY]\",\n\t\t`Starting retry logic (max ${MAX_RETRIES} attempts) for memberId: ${memberId}`,\n\t);\n\n\tfor (let attempt = 0; attempt < MAX_RETRIES; attempt++) {\n\t\ttry {\n\t\t\tlogger.info(\"[RETRY]\", `Attempt ${attempt + 1}/${MAX_RETRIES}`);\n\t\t\t// Enable subdomain clearing on 404 for retries (especially on first attempt)\n\t\t\tconst clearSubdomainOn404 =\n\t\t\t\tattempt === 0 || lastError?.message.includes(\"404\");\n\t\t\tconst result = await scrapeMovemberPage(memberId, clearSubdomainOn404);\n\t\t\tconst totalDuration = Date.now() - retryStartTime;\n\t\t\tlogger.info(\n\t\t\t\t\"[RETRY]\",\n\t\t\t\t`Success on attempt ${attempt + 1} after ${totalDuration}ms`,\n\t\t\t);\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tlastError = error instanceof Error ? error : new Error(String(error));\n\t\t\tconst errorMessage = lastError.message;\n\t\t\tlogger.error(\"[RETRY]\", `Attempt ${attempt + 1} failed:`, errorMessage);\n\n\t\t\t// If we got a 404, clear the subdomain cache before retrying\n\t\t\tif (errorMessage.includes(\"404\")) {\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"[RETRY]\",\n\t\t\t\t\t`404 detected, clearing subdomain cache for memberId: ${memberId}`,\n\t\t\t\t);\n\t\t\t\tclearSubdomainCache(\"member\", memberId);\n\t\t\t}\n\n\t\t\tif (attempt < MAX_RETRIES - 1) {\n\t\t\t\tconst delay =\n\t\t\t\t\tRETRY_DELAYS[attempt] || RETRY_DELAYS[RETRY_DELAYS.length - 1];\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"[RETRY]\",\n\t\t\t\t\t`Waiting ${delay}ms before retry ${attempt + 2}...`,\n\t\t\t\t);\n\t\t\t\tawait sleep(delay);\n\t\t\t} else {\n\t\t\t\tconst totalDuration = Date.now() - retryStartTime;\n\t\t\t\tlogger.error(\n\t\t\t\t\t\"[RETRY]\",\n\t\t\t\t\t`All ${MAX_RETRIES} attempts failed after ${totalDuration}ms`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow lastError || new Error(\"Failed to scrape after all retries\");\n}\n\n/**\n * Main function to get data (with stale-while-revalidate caching)\n * Implements stale-while-revalidate pattern: returns stale data immediately if available,\n * then fetches fresh data in the background and updates cache\n * @param memberId - The member ID to get data for\n * @param grabLive - Whether to force a fresh scrape (bypass cache)\n * @returns The data and cache status\n */\nexport async function getData(\n\tmemberId: string,\n\tgrabLive = false,\n): Promise<GetDataResult> {\n\tlet data: ScrapedData | null = null;\n\tlet cacheStatus: GetDataResult[\"cacheStatus\"] = \"HIT\";\n\n\tif (grabLive) {\n\t\t// Force fresh scrape, bypass cache\n\t\tlogger.info(\n\t\t\t\"[LIVE]\",\n\t\t\t`grab-live parameter detected - forcing fresh scrape for memberId: ${memberId}`,\n\t\t);\n\t\tdata = await scrapeWithRetry(memberId);\n\t\tcacheStatus = \"LIVE\";\n\n\t\t// Store in cache with 5-minute TTL\n\t\tlogger.info(\n\t\t\t\"[CACHE]\",\n\t\t\t`Storing live data in cache with TTL: ${CACHE_TTL}ms for memberId: ${memberId}`,\n\t\t);\n\t\tsetCachedData(\"member\", memberId, data, CACHE_TTL);\n\t\tlogger.info(\"[CACHE]\", \"Live data stored successfully\");\n\t} else {\n\t\t// Check cache first (fresh data)\n\t\tlogger.info(\"[CACHE]\", `Checking cache for memberId: ${memberId}`);\n\t\tdata = getCachedData(\"member\", memberId);\n\n\t\tif (data) {\n\t\t\tconst cacheAge = Date.now() - data.timestamp;\n\t\t\tlogger.info(\n\t\t\t\t\"[CACHE]\",\n\t\t\t\t`Cache HIT - data age: ${Math.round(cacheAge / 1000)}s for memberId: ${memberId}`,\n\t\t\t\t{\n\t\t\t\t\tamount: data.amount,\n\t\t\t\t\ttarget: data.target,\n\t\t\t\t\ttimestamp: new Date(data.timestamp).toISOString(),\n\t\t\t\t},\n\t\t\t);\n\t\t} else {\n\t\t\t// Check for stale data (stale-while-revalidate pattern)\n\t\t\tconst staleData = getStaleCachedData(\"member\", memberId);\n\t\t\tconst isStale = isCachedDataStale(\"member\", memberId);\n\n\t\t\tif (staleData && isStale) {\n\t\t\t\t// Return stale data immediately (stale-while-revalidate)\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"[CACHE]\",\n\t\t\t\t\t`Cache STALE - returning stale data immediately, fetching fresh data in background for memberId: ${memberId}`,\n\t\t\t\t);\n\t\t\t\tdata = staleData;\n\t\t\t\tcacheStatus = \"STALE\";\n\n\t\t\t\t// Fetch fresh data in background (don't await)\n\t\t\t\t// This updates the cache for the next request\n\t\t\t\tscrapeWithRetry(memberId)\n\t\t\t\t\t.then((freshData) => {\n\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\"[CACHE]\",\n\t\t\t\t\t\t\t`Background refresh completed for memberId: ${memberId}, updating cache`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tsetCachedData(\"member\", memberId, freshData, CACHE_TTL);\n\t\t\t\t\t})\n\t\t\t\t\t.catch((error) => {\n\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t\"[CACHE]\",\n\t\t\t\t\t\t\t`Background refresh failed for memberId: ${memberId}:`,\n\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// No cache at all, need to scrape\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"[CACHE]\",\n\t\t\t\t\t`Cache MISS - need to scrape for memberId: ${memberId}`,\n\t\t\t\t);\n\t\t\t\tdata = await scrapeWithRetry(memberId);\n\t\t\t\tcacheStatus = \"MISS\";\n\n\t\t\t\t// Store in cache with 5-minute TTL\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"[CACHE]\",\n\t\t\t\t\t`Storing data in cache with TTL: ${CACHE_TTL}ms for memberId: ${memberId}`,\n\t\t\t\t);\n\t\t\t\tsetCachedData(\"member\", memberId, data, CACHE_TTL);\n\t\t\t\tlogger.info(\"[CACHE]\", \"Data stored successfully\");\n\t\t\t}\n\t\t}\n\t}\n\n\t// Type guard: data should never be null at this point, but TypeScript can't guarantee it\n\t// This is a safety check in case of unexpected code paths\n\tif (!data) {\n\t\tthrow new Error(\n\t\t\t`Unexpected null data for memberId: ${memberId}. This should never happen.`,\n\t\t);\n\t}\n\n\treturn { data, cacheStatus };\n}\n\n/**\n * Scrape the Movember team page using Worker's CORS proxy and HTML parsing\n * @param teamId - The team ID to scrape\n * @param clearSubdomainOn404 - Whether to clear subdomain cache on 404 errors\n * @returns The scraped data\n * @throws If scraping fails\n */\nexport async function scrapeTeamPage(\n\tteamId: string,\n\tclearSubdomainOn404 = false,\n): Promise<ScrapedData> {\n\tlet subdomain = await getSubdomainForTeam(teamId);\n\tconst teamUrl = buildTeamUrl(teamId, subdomain);\n\tconst startTime = Date.now();\n\tlogger.info(\n\t\t\"[SCRAPE]\",\n\t\t`Starting scrape of Movember team page: ${teamUrl} (subdomain: ${subdomain})`,\n\t);\n\n\ttry {\n\t\t// Fetch the HTML via Worker's CORS proxy\n\t\tlogger.info(\"[SCRAPE]\", `Fetching HTML from ${teamUrl} via proxy...`);\n\t\tconst fetchStart = Date.now();\n\t\tlet html: string;\n\t\tlet finalUrl: string;\n\n\t\ttry {\n\t\t\tconst result = await fetchViaProxy(teamUrl);\n\t\t\thtml = result.html;\n\t\t\tfinalUrl = result.finalUrl;\n\t\t} catch (error) {\n\t\t\t// If we get an error, try clearing subdomain cache and re-detecting\n\t\t\tif (\n\t\t\t\tclearSubdomainOn404 &&\n\t\t\t\terror instanceof Error &&\n\t\t\t\terror.message.includes(\"404\")\n\t\t\t) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t`Got 404 for ${teamUrl}, clearing cached subdomain and re-detecting...`,\n\t\t\t\t);\n\t\t\t\tclearSubdomainCache(\"team\", teamId);\n\t\t\t\t// Re-detect subdomain with force refresh\n\t\t\t\tconst newSubdomain = await detectSubdomainForTeam(teamId, true);\n\t\t\t\tif (newSubdomain !== subdomain) {\n\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\t\t`Re-detected subdomain: ${newSubdomain} (was ${subdomain}), retrying with new subdomain...`,\n\t\t\t\t\t);\n\t\t\t\t\t// Retry with new subdomain\n\t\t\t\t\tconst newUrl = buildTeamUrl(teamId, newSubdomain);\n\t\t\t\t\tconst retryResult = await fetchViaProxy(newUrl);\n\t\t\t\t\thtml = retryResult.html;\n\t\t\t\t\tfinalUrl = retryResult.finalUrl;\n\t\t\t\t\tsubdomain = newSubdomain;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`HTTP error! status: 404 (page not found - team may not exist)`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\tconst fetchDuration = Date.now() - fetchStart;\n\t\tlogger.info(\n\t\t\t\"[SCRAPE]\",\n\t\t\t`HTML fetched successfully in ${formatDuration(fetchDuration)} (${html.length} characters)`,\n\t\t);\n\n\t\t// Check if URL redirected to a different subdomain\n\t\tconst actualSubdomain = extractSubdomainFromUrl(finalUrl);\n\t\tif (actualSubdomain && actualSubdomain !== subdomain) {\n\t\t\tlogger.info(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`URL redirected from ${subdomain} to ${actualSubdomain}, updating subdomain...`,\n\t\t\t);\n\t\t\tsubdomain = actualSubdomain;\n\t\t\t// Update cache with correct subdomain\n\t\t\tsetCachedSubdomain(\"team\", teamId, subdomain, SUBDOMAIN_CACHE_TTL);\n\t\t}\n\n\t\t// Verify subdomain by checking HTML content for currency indicators (optional verification only)\n\t\tconst htmlDetectedSubdomain = detectSubdomainFromHtml(html);\n\t\tif (htmlDetectedSubdomain && htmlDetectedSubdomain !== subdomain) {\n\t\t\tlogger.warn(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`HTML currency indicates subdomain ${htmlDetectedSubdomain} but URL subdomain is ${subdomain}. Trusting URL subdomain (primary source).`,\n\t\t\t);\n\t\t\t// Don't override - trust the URL subdomain we're using\n\t\t} else if (htmlDetectedSubdomain === subdomain) {\n\t\t\tlogger.info(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`HTML currency verification confirms subdomain ${subdomain}`,\n\t\t\t);\n\t\t}\n\n\t\t// Extract data from HTML\n\t\tconst { raised, target } = extractAmounts(html, teamId, subdomain);\n\n\t\t// Final validation check - ensure raised is actually valid before using\n\t\tif (!raised || !isValidNumber(raised)) {\n\t\t\t// Debug: Try to find any dollar amounts in the HTML to help diagnose\n\t\t\tconst allDollarAmounts = html.match(/\\$[\\d,]+(?:\\.\\d+)?/g);\n\t\t\tlogger.warn(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`Found ${allDollarAmounts ? allDollarAmounts.length : 0} dollar amounts in HTML:`,\n\t\t\t\tallDollarAmounts ? allDollarAmounts.slice(0, 10) : [],\n\t\t\t); // Show first 10\n\n\t\t\t// Try to find any numbers that might be amounts\n\t\t\tconst potentialAmounts = html.match(/[\\d,]{3,}(?:\\.\\d+)?/g);\n\t\t\tlogger.warn(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`Found ${potentialAmounts ? potentialAmounts.length : 0} potential amount numbers in HTML (showing first 20):`,\n\t\t\t\tpotentialAmounts ? potentialAmounts.slice(0, 20) : [],\n\t\t\t);\n\n\t\t\tconst errorDetails = {\n\t\t\t\tteamId,\n\t\t\t\tsubdomain,\n\t\t\t\turl: teamUrl,\n\t\t\t\tmessage:\n\t\t\t\t\t\"Could not find raised amount in HTML. The page may require JavaScript execution or the HTML structure may have changed.\",\n\t\t\t\thtmlLength: html.length,\n\t\t\t\tdollarAmountsFound: allDollarAmounts ? allDollarAmounts.length : 0,\n\t\t\t\traisedValue: raised || \"empty\",\n\t\t\t};\n\t\t\tlogger.error(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t\"Failed to extract raised amount:\",\n\t\t\t\terrorDetails,\n\t\t\t);\n\t\t\tthrow new Error(\n\t\t\t\t`Could not find raised amount in HTML for teamId ${teamId} (subdomain: ${subdomain}). The page may require JavaScript execution or the HTML structure may have changed. Found ${allDollarAmounts ? allDollarAmounts.length : 0} dollar amounts in HTML.`,\n\t\t\t);\n\t\t}\n\n\t\t// Double-check that raised is valid before parsing\n\t\tif (!isValidNumber(raised)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Invalid raised value captured: \"${raised}\" for teamId ${teamId}`,\n\t\t\t);\n\t\t}\n\n\t\t// Parse amount with subdomain to determine correct currency\n\t\tconst { value: raisedValue, currency } = parseAmount(\n\t\t\t`$${raised}`,\n\t\t\tsubdomain,\n\t\t);\n\n\t\t// Validate the parsed value is not empty or zero (unless it's actually zero)\n\t\tif (!raisedValue || raisedValue === \"0\" || raisedValue === \"\") {\n\t\t\tlogger.warn(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`Parsed raised value is invalid: \"${raisedValue}\" from input: \"${raised}\"`,\n\t\t\t);\n\t\t}\n\n\t\t// Format amount with appropriate currency symbol\n\t\tconst currencySymbol = getCurrencySymbol(currency);\n\t\tconst raisedFormatted = `${currencySymbol}${raisedValue}`;\n\n\t\tconst result: ScrapedData = {\n\t\t\tamount: raisedFormatted,\n\t\t\tcurrency,\n\t\t\tsubdomain, // Include subdomain in result for consolidated cache\n\t\t\ttimestamp: Date.now(),\n\t\t};\n\n\t\tif (target && isValidNumber(target)) {\n\t\t\tconst { value: targetValue } = parseAmount(`$${target}`, subdomain);\n\t\t\t// Use the same currency symbol for consistency\n\t\t\tconst targetFormatted = `${currencySymbol}${targetValue}`;\n\t\t\tresult.target = targetFormatted;\n\t\t\tresult.percentage = calculatePercentage(raisedValue, targetValue);\n\t\t} else if (target) {\n\t\t\tlogger.warn(\n\t\t\t\t\"[SCRAPE]\",\n\t\t\t\t`Target value \"${target}\" failed validation, skipping target`,\n\t\t\t);\n\t\t}\n\n\t\tconst totalDuration = Date.now() - startTime;\n\t\tlogger.info(\n\t\t\t\"[SCRAPE]\",\n\t\t\t`Scraping completed successfully in ${formatDuration(totalDuration)}:`,\n\t\t\t{\n\t\t\t\tamount: result.amount,\n\t\t\t\ttarget: result.target,\n\t\t\t\tpercentage: result.percentage,\n\t\t\t\tcurrency: result.currency,\n\t\t\t\tsubdomain: result.subdomain,\n\t\t\t},\n\t\t);\n\n\t\treturn result;\n\t} catch (error) {\n\t\tconst totalDuration = Date.now() - startTime;\n\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\n\t\t// Track error with structured context\n\t\ttrackScrapingError(\n\t\t\terror instanceof Error ? error : new Error(errorMessage),\n\t\t\t{\n\t\t\t\tmemberId: teamId,\n\t\t\t\tsubdomain,\n\t\t\t\turl: teamUrl,\n\t\t\t\tmetadata: {\n\t\t\t\t\tduration: totalDuration,\n\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\n\t\tlogger.error(\n\t\t\t\"[SCRAPE]\",\n\t\t\t`Scraping failed after ${formatDuration(totalDuration)}:`,\n\t\t\terrorMessage,\n\t\t\terror,\n\t\t);\n\t\tthrow error;\n\t}\n}\n\n/**\n * Retry wrapper with exponential backoff for teams\n * @param teamId - The team ID to scrape\n * @returns The scraped data\n * @throws If all retries fail\n */\nexport async function scrapeTeamWithRetry(\n\tteamId: string,\n): Promise<ScrapedData> {\n\tlet lastError: Error | null = null;\n\tconst retryStartTime = Date.now();\n\n\tlogger.info(\n\t\t\"[RETRY]\",\n\t\t`Starting retry logic (max ${MAX_RETRIES} attempts) for teamId: ${teamId}`,\n\t);\n\n\tfor (let attempt = 0; attempt < MAX_RETRIES; attempt++) {\n\t\ttry {\n\t\t\tlogger.info(\"[RETRY]\", `Attempt ${attempt + 1}/${MAX_RETRIES}`);\n\t\t\t// Enable subdomain clearing on 404 for retries (especially on first attempt)\n\t\t\tconst clearSubdomainOn404 =\n\t\t\t\tattempt === 0 || lastError?.message.includes(\"404\");\n\t\t\tconst result = await scrapeTeamPage(teamId, clearSubdomainOn404);\n\t\t\tconst totalDuration = Date.now() - retryStartTime;\n\t\t\tlogger.info(\n\t\t\t\t\"[RETRY]\",\n\t\t\t\t`Success on attempt ${attempt + 1} after ${totalDuration}ms`,\n\t\t\t);\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tlastError = error instanceof Error ? error : new Error(String(error));\n\t\t\tconst errorMessage = lastError.message;\n\t\t\tlogger.error(\"[RETRY]\", `Attempt ${attempt + 1} failed:`, errorMessage);\n\n\t\t\t// If we got a 404, clear the subdomain cache before retrying\n\t\t\tif (errorMessage.includes(\"404\")) {\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"[RETRY]\",\n\t\t\t\t\t`404 detected, clearing subdomain cache for teamId: ${teamId}`,\n\t\t\t\t);\n\t\t\t\tclearSubdomainCache(\"team\", teamId);\n\t\t\t}\n\n\t\t\tif (attempt < MAX_RETRIES - 1) {\n\t\t\t\tconst delay =\n\t\t\t\t\tRETRY_DELAYS[attempt] || RETRY_DELAYS[RETRY_DELAYS.length - 1];\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"[RETRY]\",\n\t\t\t\t\t`Waiting ${delay}ms before retry ${attempt + 2}...`,\n\t\t\t\t);\n\t\t\t\tawait sleep(delay);\n\t\t\t} else {\n\t\t\t\tconst totalDuration = Date.now() - retryStartTime;\n\t\t\t\tlogger.error(\n\t\t\t\t\t\"[RETRY]\",\n\t\t\t\t\t`All ${MAX_RETRIES} attempts failed after ${totalDuration}ms`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow lastError || new Error(\"Failed to scrape after all retries\");\n}\n\n/**\n * Main function to get team data (with stale-while-revalidate caching)\n * Implements stale-while-revalidate pattern: returns stale data immediately if available,\n * then fetches fresh data in the background and updates cache\n * @param teamId - The team ID to get data for\n * @param grabLive - Whether to force a fresh scrape (bypass cache)\n * @returns The data and cache status\n */\nexport async function getTeamData(\n\tteamId: string,\n\tgrabLive = false,\n): Promise<GetDataResult> {\n\tlet data: ScrapedData | null = null;\n\tlet cacheStatus: GetDataResult[\"cacheStatus\"] = \"HIT\";\n\n\tif (grabLive) {\n\t\t// Force fresh scrape, bypass cache\n\t\tlogger.info(\n\t\t\t\"[LIVE]\",\n\t\t\t`grab-live parameter detected - forcing fresh scrape for teamId: ${teamId}`,\n\t\t);\n\t\tdata = await scrapeTeamWithRetry(teamId);\n\t\tcacheStatus = \"LIVE\";\n\n\t\t// Store in cache with 5-minute TTL\n\t\tlogger.info(\n\t\t\t\"[CACHE]\",\n\t\t\t`Storing live data in cache with TTL: ${CACHE_TTL}ms for teamId: ${teamId}`,\n\t\t);\n\t\tsetCachedData(\"team\", teamId, data, CACHE_TTL);\n\t\tlogger.info(\"[CACHE]\", \"Live data stored successfully\");\n\t} else {\n\t\t// Check cache first (fresh data)\n\t\tlogger.info(\"[CACHE]\", `Checking cache for teamId: ${teamId}`);\n\t\tdata = getCachedData(\"team\", teamId);\n\n\t\tif (data) {\n\t\t\tconst cacheAge = Date.now() - data.timestamp;\n\t\t\tlogger.info(\n\t\t\t\t\"[CACHE]\",\n\t\t\t\t`Cache HIT - data age: ${Math.round(cacheAge / 1000)}s for teamId: ${teamId}`,\n\t\t\t\t{\n\t\t\t\t\tamount: data.amount,\n\t\t\t\t\ttarget: data.target,\n\t\t\t\t\ttimestamp: new Date(data.timestamp).toISOString(),\n\t\t\t\t},\n\t\t\t);\n\t\t} else {\n\t\t\t// Check for stale data (stale-while-revalidate pattern)\n\t\t\tconst staleData = getStaleCachedData(\"team\", teamId);\n\t\t\tconst isStale = isCachedDataStale(\"team\", teamId);\n\n\t\t\tif (staleData && isStale) {\n\t\t\t\t// Return stale data immediately (stale-while-revalidate)\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"[CACHE]\",\n\t\t\t\t\t`Cache STALE - returning stale data immediately, fetching fresh data in background for teamId: ${teamId}`,\n\t\t\t\t);\n\t\t\t\tdata = staleData;\n\t\t\t\tcacheStatus = \"STALE\";\n\n\t\t\t\t// Fetch fresh data in background (don't await)\n\t\t\t\t// This updates the cache for the next request\n\t\t\t\tscrapeTeamWithRetry(teamId)\n\t\t\t\t\t.then((freshData) => {\n\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\"[CACHE]\",\n\t\t\t\t\t\t\t`Background refresh completed for teamId: ${teamId}, updating cache`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tsetCachedData(\"team\", teamId, freshData, CACHE_TTL);\n\t\t\t\t\t})\n\t\t\t\t\t.catch((error) => {\n\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t\"[CACHE]\",\n\t\t\t\t\t\t\t`Background refresh failed for teamId: ${teamId}:`,\n\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// No cache at all, need to scrape\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"[CACHE]\",\n\t\t\t\t\t`Cache MISS - need to scrape for teamId: ${teamId}`,\n\t\t\t\t);\n\t\t\t\tdata = await scrapeTeamWithRetry(teamId);\n\t\t\t\tcacheStatus = \"MISS\";\n\n\t\t\t\t// Store in cache with 5-minute TTL\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"[CACHE]\",\n\t\t\t\t\t`Storing data in cache with TTL: ${CACHE_TTL}ms for teamId: ${teamId}`,\n\t\t\t\t);\n\t\t\t\tsetCachedData(\"team\", teamId, data, CACHE_TTL);\n\t\t\t\tlogger.info(\"[CACHE]\", \"Data stored successfully\");\n\t\t\t}\n\t\t}\n\t}\n\n\t// Type guard: data should never be null at this point, but TypeScript can't guarantee it\n\t// This is a safety check in case of unexpected code paths\n\tif (!data) {\n\t\tthrow new Error(\n\t\t\t`Unexpected null data for teamId: ${teamId}. This should never happen.`,\n\t\t);\n\t}\n\n\treturn { data, cacheStatus };\n}\n"],
  "mappings": "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",
  "names": ["MEMBER_SUBDOMAIN_MAP", "MOVEMBER_BASE_URL_TEMPLATE", "MOVEMBER_TEAM_URL_TEMPLATE", "DEFAULT_MEMBER_ID", "RETRY_DELAYS", "SUBDOMAIN_CURRENCY_MAP", "getCurrencyFromSubdomain", "subdomain", "CURRENCY_SYMBOL_MAP", "getCurrencySymbol", "currencyCode", "getProxyUrl", "formatDuration", "ms", "seconds", "minutes", "remainingSeconds", "sleep", "resolve", "LOG_LEVELS", "currentLogLevel", "initializeLogLevel", "stored", "level", "error", "formatMessage", "prefix", "args", "shouldLog", "logger", "upperLevel", "name", "value", "logger_default", "parseAmount", "text", "subdomain", "cleaned", "currency", "getCurrencyFromSubdomain", "amountMatch", "isValidNumber", "value", "calculatePercentage", "raised", "target", "raisedNum", "targetNum", "URL_PATTERNS", "CURRENCY_CODE_PATTERNS", "COUNTRY_DETECTION_PATTERNS", "DOLLAR_AMOUNT_PATTERN", "RAISED_PATTERNS", "TARGET_PATTERNS", "RAISED_JSON_PATTERNS", "TARGET_JSON_PATTERNS", "GENERIC_RAISED_PATTERNS", "GENERIC_TARGET_PATTERNS", "extractRaisedAmountWithDOMParser", "html", "doc", "selectors", "selector", "elements", "element", "amountMatch", "isValidNumber", "logger", "dataRaised", "scriptTags", "script", "scriptContent", "i", "RAISED_JSON_PATTERNS", "pattern", "match", "captured", "error", "extractRaisedAmount", "raised", "RAISED_PATTERNS", "scriptTagMatches", "scriptTag", "GENERIC_RAISED_PATTERNS", "allDollarMatches", "scoredAmounts", "amount", "matchIndex", "contextStart", "contextEnd", "context", "raisedScore", "a", "b", "raisedCandidates", "extractTargetAmountWithDOMParser", "dataTarget", "TARGET_JSON_PATTERNS", "extractTargetAmount", "target", "TARGET_PATTERNS", "GENERIC_TARGET_PATTERNS", "j", "targetScore", "targetCandidates", "extractAmounts", "memberId", "subdomain", "extractStart", "extractDuration", "formatDuration", "ERROR_SEVERITY", "ERROR_CATEGORY", "ERROR_TRACKING_CONFIG", "SENSITIVE_QUERY_PARAMS", "SAFE_QUERY_PARAMS", "SENSITIVE_PATTERNS", "hashValue", "value", "hash", "i", "redactSensitive", "text", "redacted", "pattern", "sanitizeMessage", "message", "truncated", "sanitizeStack", "stack", "sanitizeUrl", "url", "urlObj", "origin", "pathname", "safeParams", "key", "lowerKey", "queryString", "withoutQuery", "purgeExpiredErrors", "errors", "now", "error", "enforceRetentionLimit", "trackError", "context", "rawMessage", "rawStack", "messageHash", "stackHash", "expiresAt", "errorInfo", "logger_default", "storedErrors", "activeErrors", "trimmedErrors", "e", "trackScrapingError", "trackSubdomainError", "trackNetworkError", "extractSubdomainFromUrl", "url", "match", "URL_PATTERNS", "fetchViaProxy", "proxyUrl", "getProxyUrl", "response", "errorMessage", "errorData", "errorText", "e", "logger_default", "error", "trackNetworkError", "html", "finalUrl", "buildMovemberUrl", "memberId", "subdomain", "MOVEMBER_BASE_URL_TEMPLATE", "buildTeamUrl", "teamId", "MOVEMBER_TEAM_URL_TEMPLATE", "createCacheKey", "type", "id", "prefix", "getCachedData", "cacheKey", "cached", "entry", "error", "logger_default", "getStaleCachedData", "isCachedDataStale", "setCachedData", "data", "ttl", "cacheValue", "getCachedSubdomain", "setCachedSubdomain", "subdomain", "clearSubdomainCache", "subdomainKey", "oldAmountKey", "detectSubdomainFromHtml", "html", "COUNTRY_DETECTION_PATTERNS", "CURRENCY_CODE_PATTERNS", "DOLLAR_AMOUNT_PATTERN", "detectSubdomainForMember", "memberId", "forceRefresh", "logger_default", "cached", "getCachedSubdomain", "MEMBER_SUBDOMAIN_MAP", "subdomain", "setCachedSubdomain", "commonSubdomains", "fallbackSubdomain", "testSubdomainUrl", "buildMovemberUrl", "testHtml", "finalUrl", "fetchViaProxy", "actualSubdomain", "extractSubdomainFromUrl", "detectedSubdomain", "confirmedSubdomain", "fallbackSubdomainToUse", "e", "error", "testUrl", "trackSubdomainError", "getSubdomainForMember", "detectSubdomainForTeam", "teamId", "buildTeamUrl", "getSubdomainForTeam", "scrapeMovemberPage", "memberId", "clearSubdomainOn404", "subdomain", "getSubdomainForMember", "movemberUrl", "buildMovemberUrl", "startTime", "logger_default", "fetchStart", "html", "finalUrl", "result", "fetchViaProxy", "error", "clearSubdomainCache", "newSubdomain", "detectSubdomainForMember", "newUrl", "retryResult", "fetchDuration", "formatDuration", "actualSubdomain", "extractSubdomainFromUrl", "setCachedSubdomain", "htmlDetectedSubdomain", "detectSubdomainFromHtml", "raised", "target", "extractAmounts", "isValidNumber", "allDollarAmounts", "potentialAmounts", "errorDetails", "raisedValue", "currency", "parseAmount", "currencySymbol", "getCurrencySymbol", "targetValue", "targetFormatted", "calculatePercentage", "totalDuration", "errorMessage", "trackScrapingError", "scrapeWithRetry", "lastError", "retryStartTime", "attempt", "delay", "RETRY_DELAYS", "sleep", "getData", "grabLive", "data", "cacheStatus", "setCachedData", "getCachedData", "cacheAge", "staleData", "getStaleCachedData", "isStale", "isCachedDataStale", "freshData", "scrapeTeamPage", "teamId", "getSubdomainForTeam", "teamUrl", "buildTeamUrl", "detectSubdomainForTeam", "scrapeTeamWithRetry", "getTeamData"]
}
